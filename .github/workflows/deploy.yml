name: Deploy Staging & Production

on:
  push:
    branches: [main]
    # Removed 'paths' filter, using only 'paths-ignore'
    paths-ignore:
      - '**.md'
      - 'content/**'
      - 'tests/**' # Ignore test files for deployment trigger
      - 'e2e/**' # Ignore e2e test files
      - 'test/fixtures/**'
      - 'LICENSE'
      - '.gitignore'
      - 'playwright.config.ts'
      - 'lighthouserc.js'
      - 'cypress/**'
      # Add others? Maybe specific docs/config files?
  workflow_dispatch: # Allow manual trigger for retries / specific deployments

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true # Cancel older pushes to main, but consider `false` for deployments

# Define environment variable defaults accessible by all jobs
env:
  SUPABASE_PROJECT_ID: ${{ vars.SUPABASE_PROJECT_ID }} # From Repo/Org Variables
  VERCEL_ORG_ID: ${{ secrets.VERCEL_ORG_ID }} # From Repo Secrets
  VERCEL_PROJECT_ID: ${{ secrets.VERCEL_PROJECT_ID }} # From Repo Secrets
  # Use staging branch name consistently
  STAGING_BRANCH_NAME: staging-${{ github.sha }}

jobs:
  deploy-staging:
    name: Deploy to Staging
    runs-on: ubuntu-latest
    # Only run on pushes to main
    if: github.event_name == 'push' && github.ref == 'refs/heads/main'
    outputs:
      # Outputs needed for approval/promotion jobs
      preview_url: ${{ steps.vercel-deploy.outputs.preview_url }}
      preview_id: ${{ steps.vercel-deploy.outputs.preview_id }}
      supabase_branch: ${{ env.STAGING_BRANCH_NAME }}

    steps:
      - name: Setup Node + NPM Deps (Fetch All History)
        uses: ./.github/actions/setup-node-npm
        with:
          node-version: '20.x'
          fetch-depth: 0 # Vercel build needs full history

      - name: Setup Supabase CLI
        uses: ./.github/actions/setup-supabase-cli

      - name: Install Vercel CLI
        run: npm install -g vercel@latest

      - name: Verify Secrets
        run: |
          if [[ -z "${{ secrets.SUPABASE_ACCESS_TOKEN }}" ]]; then # Use SUPABASE_ACCESS_TOKEN convention
            echo "::error::Missing SUPABASE_ACCESS_TOKEN secret."
            exit 1
          fi
          if [[ -z "${{ secrets.VERCEL_TOKEN }}" ]]; then
            echo "::error::Missing VERCEL_TOKEN secret."
            exit 1
          fi
          if [[ -z "${{ env.VERCEL_ORG_ID }}" ]]; then
            echo "::error::Missing VERCEL_ORG_ID secret."
            exit 1
          fi
           if [[ -z "${{ env.VERCEL_PROJECT_ID }}" ]]; then
            echo "::error::Missing VERCEL_PROJECT_ID secret."
            exit 1
          fi
          if [[ -z "${{ env.SUPABASE_PROJECT_ID }}" ]]; then
            echo "::error::Missing SUPABASE_PROJECT_ID variable."
            exit 1
          fi
        env:
          SUPABASE_ACCESS_TOKEN: ${{ secrets.SUPABASE_ACCESS_TOKEN }}
          VERCEL_TOKEN: ${{ secrets.VERCEL_TOKEN }}

      - name: Login to Supabase
        run: supabase login
        env:
          SUPABASE_ACCESS_TOKEN: ${{ secrets.SUPABASE_ACCESS_TOKEN }}

      - name: Create or Reset Supabase Branch
        id: supabase-branch
        run: |
          BRANCH_NAME="${{ env.STAGING_BRANCH_NAME }}"
          echo "Checking for Supabase branch: $BRANCH_NAME"

          # Check if branch exists
          if supabase db branch list --project-ref ${{ env.SUPABASE_PROJECT_ID }} | grep -q "$BRANCH_NAME"; then
            echo "Branch exists, resetting..."
            supabase db remote changes --branch $BRANCH_NAME --project-ref ${{ env.SUPABASE_PROJECT_ID }}
            supabase db reset --branch $BRANCH_NAME --project-ref ${{ env.SUPABASE_PROJECT_ID }}
          else
            echo "Branch does not exist, creating..."
            supabase db branch create $BRANCH_NAME --project-ref ${{ env.SUPABASE_PROJECT_ID }}
          fi

          # Push latest migrations
          echo "Pushing migrations to branch $BRANCH_NAME..."
          supabase db push --branch $BRANCH_NAME --project-ref ${{ env.SUPABASE_PROJECT_ID }} --linked

          # Get branch info (assuming it exists now)
          echo "Getting branch info..."
          BRANCH_INFO=$(supabase db branch list --project-ref ${{ env.SUPABASE_PROJECT_ID }} --output json | jq --arg name "$BRANCH_NAME" '.[] | select(.name == $name)')

          if [ -z "$BRANCH_INFO" ]; then
            echo "::error::Failed to get branch info for $BRANCH_NAME"
            exit 1
          fi

          # Extract and set output variables (used for Vercel env)
          echo "api_url=$(echo $BRANCH_INFO | jq -r '.api_url')" >> $GITHUB_OUTPUT
          echo "anon_key=$(echo $BRANCH_INFO | jq -r '.anon_key')" >> $GITHUB_OUTPUT
          echo "service_role_key=$(echo $BRANCH_INFO | jq -r '.service_role_key')" >> $GITHUB_OUTPUT

      - name: Link Vercel Project
        run: vercel link --yes --org-id ${{ env.VERCEL_ORG_ID }} --project-id ${{ env.VERCEL_PROJECT_ID }}
        env:
          VERCEL_TOKEN: ${{ secrets.VERCEL_TOKEN }}

      - name: Pull Vercel Environment Information (Preview)
        run: vercel pull --yes --environment=preview --token=${{ secrets.VERCEL_TOKEN }}
        env:
          VERCEL_TOKEN: ${{ secrets.VERCEL_TOKEN }}

      - name: Set Supabase Environment Variables for Vercel Preview
        run: |
          echo "Setting Supabase preview env vars..."
          vercel env add NEXT_PUBLIC_SUPABASE_URL ${{ steps.supabase-branch.outputs.api_url }} preview --token=${{ secrets.VERCEL_TOKEN }} --scope team --yes
          vercel env add NEXT_PUBLIC_SUPABASE_ANON_KEY ${{ steps.supabase-branch.outputs.anon_key }} preview --token=${{ secrets.VERCEL_TOKEN }} --scope team --yes
          vercel env add SUPABASE_SERVICE_ROLE_KEY ${{ steps.supabase-branch.outputs.service_role_key }} preview --token=${{ secrets.VERCEL_TOKEN }} --scope team --yes
        env:
          VERCEL_TOKEN: ${{ secrets.VERCEL_TOKEN }}

      - name: Deploy to Vercel Preview
        id: vercel-deploy
        run: |
          echo "Deploying to Vercel Preview..."
          # Deploy and capture output
          VERCEL_DEPLOY_OUTPUT=$(vercel deploy --token=${{ secrets.VERCEL_TOKEN }} --scope team)
          echo "$VERCEL_DEPLOY_OUTPUT"

          # Extract preview URL
          PREVIEW_URL=$(echo "$VERCEL_DEPLOY_OUTPUT" | grep -Eo 'https://[a-zA-Z0-9-]+-${{ env.VERCEL_PROJECT_ID }}-[a-zA-Z0-9]+.vercel.app')
          if [ -z "$PREVIEW_URL" ]; then
            echo "::error::Could not extract preview URL from Vercel output."
            # Attempt fallback extraction
            PREVIEW_URL=$(echo "$VERCEL_DEPLOY_OUTPUT" | grep -Eo 'https://[^ ]+')
            if [ -z "$PREVIEW_URL" ]; then
              echo "::error::Fallback URL extraction failed."
              exit 1
            fi
            echo "Using fallback URL: $PREVIEW_URL"
          else
            echo "Preview URL: $PREVIEW_URL"
          fi

          echo "preview_url=$PREVIEW_URL" >> $GITHUB_OUTPUT

          # Get deployment ID using the extracted URL
          echo "Getting deployment ID for $PREVIEW_URL..."
          # Note: `vercel inspect` might be deprecated or behaviour changed.
          # Using `vercel ls --meta deploymentId` filtered by url might be more robust
          PREVIEW_ID=$(vercel inspect $PREVIEW_URL --token=${{ secrets.VERCEL_TOKEN }} --scope team | jq -r .id)
          if [ -z "$PREVIEW_ID" ] || [ "$PREVIEW_ID" == "null" ]; then
             echo "::warning::Could not get deployment ID using vercel inspect. Trying vercel ls..."
             PREVIEW_ID=$(vercel ls --token=${{ secrets.VERCEL_TOKEN }} --scope team --meta deploymentId --json | jq -r --arg url "$PREVIEW_URL" '.deployments[] | select(.url == $url) | .meta.deploymentId // empty' | head -n 1)
          fi

          if [ -z "$PREVIEW_ID" ]; then
            echo "::error::Could not extract deployment ID."
            exit 1
          fi
          echo "Preview ID: $PREVIEW_ID"
          echo "preview_id=$PREVIEW_ID" >> $GITHUB_OUTPUT
        env:
          VERCEL_TOKEN: ${{ secrets.VERCEL_TOKEN }}
          VERCEL_SCOPE: ${{ vars.VERCEL_SCOPE || github.repository_owner }} # For team scope

      - name: Save deployment info to artifact
        run: |
          mkdir -p deployment-info
          echo "${{ steps.vercel-deploy.outputs.preview_url }}" > deployment-info/preview-url.txt
          echo "${{ steps.vercel-deploy.outputs.preview_id }}" > deployment-info/preview-id.txt
          echo "${{ env.STAGING_BRANCH_NAME }}" > deployment-info/supabase-branch.txt

      - name: Upload deployment info artifact
        uses: actions/upload-artifact@v4
        with:
          name: deployment-info-${{ github.sha }}
          path: deployment-info/
          retention-days: 7 # Keep artifact long enough for approval

  approve-production:
    name: Approve Production Deployment
    needs: deploy-staging
    runs-on: ubuntu-latest
    environment:
      name: production # Use environment for manual approval gate
      url: ${{ needs.deploy-staging.outputs.preview_url }} # Show preview URL in environment

    steps:
      - name: Display Staging Info
        run: |
          echo "## Ready for Production Promotion :rocket:"
          echo ""
          echo "Please review the staging deployment before approving:"
          echo "- **Staging URL:** ${{ needs.deploy-staging.outputs.preview_url }}"
          echo "- **Deployment ID:** ${{ needs.deploy-staging.outputs.preview_id }}"
          echo "- **Supabase Branch:** ${{ needs.deploy-staging.outputs.supabase_branch }}"
          echo ""
          echo "Approve the 'production' environment gate in GitHub Actions to proceed."

  promote-to-production:
    name: Promote to Production
    needs: approve-production # Depends on manual approval
    runs-on: ubuntu-latest
    environment: production # Ensure it runs in prod env context for secrets/vars

    steps:
      - name: Download deployment info artifact
        uses: actions/download-artifact@v4
        with:
          name: deployment-info-${{ github.sha }} # Use SHA to get correct artifact
          path: deployment-info

      - name: Load deployment info into env
        id: load_info
        run: |
          echo "PREVIEW_URL=$(cat deployment-info/preview-url.txt)" >> $GITHUB_ENV
          echo "PREVIEW_ID=$(cat deployment-info/preview-id.txt)" >> $GITHUB_ENV
          echo "SUPABASE_BRANCH=$(cat deployment-info/supabase-branch.txt)" >> $GITHUB_ENV

      - name: Setup Node + NPM Deps
        uses: ./.github/actions/setup-node-npm
        with:
          node-version: '20.x'
          fetch-depth: 0 # Needed for Vercel link/pull

      - name: Setup Supabase CLI
        uses: ./.github/actions/setup-supabase-cli

      - name: Install Vercel CLI
        run: npm install -g vercel@latest

      - name: Verify Secrets
        run: |
          # Verify secrets needed for production promotion
          if [[ -z "${{ secrets.SUPABASE_ACCESS_TOKEN }}" ]]; then
            echo "::error::Missing SUPABASE_ACCESS_TOKEN secret."
            exit 1
          fi
          if [[ -z "${{ secrets.VERCEL_TOKEN }}" ]]; then
            echo "::error::Missing VERCEL_TOKEN secret."
            exit 1
          fi
        env:
          SUPABASE_ACCESS_TOKEN: ${{ secrets.SUPABASE_ACCESS_TOKEN }}
          VERCEL_TOKEN: ${{ secrets.VERCEL_TOKEN }}

      - name: Login to Supabase
        run: supabase login
        env:
          SUPABASE_ACCESS_TOKEN: ${{ secrets.SUPABASE_ACCESS_TOKEN }}

      - name: Promote Vercel deployment to production
        run: |
          echo "Promoting Vercel deployment ${{ env.PREVIEW_ID }} ($PREVIEW_URL) to production..."
          vercel promote ${{ env.PREVIEW_ID }} --token=${{ secrets.VERCEL_TOKEN }} --scope team --yes
          echo "Vercel deployment promoted to production domains!"
        env:
          VERCEL_TOKEN: ${{ secrets.VERCEL_TOKEN }}
          VERCEL_SCOPE: ${{ vars.VERCEL_SCOPE || github.repository_owner }}

      - name: Deploy Supabase branch to production
        run: |
          echo "Deploying Supabase branch ${{ env.SUPABASE_BRANCH }} changes to production..."
          supabase db branch deploy ${{ env.SUPABASE_BRANCH }} --project-ref ${{ env.SUPABASE_PROJECT_ID }} --linked
          echo "Supabase branch deployed to production successfully!"

      - name: Clean up Supabase staging branch
        # Run even if previous steps failed partially, but after deploy attempt
        if: always()
        run: |
          echo "Cleaning up Supabase branch ${{ env.SUPABASE_BRANCH }}..."
          supabase db branch delete ${{ env.SUPABASE_BRANCH }} --project-ref ${{ env.SUPABASE_PROJECT_ID }} --linked --yes
          echo "Supabase branch ${{ env.SUPABASE_BRANCH }} deleted."

      - name: Production deployment summary
        run: |
          PROD_URL="${{ vars.PRODUCTION_URL || 'https://YOUR_APP_DOMAIN.com' }}" # Use Production URL variable
          echo "## Production Deployment Successful! :rocket:" >> $GITHUB_STEP_SUMMARY
          echo "The deployment **${{ env.PREVIEW_ID }}** has been promoted to production." >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "- **Production URL:** [$PROD_URL]($PROD_URL)"
          echo "- **Promoted from Staging:** ${{ env.PREVIEW_URL }}"
          echo "- **Supabase Branch Merged:** ${{ env.SUPABASE_BRANCH }}"
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "The Supabase branch has been deployed to production and deleted." >> $GITHUB_STEP_SUMMARY

      - name: Notify Slack (Optional)
        if: success() && env.SLACK_RELEASE_WEBHOOK != '' # Check env var presence
        run: |
          PROD_URL="${{ vars.PRODUCTION_URL || 'https://YOUR_APP_DOMAIN.com' }}"
          # Use the environment variable for the webhook URL
          curl -X POST -H 'Content-type: application/json' --data "{
            \"text\": \":rocket: *Production Deployment Successful!*\\n• *URL:* <$PROD_URL|$PROD_URL>\\n• *Commit:* <https://github.com/${{ github.repository }}/commit/${{ github.sha }}|${{ github.sha }}>\\n• *Promoted by:* ${{ github.actor }}\"
          }" "$SLACK_RELEASE_WEBHOOK"
        env:
          # Pass the secret into the step's environment
          SLACK_RELEASE_WEBHOOK: ${{ secrets.SLACK_RELEASE_WEBHOOK }}
