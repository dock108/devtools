[{"filePath":"/Users/michaelfuscoletti/Desktop/dock108home/app/(auth)/callback/route.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":148,"column":17,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":148,"endColumn":20,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6104,6107],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6104,6107],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { createServerClient } from '@supabase/ssr';\nimport { cookies } from 'next/headers';\nimport { NextRequest, NextResponse } from 'next/server';\nimport { stripe } from '@/lib/stripe'; // Assuming stripe client is configured\nimport { getErrorRedirect, getStatusRedirect } from '@/utils/helpers'; // Assumed helpers\nimport { Database } from '@/types/supabase'; // Assuming generated types\nimport { createAdminClient } from '@/lib/supabase/admin'; // Assuming admin client for inserts\nimport { createWebhookIfMissing } from '@/lib/stripe/webhooks';\nimport { enqueueBackfill } from '@/lib/guardian/backfill';\n\n// TODO: Import actual functions when created\n// import { enqueueBackfill } from '@/lib/guardian/backfill';\n\nexport async function GET(request: NextRequest) {\n  const requestUrl = new URL(request.url);\n  const code = requestUrl.searchParams.get('code');\n  const error = requestUrl.searchParams.get('error');\n  const errorDescription = requestUrl.searchParams.get('error_description');\n\n  const cookieStore = cookies();\n  const supabase = createServerClient<Database>(\n    process.env.NEXT_PUBLIC_SUPABASE_URL!,\n    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,\n    { cookies: { get: (name) => cookieStore.get(name)?.value } },\n  );\n\n  // 1. Handle OAuth errors from Stripe\n  if (error) {\n    console.error(`Stripe OAuth Error: ${error} - ${errorDescription}`);\n    return NextResponse.redirect(getErrorRedirect(requestUrl.origin, error, errorDescription));\n  }\n\n  // 2. Handle missing code\n  if (!code) {\n    console.error('Missing OAuth code in callback');\n    return NextResponse.redirect(\n      getErrorRedirect(requestUrl.origin, 'OAuth Error', 'No code returned from Stripe.'),\n    );\n  }\n\n  try {\n    // 3. Exchange code for tokens\n    console.log('Exchanging OAuth code for Stripe tokens...');\n    const response = await stripe.oauth.token({\n      grant_type: 'authorization_code',\n      code: code,\n    });\n    console.log('Stripe token exchange successful:', response.stripe_user_id);\n\n    const stripeAccountId = response.stripe_user_id;\n    const refreshToken = response.refresh_token; // Store securely!\n    const accessToken = response.access_token; // Store securely!\n    const scope = response.scope;\n\n    if (!stripeAccountId) {\n      throw new Error('Stripe account ID not found in OAuth response.');\n    }\n\n    // 4. Get Supabase User\n    const {\n      data: { user },\n      error: userError,\n    } = await supabase.auth.getUser();\n    if (userError || !user) {\n      console.error('Error fetching user:', userError);\n      return NextResponse.redirect(\n        getErrorRedirect(requestUrl.origin, 'Authentication Error', 'Could not get user session.'),\n      );\n    }\n    console.log('Supabase user found:', user.id);\n\n    // Use Admin client for DB operations from server-side route\n    const supabaseAdmin = createAdminClient();\n\n    // 5. Check account limit (<= 2)\n    console.log(`Checking account limit for user ${user.id}...`);\n    const { count, error: countError } = await supabaseAdmin\n      .from('stripe_accounts') // Assuming this table exists\n      .select('id', { count: 'exact', head: true })\n      .eq('user_id', user.id);\n\n    if (countError) {\n      console.error('Error counting Stripe accounts:', countError);\n      throw new Error('Could not verify account limit.'); // Internal error\n    }\n\n    const MAX_ACCOUNTS = 2;\n    if (count !== null && count >= MAX_ACCOUNTS) {\n      console.warn(`User ${user.id} has reached account limit (${count}/${MAX_ACCOUNTS}).`);\n      return NextResponse.redirect(\n        getErrorRedirect(\n          requestUrl.origin,\n          'Account Limit Reached',\n          `You can connect a maximum of ${MAX_ACCOUNTS} Stripe accounts.`,\n          '/dashboard', // Redirect back to dashboard or settings\n        ),\n      );\n    }\n    console.log(`User ${user.id} has ${count ?? 0} accounts, proceeding.`);\n\n    // 6. Insert/Update Stripe Account Info (encrypt tokens!)\n    const keyId = process.env.SODIUM_ENCRYPTION_KEY_ID;\n    if (!keyId) {\n      console.error('SODIUM_ENCRYPTION_KEY_ID is not set in environment variables.');\n      throw new Error('Server configuration error for encryption.');\n    }\n\n    console.log(`Upserting Stripe account ${stripeAccountId} for user ${user.id}...`);\n    // We need to use raw SQL for encryption as Supabase client doesn't directly support pgsodium bytea functions yet.\n    // Note: Ensure pgsodium is enabled and the key referenced by keyId exists.\n    const { error: upsertError } = await supabaseAdmin.rpc('upsert_stripe_account', {\n      p_user_id: user.id,\n      p_stripe_account_id: stripeAccountId,\n      p_scope: scope,\n      p_refresh_token: refreshToken, // Pass plaintext to function\n      p_access_token: accessToken, // Pass plaintext to function\n      p_key_id: keyId,\n    });\n\n    // We need to define the upsert_stripe_account SQL function in a migration\n    // This function will handle the encryption using pgsodium.crypto_aead_det_encrypt\n\n    if (upsertError) {\n      console.error('Error upserting Stripe account:', upsertError);\n      throw new Error(`Failed to save Stripe account details: ${upsertError.message}`);\n    }\n    console.log(`Successfully upserted Stripe account ${stripeAccountId}`);\n\n    // 7. Provision Webhook\n    console.log(`Provisioning webhook for account ${stripeAccountId}...`);\n    await createWebhookIfMissing(stripeAccountId);\n    console.log(`Webhook provisioning step completed for ${stripeAccountId}.`);\n\n    // 8. Enqueue Backfill & Create initial status record\n    console.log(`Enqueueing backfill for account ${stripeAccountId}...`);\n    await enqueueBackfill(user.id, stripeAccountId);\n    console.log(`Backfill enqueue step completed for ${stripeAccountId}.`);\n\n    // 9. Redirect on success\n    console.log(`Redirecting to dashboard for user ${user.id}, account ${stripeAccountId}`);\n    return NextResponse.redirect(\n      getStatusRedirect(\n        requestUrl.origin,\n        'Stripe Account Connected',\n        `Successfully connected ${stripeAccountId}. Historical data back-fill initiated.`,\n      ),\n    );\n  } catch (err: any) {\n    console.error('Error during Stripe OAuth callback:', err);\n    const message = err.message || 'An unexpected error occurred during Stripe Connect.';\n    return NextResponse.redirect(getErrorRedirect(requestUrl.origin, 'Connection Failed', message));\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/michaelfuscoletti/Desktop/dock108home/app/(auth)/layout.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/michaelfuscoletti/Desktop/dock108home/app/(auth)/settings/ApiKeysManager.tsx","messages":[{"ruleId":"react/no-unescaped-entities","severity":2,"message":"`'` can be escaped with `&apos;`, `&lsquo;`, `&#39;`, `&rsquo;`.","line":198,"column":84,"nodeType":"JSXText","messageId":"unescapedEntityAlts","suggestions":[{"messageId":"replaceWithAlt","data":{"alt":"&apos;"},"fix":{"range":[7143,7289],"text":"\n                  Your new API key has been created. Please copy it now, as you won&apos;t be able to see\n                  it again.\n                "},"desc":"Replace with `&apos;`."},{"messageId":"replaceWithAlt","data":{"alt":"&lsquo;"},"fix":{"range":[7143,7289],"text":"\n                  Your new API key has been created. Please copy it now, as you won&lsquo;t be able to see\n                  it again.\n                "},"desc":"Replace with `&lsquo;`."},{"messageId":"replaceWithAlt","data":{"alt":"&#39;"},"fix":{"range":[7143,7289],"text":"\n                  Your new API key has been created. Please copy it now, as you won&#39;t be able to see\n                  it again.\n                "},"desc":"Replace with `&#39;`."},{"messageId":"replaceWithAlt","data":{"alt":"&rsquo;"},"fix":{"range":[7143,7289],"text":"\n                  Your new API key has been created. Please copy it now, as you won&rsquo;t be able to see\n                  it again.\n                "},"desc":"Replace with `&rsquo;`."}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"'use client';\n\nimport { useState, useTransition, ChangeEvent } from 'react';\nimport { toast } from 'sonner';\nimport { Button } from '@/components/ui/button';\nimport { Input } from '@/components/ui/input';\nimport {\n  Dialog,\n  DialogContent,\n  DialogDescription,\n  DialogFooter,\n  DialogHeader,\n  DialogTitle,\n  DialogTrigger,\n  DialogClose,\n} from '@/components/ui/dialog';\nimport {\n  AlertDialog,\n  AlertDialogAction,\n  AlertDialogCancel,\n  AlertDialogContent,\n  AlertDialogDescription,\n  AlertDialogFooter,\n  AlertDialogHeader,\n  AlertDialogTitle,\n} from '@/components/ui/alert-dialog';\nimport {\n  Table,\n  TableBody,\n  TableCell,\n  TableHead,\n  TableHeader,\n  TableRow,\n} from '@/components/ui/table';\nimport { Label } from '@/components/ui/label';\nimport { Trash2, PlusCircle, Copy } from 'lucide-react';\nimport { ApiKeyInfo } from '@/lib/supabase/user'; // Import type\nimport { generateApiKeyServerAction, revokeApiKeyServerAction } from './actions'; // Import the real server actions\nimport { Card, CardContent, CardFooter, CardDescription } from '@/components/ui/card';\n\ninterface ApiKeysManagerProps {\n  initialApiKeys: ApiKeyInfo[];\n}\n\nexport function ApiKeysManager({ initialApiKeys }: ApiKeysManagerProps) {\n  const [apiKeys, setApiKeys] = useState<ApiKeyInfo[]>(initialApiKeys);\n  const [newKeyName, setNewKeyName] = useState('');\n  const [generatedKey, setGeneratedKey] = useState<string | null>(null);\n  const [isGenerating, startGeneratingTransition] = useTransition();\n  const [isCreateDialogOpen, setIsCreateDialogOpen] = useState(false);\n  const [showRevokeDialog, setShowRevokeDialog] = useState(false);\n  const [keyToRevoke, setKeyToRevoke] = useState<ApiKeyInfo | null>(null);\n\n  const handleGenerateKey = () => {\n    if (!newKeyName.trim()) {\n      toast.error('Please enter a name for the API key.');\n      return;\n    }\n    startGeneratingTransition(async () => {\n      const formData = new FormData();\n      formData.append('keyName', newKeyName);\n      const result = await generateApiKeyServerAction(formData);\n\n      if (result.success && result.apiKey) {\n        toast.success('API Key generated successfully!');\n        setGeneratedKey(result.apiKey);\n        // Optimistically add (or wait for re-fetch/invalidation)\n        // For simplicity, let's assume revalidation will handle list update\n        // Or manually refetch profile data here\n        setNewKeyName(''); // Clear input\n        // Keep dialog open to show the key\n      } else {\n        toast.error(`Error generating API key: ${result.error || 'Unknown error'}`);\n        setIsCreateDialogOpen(false); // Close dialog on error\n      }\n    });\n  };\n\n  const handleRevokeKey = (keyId: string) => {\n    const revoke = async () => {\n      const formData = new FormData();\n      formData.append('keyId', keyId);\n      const result = await revokeApiKeyServerAction(formData);\n\n      if (result.success) {\n        toast.success('API Key revoked successfully!');\n        setApiKeys((currentKeys) => currentKeys.filter((key) => key.id !== keyId));\n      } else {\n        toast.error(`Error revoking API key: ${result.error || 'Unknown error'}`);\n      }\n    };\n    revoke();\n  };\n\n  const copyToClipboard = (text: string) => {\n    navigator.clipboard\n      .writeText(text)\n      .then(() => toast.success('API Key copied to clipboard!'))\n      .catch((_err) => toast.error('Failed to copy key.'));\n  };\n\n  const closeCreateDialog = () => {\n    setIsCreateDialogOpen(false);\n    setGeneratedKey(null); // Clear generated key when dialog closes\n    setNewKeyName('');\n  };\n\n  const handleRevoke = (keyId: string, keyName: string) => {\n    setKeyToRevoke({ id: keyId, name: keyName });\n    setShowRevokeDialog(true);\n  };\n\n  const confirmRevoke = () => {\n    if (keyToRevoke) {\n      handleRevokeKey(keyToRevoke.id);\n      setShowRevokeDialog(false);\n    }\n  };\n\n  return (\n    <div className=\"space-y-6\">\n      {/* Key List */}\n      <div className=\"rounded-md border\">\n        <Table>\n          <TableHeader>\n            <TableRow>\n              <TableHead>Name</TableHead>\n              <TableHead>Prefix</TableHead>\n              <TableHead>Created</TableHead>\n              <TableHead className=\"text-right\">Actions</TableHead>\n            </TableRow>\n          </TableHeader>\n          <TableBody>\n            {apiKeys.length === 0 && (\n              <TableRow>\n                <TableCell colSpan={4} className=\"h-24 text-center text-muted-foreground\">\n                  No API keys created yet.\n                </TableCell>\n              </TableRow>\n            )}\n            {apiKeys.map((key) => (\n              <TableRow key={key.id}>\n                <TableCell className=\"font-medium\">{key.name}</TableCell>\n                <TableCell>{key.prefix}****</TableCell> {/* Show prefix only */}\n                <TableCell>{new Date(key.created_at).toLocaleDateString()}</TableCell>\n                <TableCell className=\"text-right\">\n                  <div className=\"flex items-center space-x-2\">\n                    <Button onClick={() => handleRevoke(key.id, key.name)} variant=\"destructive\">\n                      <Trash2 className=\"mr-2 h-4 w-4\" /> Revoke\n                    </Button>\n\n                    {/* Confirmation Dialog */}\n                    <AlertDialog open={showRevokeDialog && keyToRevoke?.id === key.id}>\n                      <AlertDialogContent>\n                        <AlertDialogHeader>\n                          <AlertDialogTitle>Revoke API Key?</AlertDialogTitle>\n                          <AlertDialogDescription>\n                            Are you sure you want to revoke the key named &quot;{keyToRevoke?.name}\n                            &quot;? This action cannot be undone.\n                          </AlertDialogDescription>\n                        </AlertDialogHeader>\n                        <AlertDialogFooter>\n                          <AlertDialogCancel onClick={() => setShowRevokeDialog(false)}>\n                            Cancel\n                          </AlertDialogCancel>\n                          <AlertDialogAction onClick={confirmRevoke} variant=\"destructive\">\n                            Revoke Key\n                          </AlertDialogAction>\n                        </AlertDialogFooter>\n                      </AlertDialogContent>\n                    </AlertDialog>\n                  </div>\n                </TableCell>\n              </TableRow>\n            ))}\n          </TableBody>\n        </Table>\n      </div>\n\n      {/* Create Key Button & Dialog */}\n      <Dialog open={isCreateDialogOpen} onOpenChange={setIsCreateDialogOpen}>\n        <DialogTrigger asChild>\n          <Button disabled={isGenerating}>\n            <PlusCircle className=\"mr-2 h-4 w-4\" /> Create New API Key\n          </Button>\n        </DialogTrigger>\n        <DialogContent\n          onInteractOutside={(e) => {\n            // Prevent closing if we just generated a key to show\n            if (generatedKey) e.preventDefault();\n          }}\n        >\n          {generatedKey ? (\n            <>\n              <DialogHeader>\n                <DialogTitle>API Key Generated</DialogTitle>\n                <DialogDescription>\n                  Your new API key has been created. Please copy it now, as you won't be able to see\n                  it again.\n                </DialogDescription>\n              </DialogHeader>\n              <div className=\"flex items-center space-x-2 mt-4 bg-muted p-3 rounded-md\">\n                <Input\n                  id=\"new-api-key\"\n                  value={generatedKey}\n                  readOnly\n                  className=\"flex-1 font-mono text-sm\"\n                />\n                <Button type=\"button\" size=\"sm\" onClick={() => copyToClipboard(generatedKey)}>\n                  <Copy className=\"h-4 w-4\" />\n                </Button>\n              </div>\n              <DialogFooter>\n                <Button variant=\"outline\" onClick={closeCreateDialog}>\n                  Close\n                </Button>\n              </DialogFooter>\n            </>\n          ) : (\n            <>\n              <DialogHeader>\n                <DialogTitle>Create New API Key</DialogTitle>\n                <DialogDescription>Give your new API key a descriptive name.</DialogDescription>\n              </DialogHeader>\n              <div className=\"grid gap-4 py-4\">\n                <div className=\"grid grid-cols-4 items-center gap-4\">\n                  <Label htmlFor=\"key-name\" className=\"text-right\">\n                    Name\n                  </Label>\n                  <Input\n                    id=\"key-name\"\n                    value={newKeyName}\n                    onChange={(e: ChangeEvent<HTMLInputElement>) => setNewKeyName(e.target.value)}\n                    className=\"col-span-3\"\n                    placeholder=\"e.g., My Production Server\"\n                    disabled={isGenerating}\n                  />\n                </div>\n              </div>\n              <DialogFooter>\n                <DialogClose asChild>\n                  <Button type=\"button\" variant=\"outline\" disabled={isGenerating}>\n                    Cancel\n                  </Button>\n                </DialogClose>\n                <Button\n                  type=\"button\"\n                  onClick={handleGenerateKey}\n                  disabled={isGenerating || !newKeyName.trim()}\n                >\n                  {isGenerating ? 'Generating...' : 'Generate Key'}\n                </Button>\n              </DialogFooter>\n            </>\n          )}\n        </DialogContent>\n      </Dialog>\n\n      <Card className=\"mt-6\">\n        <CardContent>\n          <p className=\"text-xs text-muted-foreground\">\n            API keys grant access to your account. Treat them like passwords and keep them secure.\n          </p>\n        </CardContent>\n        <CardFooter className=\"border-t px-6 py-4\">\n          <CardDescription>\n            Manage your API keys here. Be sure to store them securely, as they won&apos;t be shown\n            again.\n          </CardDescription>\n        </CardFooter>\n      </Card>\n    </div>\n  );\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/michaelfuscoletti/Desktop/dock108home/app/(auth)/settings/PasswordForm.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/michaelfuscoletti/Desktop/dock108home/app/(auth)/settings/ProfileForm.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/michaelfuscoletti/Desktop/dock108home/app/(auth)/settings/ThemeSwitcher.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/michaelfuscoletti/Desktop/dock108home/app/(auth)/settings/accounts/accounts-client.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/michaelfuscoletti/Desktop/dock108home/app/(auth)/settings/accounts/layout.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/michaelfuscoletti/Desktop/dock108home/app/(auth)/settings/accounts/page.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/michaelfuscoletti/Desktop/dock108home/app/(auth)/settings/accounts/providers.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/michaelfuscoletti/Desktop/dock108home/app/(auth)/settings/actions.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/michaelfuscoletti/Desktop/dock108home/app/(auth)/settings/connected-accounts/ConnectedAccountsManager.tsx","messages":[{"ruleId":"react/no-unescaped-entities","severity":2,"message":"`'` can be escaped with `&apos;`, `&lsquo;`, `&#39;`, `&rsquo;`.","line":557,"column":45,"nodeType":"JSXText","messageId":"unescapedEntityAlts","suggestions":[{"messageId":"replaceWithAlt","data":{"alt":"&apos;"},"fix":{"range":[24586,24885],"text":"\n                            Stops Stripe from automatically sending funds to your bank. Guardian may\n                            turn this off automatically when fraud is suspected. You can resume\n                            payouts once you&apos;ve reviewed the transactions.\n                          "},"desc":"Replace with `&apos;`."},{"messageId":"replaceWithAlt","data":{"alt":"&lsquo;"},"fix":{"range":[24586,24885],"text":"\n                            Stops Stripe from automatically sending funds to your bank. Guardian may\n                            turn this off automatically when fraud is suspected. You can resume\n                            payouts once you&lsquo;ve reviewed the transactions.\n                          "},"desc":"Replace with `&lsquo;`."},{"messageId":"replaceWithAlt","data":{"alt":"&#39;"},"fix":{"range":[24586,24885],"text":"\n                            Stops Stripe from automatically sending funds to your bank. Guardian may\n                            turn this off automatically when fraud is suspected. You can resume\n                            payouts once you&#39;ve reviewed the transactions.\n                          "},"desc":"Replace with `&#39;`."},{"messageId":"replaceWithAlt","data":{"alt":"&rsquo;"},"fix":{"range":[24586,24885],"text":"\n                            Stops Stripe from automatically sending funds to your bank. Guardian may\n                            turn this off automatically when fraud is suspected. You can resume\n                            payouts once you&rsquo;ve reviewed the transactions.\n                          "},"desc":"Replace with `&rsquo;`."}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"'use client';\n\nimport React, { useState, useTransition, useEffect } from 'react';\nimport { useSearchParams } from 'next/navigation';\nimport {\n  linkStripeAccountServerAction,\n  disconnectStripeAccountServerAction,\n  resumePayoutsServerAction,\n  pausePayoutsServerAction,\n  toggleAlertsServerAction,\n} from './actions';\nimport { Button } from '@/components/ui/button';\nimport {\n  Table,\n  TableBody,\n  TableCell,\n  TableHead,\n  TableHeader,\n  TableRow,\n} from '@/components/ui/table';\nimport {\n  AlertDialog,\n  AlertDialogAction,\n  AlertDialogCancel,\n  AlertDialogContent,\n  AlertDialogDescription,\n  AlertDialogFooter,\n  AlertDialogHeader,\n  AlertDialogTitle,\n  AlertDialogTrigger,\n} from '@/components/ui/alert-dialog';\nimport { Switch } from '@/components/ui/switch';\nimport {\n  Select,\n  SelectContent,\n  SelectItem,\n  SelectTrigger,\n  SelectValue,\n} from '@/components/ui/select';\nimport { Badge } from '@/components/ui/badge';\nimport { Tooltip, TooltipContent, TooltipProvider, TooltipTrigger } from '@/components/ui/tooltip';\nimport { toast } from 'sonner';\nimport { format, formatDistanceToNow } from 'date-fns';\nimport { Loader2, Trash2, Copy, PlusCircle, Info, BellOff, Clock } from 'lucide-react';\nimport { Card, CardContent, CardHeader, CardTitle, CardDescription } from '@/components/ui/card';\nimport { BackfillProgress } from '@/components/progress/BackfillProgress';\n\n// Define the structure of a connected account based on fetched data\ninterface ConnectedAccount {\n  id: string;\n  stripe_account_id: string;\n  business_name: string | null;\n  created_at: string;\n  payouts_paused: boolean;\n  paused_by: string | null;\n  paused_reason: string | null;\n  alerts_muted_until: string | null;\n}\n\nconst MUTE_OPTIONS = [\n  { value: '60', label: '1 Hour' },\n  { value: '360', label: '6 Hours' },\n  { value: '1440', label: '24 Hours' },\n  { value: 'infinity', label: 'Indefinitely' },\n];\n\nexport function ConnectedAccountsManager({\n  initialAccounts,\n}: {\n  initialAccounts: ConnectedAccount[];\n}) {\n  const [accounts, setAccounts] = useState<ConnectedAccount[]>(initialAccounts);\n  const [isLinking, startLinkTransition] = useTransition();\n  const [isDisconnecting, startDisconnectTransition] = useTransition();\n  const [isTogglingPayouts, startPayoutsToggleTransition] = useTransition();\n  const [togglingPayoutsAccountId, setTogglingPayoutsAccountId] = useState<string | null>(null);\n  const [accountToDisconnect, setAccountToDisconnect] = useState<string | null>(null);\n  const [muteDuration, setMuteDuration] = useState<string>('360');\n  const [isTogglingMute, startMuteToggleTransition] = useTransition();\n  const [togglingMuteAccountId, setTogglingMuteAccountId] = useState<string | null>(null);\n\n  const searchParams = useSearchParams();\n\n  // Update local state if initialAccounts changes (e.g., after revalidation)\n  useEffect(() => {\n    setAccounts(initialAccounts);\n  }, [initialAccounts]);\n\n  // Check for error flags from OAuth callback\n  useEffect(() => {\n    const error = searchParams.get('error');\n    if (error === 'duplicate_link') {\n      toast.error('This Stripe account is already linked.');\n      window.history.replaceState(null, '', '/settings/connected-accounts');\n    }\n  }, [searchParams]);\n\n  const handleAddAccount = () => {\n    startLinkTransition(async () => {\n      try {\n        const result = await linkStripeAccountServerAction();\n        if (result?.url) {\n          window.location.href = result.url;\n        } else {\n          toast.error('Could not start Stripe connection. Please try again.');\n        }\n      } catch (error) {\n        toast.error(error instanceof Error ? error.message : 'An unexpected error occurred.');\n      }\n    });\n  };\n\n  const handleDisconnect = (stripeAccountId: string) => {\n    startDisconnectTransition(async () => {\n      const previousAccounts = accounts;\n      setAccounts((prev) => prev.filter((acc) => acc.stripe_account_id !== stripeAccountId));\n      setAccountToDisconnect(null);\n      try {\n        await disconnectStripeAccountServerAction(stripeAccountId);\n        toast.success('Stripe account disconnected successfully.');\n      } catch (error) {\n        setAccounts(previousAccounts);\n        toast.error(error instanceof Error ? error.message : 'Could not disconnect account.');\n      }\n    });\n  };\n\n  const handleTogglePayouts = (account: ConnectedAccount) => {\n    setTogglingPayoutsAccountId(account.stripe_account_id);\n    startPayoutsToggleTransition(async () => {\n      const action = account.payouts_paused ? resumePayoutsServerAction : pausePayoutsServerAction;\n      const optimisticUpdate = !account.payouts_paused;\n      const previousAccounts = accounts;\n\n      // Optimistic UI Update\n      setAccounts((prev) =>\n        prev.map((acc) =>\n          acc.stripe_account_id === account.stripe_account_id\n            ? { ...acc, payouts_paused: optimisticUpdate }\n            : acc,\n        ),\n      );\n\n      try {\n        await action(account.stripe_account_id);\n        toast.success(`Payouts ${optimisticUpdate ? 'paused' : 'resumed'} successfully.`);\n        // Data will refresh via revalidatePath\n      } catch (error) {\n        setAccounts(previousAccounts); // Rollback optimistic update\n        toast.error(error instanceof Error ? error.message : 'Failed to update payout status.');\n      } finally {\n        setTogglingPayoutsAccountId(null);\n      }\n    });\n  };\n\n  const handleToggleMute = (account: ConnectedAccount) => {\n    setTogglingMuteAccountId(account.stripe_account_id);\n    startMuteToggleTransition(async () => {\n      const isCurrentlyMuted =\n        !!account.alerts_muted_until && new Date(account.alerts_muted_until) > new Date();\n      const action = isCurrentlyMuted ? 'unmute' : 'mute';\n      let durationMinutes: number | undefined = undefined;\n\n      if (action === 'mute') {\n        if (muteDuration === 'infinity') {\n          durationMinutes = Infinity;\n        } else {\n          durationMinutes = parseInt(muteDuration, 10);\n          if (isNaN(durationMinutes)) {\n            console.warn('Invalid mute duration selected, defaulting to 6 hours');\n            durationMinutes = 360; // Default if parse fails\n          }\n        }\n      }\n\n      const optimisticMutedUntil =\n        action === 'mute'\n          ? durationMinutes === Infinity\n            ? 'infinity'\n            : new Date(Date.now() + durationMinutes * 60000).toISOString()\n          : null;\n\n      // Optimistic UI update\n      const previousAccounts = accounts;\n      setAccounts((prev) =>\n        prev.map((acc) =>\n          acc.stripe_account_id === account.stripe_account_id\n            ? { ...acc, alerts_muted_until: optimisticMutedUntil }\n            : acc,\n        ),\n      );\n\n      try {\n        const result = await toggleAlertsServerAction({\n          stripeAccountId: account.stripe_account_id,\n          action,\n          durationMinutes: action === 'mute' ? durationMinutes : undefined,\n        });\n\n        if (result.success) {\n          toast.success(`Alerts ${action === 'mute' ? 'muted' : 'unmuted'} successfully.`);\n          // Update with the exact value from the server if different (e.g., due to default fallback)\n          setAccounts((prev) =>\n            prev.map((acc) =>\n              acc.stripe_account_id === account.stripe_account_id\n                ? { ...acc, alerts_muted_until: result.mutedUntil }\n                : acc,\n            ),\n          );\n        } else {\n          throw new Error('Server action failed'); // Should be caught below\n        }\n        // Data should revalidate via revalidatePath\n      } catch (error) {\n        setAccounts(previousAccounts); // Rollback\n        toast.error(error instanceof Error ? error.message : `Failed to ${action} alerts.`);\n      } finally {\n        setTogglingMuteAccountId(null);\n      }\n    });\n  };\n\n  const copyToClipboard = (text: string) => {\n    navigator.clipboard\n      .writeText(text)\n      .then(() => toast.success('Stripe ID copied to clipboard!'))\n      .catch((_err) => toast.error('Failed to copy ID.'));\n  };\n\n  const getPauseTooltipContent = (account: ConnectedAccount): string => {\n    if (account.payouts_paused) {\n      let reason = `Paused by ${account.paused_by || 'unknown'}`;\n      if (account.paused_reason) reason += `: ${account.paused_reason.replace(/_/g, ' ')}`;\n      return reason;\n    } else {\n      return 'Automatic payouts active.';\n    }\n  };\n\n  const getMuteStatus = (account: ConnectedAccount): { muted: boolean; text: string } => {\n    if (account.alerts_muted_until) {\n      if (account.alerts_muted_until === 'infinity') {\n        return { muted: true, text: 'Muted indefinitely' };\n      }\n      const muteEndDate = new Date(account.alerts_muted_until);\n      if (muteEndDate > new Date()) {\n        return {\n          muted: true,\n          text: `Muted ${formatDistanceToNow(muteEndDate, { addSuffix: true })}`,\n        };\n      }\n    }\n    return { muted: false, text: 'Alerts active' };\n  };\n\n  return (\n    <Card>\n      <CardHeader className=\"flex flex-row items-center justify-between\">\n        <div>\n          <CardTitle>Connected Stripe Accounts</CardTitle>\n          <CardDescription>\n            Link multiple Stripe accounts to manage them with DOCK108.\n          </CardDescription>\n        </div>\n        <Button onClick={handleAddAccount} disabled={isLinking}>\n          {isLinking ? (\n            <>\n              <Loader2 className=\"mr-2 h-4 w-4 animate-spin\" /> Connecting...\n            </>\n          ) : (\n            <>\n              <PlusCircle className=\"mr-2 h-4 w-4\" /> Add Account\n            </>\n          )}\n        </Button>\n      </CardHeader>\n      <CardContent>\n        {accounts.length === 0 ? (\n          <p className=\"text-center text-muted-foreground py-8\">\n            No Stripe accounts connected yet.\n          </p>\n        ) : (\n          <TooltipProvider delayDuration={300}>\n            {/* Desktop Table */}\n            <div className=\"hidden md:block\">\n              <Table>\n                <TableHeader>\n                  <TableRow>\n                    <TableHead>Display Name</TableHead>\n                    <TableHead>Stripe Account ID</TableHead>\n                    <TableHead>Payouts</TableHead>\n                    <TableHead>Alerts</TableHead>\n                    <TableHead>Backfill Status</TableHead>\n                    <TableHead>Connected On</TableHead>\n                    <TableHead className=\"text-right\">Actions</TableHead>\n                  </TableRow>\n                </TableHeader>\n                <TableBody>\n                  {accounts.map((account) => {\n                    const muteStatus = getMuteStatus(account);\n                    const isLoadingMute =\n                      isTogglingMute && togglingMuteAccountId === account.stripe_account_id;\n                    const isLoadingPayouts =\n                      isTogglingPayouts && togglingPayoutsAccountId === account.stripe_account_id;\n                    return (\n                      <TableRow key={account.id}>\n                        <TableCell className=\"font-medium\">\n                          {account.business_name || 'N/A'}\n                        </TableCell>\n                        <TableCell className=\"flex items-center gap-2\">\n                          <span className=\"font-mono text-sm\">{account.stripe_account_id}</span>\n                          <Button\n                            variant=\"ghost\"\n                            size=\"icon\"\n                            className=\"h-6 w-6\"\n                            onClick={() => copyToClipboard(account.stripe_account_id)}\n                          >\n                            <Copy className=\"h-3 w-3\" />\n                          </Button>\n                        </TableCell>\n                        <TableCell>\n                          <Tooltip>\n                            <TooltipTrigger asChild>\n                              <div className=\"flex items-center\">\n                                <Switch\n                                  id={`payout-switch-${account.id}`}\n                                  checked={!account.payouts_paused}\n                                  onCheckedChange={() => handleTogglePayouts(account)}\n                                  disabled={isLoadingPayouts || isDisconnecting}\n                                  aria-label={\n                                    account.payouts_paused ? 'Resume payouts' : 'Pause payouts'\n                                  }\n                                />\n                                {isLoadingPayouts &&\n                                  togglingPayoutsAccountId === account.stripe_account_id && (\n                                    <Loader2 className=\"h-4 w-4 animate-spin ml-2\" />\n                                  )}\n                              </div>\n                            </TooltipTrigger>\n                            <TooltipContent>{getPauseTooltipContent(account)}</TooltipContent>\n                          </Tooltip>\n                        </TableCell>\n                        <TableCell>\n                          <div className=\"flex items-center space-x-2\">\n                            <Tooltip>\n                              <TooltipTrigger asChild>\n                                <Button\n                                  variant=\"ghost\"\n                                  size=\"icon\"\n                                  className=\"h-8 w-8\"\n                                  onClick={() => handleToggleMute(account)}\n                                  disabled={isLoadingMute || isDisconnecting}\n                                  aria-label={muteStatus.muted ? 'Unmute alerts' : 'Mute alerts'}\n                                >\n                                  {isLoadingMute ? (\n                                    <Loader2 className=\"h-4 w-4 animate-spin\" />\n                                  ) : (\n                                    <BellOff\n                                      className={`h-4 w-4 ${muteStatus.muted ? 'text-destructive' : 'text-muted-foreground'}`}\n                                    />\n                                  )}\n                                </Button>\n                              </TooltipTrigger>\n                              <TooltipContent>\n                                {muteStatus.muted\n                                  ? 'Click to unmute alerts'\n                                  : 'Click to mute alerts'}\n                                <br />\n                                <span className=\"text-xs text-muted-foreground\">\n                                  Monitoring continues while muted.\n                                </span>\n                              </TooltipContent>\n                            </Tooltip>\n                            {muteStatus.muted ? (\n                              <Badge variant=\"secondary\" className=\"whitespace-nowrap\">\n                                <Clock className=\"h-3 w-3 mr-1\" />\n                                {muteStatus.text}\n                              </Badge>\n                            ) : (\n                              <Select\n                                value={muteDuration}\n                                onValueChange={setMuteDuration}\n                                disabled={isLoadingMute}\n                              >\n                                <SelectTrigger className=\"h-8 w-[130px] text-xs\">\n                                  <SelectValue placeholder=\"Select duration\" />\n                                </SelectTrigger>\n                                <SelectContent>\n                                  {MUTE_OPTIONS.map((opt) => (\n                                    <SelectItem\n                                      key={opt.value}\n                                      value={opt.value}\n                                      className=\"text-xs\"\n                                    >\n                                      {opt.label}\n                                    </SelectItem>\n                                  ))}\n                                </SelectContent>\n                              </Select>\n                            )}\n                          </div>\n                        </TableCell>\n                        <TableCell>\n                          <BackfillProgress accountId={account.stripe_account_id} />\n                        </TableCell>\n                        <TableCell>{format(new Date(account.created_at), 'MMM d, yyyy')}</TableCell>\n                        <TableCell className=\"text-right\">\n                          <AlertDialog\n                            open={accountToDisconnect === account.stripe_account_id}\n                            onOpenChange={(open) => !open && setAccountToDisconnect(null)}\n                          >\n                            <AlertDialogTrigger asChild>\n                              <Button\n                                variant=\"ghost\"\n                                size=\"icon\"\n                                className=\"text-destructive hover:text-destructive h-8 w-8\"\n                                onClick={() => setAccountToDisconnect(account.stripe_account_id)}\n                                disabled={\n                                  isDisconnecting &&\n                                  accountToDisconnect === account.stripe_account_id\n                                }\n                              >\n                                {isDisconnecting &&\n                                accountToDisconnect === account.stripe_account_id ? (\n                                  <Loader2 className=\"h-4 w-4 animate-spin\" />\n                                ) : (\n                                  <Trash2 className=\"h-4 w-4\" />\n                                )}\n                              </Button>\n                            </AlertDialogTrigger>\n                            <AlertDialogContent>\n                              <AlertDialogHeader>\n                                <AlertDialogTitle>\n                                  Disconnect {accountToDisconnect?.business_name}?\n                                </AlertDialogTitle>\n                                <AlertDialogDescription>\n                                  Are you sure you want to disconnect this Stripe account? You\n                                  won&apos;t be able to monitor its payouts or receive alerts until\n                                  reconnected.\n                                </AlertDialogDescription>\n                              </AlertDialogHeader>\n                              <AlertDialogFooter>\n                                <AlertDialogCancel onClick={() => setAccountToDisconnect(null)}>\n                                  Cancel\n                                </AlertDialogCancel>\n                                <AlertDialogAction\n                                  className=\"bg-destructive text-destructive-foreground hover:bg-destructive/90\"\n                                  onClick={() => handleDisconnect(account.stripe_account_id)}\n                                  disabled={isDisconnecting}\n                                >\n                                  {isDisconnecting ? (\n                                    <Loader2 className=\"mr-2 h-4 w-4 animate-spin\" />\n                                  ) : null}\n                                  Disconnect\n                                </AlertDialogAction>\n                              </AlertDialogFooter>\n                            </AlertDialogContent>\n                          </AlertDialog>\n                        </TableCell>\n                      </TableRow>\n                    );\n                  })}\n                </TableBody>\n              </Table>\n            </div>\n\n            {/* Mobile Cards */}\n            <div className=\"block md:hidden space-y-4\">\n              {accounts.map((account) => {\n                const muteStatus = getMuteStatus(account);\n                const isLoadingMute =\n                  isTogglingMute && togglingMuteAccountId === account.stripe_account_id;\n                const isLoadingPayouts =\n                  isTogglingPayouts && togglingPayoutsAccountId === account.stripe_account_id;\n                return (\n                  <Card key={account.id} className=\"border shadow-sm\">\n                    <CardHeader className=\"flex flex-row items-center justify-between pb-2\">\n                      <CardTitle className=\"text-lg\">{account.business_name || 'N/A'}</CardTitle>\n                      <AlertDialog\n                        open={accountToDisconnect === account.stripe_account_id}\n                        onOpenChange={(open) => !open && setAccountToDisconnect(null)}\n                      >\n                        <AlertDialogTrigger asChild>\n                          <Button\n                            variant=\"ghost\"\n                            size=\"icon\"\n                            className=\"text-destructive hover:text-destructive h-8 w-8\"\n                            onClick={() => setAccountToDisconnect(account.stripe_account_id)}\n                            disabled={\n                              isDisconnecting && accountToDisconnect === account.stripe_account_id\n                            }\n                          >\n                            {isDisconnecting &&\n                            accountToDisconnect === account.stripe_account_id ? (\n                              <Loader2 className=\"h-4 w-4 animate-spin\" />\n                            ) : (\n                              <Trash2 className=\"h-4 w-4\" />\n                            )}\n                          </Button>\n                        </AlertDialogTrigger>\n                        <AlertDialogContent>\n                          <AlertDialogHeader>\n                            <AlertDialogTitle>\n                              Disconnect {accountToDisconnect?.business_name}?\n                            </AlertDialogTitle>\n                            <AlertDialogDescription>\n                              Are you sure you want to disconnect this Stripe account? You\n                              won&apos;t be able to monitor its payouts or receive alerts until\n                              reconnected.\n                            </AlertDialogDescription>\n                          </AlertDialogHeader>\n                          <AlertDialogFooter>\n                            <AlertDialogCancel onClick={() => setAccountToDisconnect(null)}>\n                              Cancel\n                            </AlertDialogCancel>\n                            <AlertDialogAction\n                              className=\"bg-destructive text-destructive-foreground hover:bg-destructive/90\"\n                              onClick={() => handleDisconnect(account.stripe_account_id)}\n                              disabled={isDisconnecting}\n                            >\n                              {isDisconnecting ? (\n                                <Loader2 className=\"mr-2 h-4 w-4 animate-spin\" />\n                              ) : null}\n                              Disconnect\n                            </AlertDialogAction>\n                          </AlertDialogFooter>\n                        </AlertDialogContent>\n                      </AlertDialog>\n                    </CardHeader>\n                    <CardContent className=\"space-y-3 text-sm\">\n                      <div className=\"flex items-center gap-2 text-muted-foreground\">\n                        <span className=\"font-mono\">{account.stripe_account_id}</span>\n                        <Button\n                          variant=\"ghost\"\n                          size=\"icon\"\n                          className=\"h-6 w-6\"\n                          onClick={() => copyToClipboard(account.stripe_account_id)}\n                        >\n                          <Copy className=\"h-3 w-3\" />\n                        </Button>\n                      </div>\n                      <p className=\"text-muted-foreground\">\n                        Connected: {format(new Date(account.created_at), 'MMM d, yyyy')}\n                      </p>\n                      <div className=\"flex items-center justify-between pt-2 border-t\">\n                        <Tooltip>\n                          <TooltipTrigger asChild>\n                            <span className=\"text-muted-foreground flex items-center\">\n                              Payouts\n                              <Info className=\"h-3 w-3 ml-1\" />\n                            </span>\n                          </TooltipTrigger>\n                          <TooltipContent className=\"max-w-xs\">\n                            Stops Stripe from automatically sending funds to your bank. Guardian may\n                            turn this off automatically when fraud is suspected. You can resume\n                            payouts once you've reviewed the transactions.\n                          </TooltipContent>\n                        </Tooltip>\n                        <Tooltip>\n                          <TooltipTrigger asChild>\n                            <div className=\"flex items-center\">\n                              <Switch\n                                id={`payout-switch-mobile-${account.id}`}\n                                checked={!account.payouts_paused}\n                                onCheckedChange={() => handleTogglePayouts(account)}\n                                disabled={isLoadingPayouts || isDisconnecting}\n                                aria-label={\n                                  account.payouts_paused ? 'Resume payouts' : 'Pause payouts'\n                                }\n                              />\n                              {isLoadingPayouts &&\n                                togglingPayoutsAccountId === account.stripe_account_id && (\n                                  <Loader2 className=\"h-4 w-4 animate-spin ml-2\" />\n                                )}\n                            </div>\n                          </TooltipTrigger>\n                          <TooltipContent>{getPauseTooltipContent(account)}</TooltipContent>\n                        </Tooltip>\n                      </div>\n                      <div className=\"flex items-center justify-between pt-2 border-t\">\n                        <Tooltip>\n                          <TooltipTrigger asChild>\n                            <span className=\"text-muted-foreground flex items-center\">\n                              Alerts\n                              <Info className=\"h-3 w-3 ml-1\" />\n                            </span>\n                          </TooltipTrigger>\n                          <TooltipContent className=\"max-w-xs\">\n                            Stops e-mail/Slack alerts while you investigate. Monitoring continues.\n                          </TooltipContent>\n                        </Tooltip>\n                        <div className=\"flex items-center space-x-2\">\n                          {muteStatus.muted ? (\n                            <Badge variant=\"secondary\" className=\"whitespace-nowrap text-xs\">\n                              <Clock className=\"h-3 w-3 mr-1\" />\n                              {muteStatus.text}\n                            </Badge>\n                          ) : (\n                            <Select\n                              value={muteDuration}\n                              onValueChange={setMuteDuration}\n                              disabled={isLoadingMute}\n                            >\n                              <SelectTrigger className=\"h-8 w-[100px] text-xs\">\n                                <SelectValue placeholder=\"Duration\" />\n                              </SelectTrigger>\n                              <SelectContent>\n                                {MUTE_OPTIONS.map((opt) => (\n                                  <SelectItem key={opt.value} value={opt.value} className=\"text-xs\">\n                                    {opt.label}\n                                  </SelectItem>\n                                ))}\n                              </SelectContent>\n                            </Select>\n                          )}\n                          <Tooltip>\n                            <TooltipTrigger asChild>\n                              <Button\n                                variant=\"ghost\"\n                                size=\"icon\"\n                                className=\"h-8 w-8\"\n                                onClick={() => handleToggleMute(account)}\n                                disabled={isLoadingMute || isDisconnecting}\n                                aria-label={muteStatus.muted ? 'Unmute alerts' : 'Mute alerts'}\n                              >\n                                {isLoadingMute ? (\n                                  <Loader2 className=\"h-4 w-4 animate-spin\" />\n                                ) : (\n                                  <BellOff\n                                    className={`h-4 w-4 ${muteStatus.muted ? 'text-destructive' : 'text-muted-foreground'}`}\n                                  />\n                                )}\n                              </Button>\n                            </TooltipTrigger>\n                            <TooltipContent>\n                              {muteStatus.muted ? 'Click to unmute alerts' : 'Click to mute alerts'}\n                            </TooltipContent>\n                          </Tooltip>\n                        </div>\n                      </div>\n                      <div className=\"flex items-center justify-between pt-2 border-t\">\n                        <Tooltip>\n                          <TooltipTrigger asChild>\n                            <span className=\"text-muted-foreground flex items-center\">\n                              Backfill Status\n                              <Info className=\"h-3 w-3 ml-1\" />\n                            </span>\n                          </TooltipTrigger>\n                          <TooltipContent className=\"max-w-xs\">\n                            Status of the last backfill operation.\n                          </TooltipContent>\n                        </Tooltip>\n                        <div className=\"flex items-center space-x-2\">\n                          <BackfillProgress accountId={account.stripe_account_id} />\n                        </div>\n                      </div>\n                    </CardContent>\n                  </Card>\n                );\n              })}\n            </div>\n          </TooltipProvider>\n        )}\n      </CardContent>\n    </Card>\n  );\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/michaelfuscoletti/Desktop/dock108home/app/(auth)/settings/connected-accounts/actions.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":72,"column":51,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":72,"endColumn":54,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2521,2524],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2521,2524],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":75,"column":39,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":75,"endColumn":42,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2633,2636],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2633,2636],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":131,"column":107,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":131,"endColumn":110,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4931,4934],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4931,4934],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"'use server';\n\nimport { cookies, headers } from 'next/headers';\nimport { createServerClient } from '@supabase/ssr';\nimport { Database } from '@/types/supabase.d';\nimport { stripe } from '@/lib/stripe'; // Corrected path\nimport { revalidatePath } from 'next/cache';\nimport { Resend } from 'resend'; // Import Resend SDK\n// import { createClient } from '@/lib/supabase/server'; // Removed unused import\n\n// --- Notification Helpers ---\n// Basic Slack helper using fetch\nasync function sendSlackNotificationAction(message: string) {\n  const webhookUrl = process.env.SLACK_WEBHOOK_URL;\n  if (!webhookUrl) {\n    console.warn('SLACK_WEBHOOK_URL not set, skipping Slack notification.');\n    return;\n  }\n  try {\n    const response = await fetch(webhookUrl, {\n      method: 'POST',\n      headers: { 'Content-Type': 'application/json' },\n      body: JSON.stringify({ text: message }),\n    });\n    if (!response.ok) {\n      throw new Error(`Slack webhook failed: ${response.status} ${await response.text()}`);\n    }\n    console.log('Slack notification sent successfully via Server Action helper.');\n  } catch (error) {\n    console.error('Error sending Slack notification via Server Action helper:', error);\n    // Don't throw from helper, just log the error\n  }\n}\n\n// Basic Resend helper\nasync function sendEmailNotificationAction(to: string, subject: string, body: string) {\n  const resendApiKey = process.env.RESEND_API_KEY;\n  if (!resendApiKey) {\n    console.warn('RESEND_API_KEY not set, skipping Email notification.');\n    return;\n  }\n  try {\n    const resend = new Resend(resendApiKey);\n    const { data, error } = await resend.emails.send({\n      from: 'DOCK108 Guardian <guardian@dock108.ai>', // Replace with your verified sender\n      to: [to],\n      subject: subject,\n      text: body,\n    });\n    if (error) throw error;\n    console.log(\n      `Email notification sent successfully via Server Action helper to ${to}. ID:`,\n      data?.id,\n    );\n  } catch (error) {\n    console.error(`Error sending email notification via Server Action helper to ${to}:`, error);\n    // Don't throw from helper, just log the error\n  }\n}\n\n// --- Supabase Client Helper ---\nconst createSupabaseServerClient = () => {\n  const cookieStore = cookies();\n  return createServerClient<Database>(\n    process.env.NEXT_PUBLIC_SUPABASE_URL!,\n    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,\n    {\n      cookies: {\n        get(name: string) {\n          return cookieStore.get(name)?.value;\n        },\n        set(name: string, value: string, options: any) {\n          cookieStore.set({ name, value, ...options });\n        },\n        remove(name: string, options: any) {\n          cookieStore.set({ name, value: '', ...options });\n        },\n      },\n    },\n  );\n};\n\n// --- Server Actions ---\n\nexport async function linkStripeAccountServerAction() {\n  const supabase = createSupabaseServerClient();\n  const {\n    data: { user },\n  } = await supabase.auth.getUser();\n\n  if (!user) {\n    throw new Error('Unauthorized: User not logged in');\n  }\n\n  // Construct the URLs for Stripe callback\n  // Ensure these URLs match your environment (localhost vs production)\n  const baseUrl = process.env.NEXT_PUBLIC_APP_URL || 'http://localhost:3000';\n  // const returnUrl = `${baseUrl}/settings/connected-accounts`; // Removed\n  // const refreshUrl = `${baseUrl}/settings/connected-accounts`; // Removed\n\n  const origin = headers().get('origin');\n  if (!origin) {\n    return { success: false, error: 'Could not determine request origin' };\n  }\n\n  try {\n    const accountLink = await stripe.accountLinks.create({\n      // Note: Stripe needs an actual account ID to create a link.\n      // This action seems designed to initiate linking a *new* account,\n      // but accountLinks is typically for existing accounts needing onboarding.\n      //\n      // For initiating a *new* connection via OAuth, you usually redirect directly\n      // to a pre-constructed Stripe Connect OAuth URL, often using stripe.oauth.authorizeUrl()\n      // Let's assume we are using stripe.oauth.authorizeUrl() instead.\n\n      // type: 'account_onboarding',\n      // account: 'acct_xyz' // Needs an actual account ID, which we don't have yet for a new link\n\n      // Redirecting to Stripe Connect OAuth URL construction:\n      // See: https://stripe.com/docs/connect/standard-accounts#integrating-oauth\n      // You need your Stripe Connect Client ID from Stripe Dashboard > Connect > Settings\n      client_id: process.env.STRIPE_CLIENT_ID!,\n      redirect_uri: `${baseUrl}/api/stripe/oauth/callback`, // Your configured callback handler\n      response_type: 'code',\n      scope: 'read_write', // Request necessary permissions\n      // Optional: state parameter for security\n      state: user.id, // Example: Pass user ID for verification in callback\n    });\n\n    // Construct the authorize URL\n    const authorizeUrl = `https://connect.stripe.com/oauth/authorize?${new URLSearchParams(accountLink as any).toString()}`;\n\n    console.log('Generated Stripe Connect OAuth URL:', authorizeUrl);\n    return { url: authorizeUrl };\n  } catch (error) {\n    console.error('Error creating Stripe account link:', error);\n    throw new Error('Could not initiate Stripe connection.');\n  }\n}\n\nexport async function disconnectStripeAccountServerAction(stripeAccountId: string) {\n  if (!stripeAccountId) {\n    throw new Error('Stripe Account ID is required.');\n  }\n\n  const supabase = createSupabaseServerClient();\n  const {\n    data: { user },\n  } = await supabase.auth.getUser();\n\n  if (!user) {\n    throw new Error('Unauthorized: User not logged in');\n  }\n\n  try {\n    // 1. Deauthorize the account with Stripe\n    // This revokes the application's access to the Stripe account.\n    // Uses the Stripe Platform's secret key.\n    // See: https://stripe.com/docs/connect/standard-accounts#disconnecting\n    await stripe.oauth.deauthorize({\n      client_id: process.env.STRIPE_CLIENT_ID!,\n      stripe_user_id: stripeAccountId,\n    });\n    console.log(`Deauthorized Stripe account ${stripeAccountId} via Stripe API.`);\n\n    // 2. Delete the account from your database\n    const { error: deleteError } = await supabase\n      .from('connected_accounts')\n      .delete()\n      .match({ user_id: user.id, stripe_account_id: stripeAccountId });\n\n    if (deleteError) {\n      console.error(`Error deleting connected account ${stripeAccountId} from DB:`, deleteError);\n      throw new Error('Failed to remove account from database.');\n    }\n    console.log(`Deleted connected account ${stripeAccountId} for user ${user.id} from DB.`);\n\n    // 3. Revalidate the path to refresh the list\n    revalidatePath('/settings/connected-accounts');\n\n    return { success: true };\n  } catch (error) {\n    console.error(`Error disconnecting Stripe account ${stripeAccountId}:`, error);\n    // Determine if the error came from Stripe or DB deletion for better messaging\n    if (error instanceof Error && error.message.includes('database')) {\n      throw new Error('Failed to remove account locally after disconnecting from Stripe.');\n    }\n    if (error instanceof Error && error.message.includes('deauthorize')) {\n      throw new Error('Failed to disconnect account from Stripe.');\n    }\n    throw new Error('Could not disconnect Stripe account.');\n  }\n}\n\nexport async function resumePayoutsServerAction(stripeAccountId: string) {\n  if (!stripeAccountId) {\n    throw new Error('Stripe Account ID is required.');\n  }\n\n  const supabase = createSupabaseServerClient();\n  const {\n    data: { user },\n  } = await supabase.auth.getUser();\n\n  if (!user || !user.email) {\n    // Ensure user and email exist\n    throw new Error('Unauthorized or user email missing.');\n  }\n\n  console.log(`User ${user.id} attempting to resume payouts for ${stripeAccountId}`);\n\n  try {\n    // Fetch account details for notification context\n    const { data: account, error: fetchError } = await supabase\n      .from('connected_accounts')\n      .select('business_name')\n      .eq('user_id', user.id)\n      .eq('stripe_account_id', stripeAccountId)\n      .maybeSingle();\n\n    if (fetchError) {\n      console.error(`Failed to fetch account details for ${stripeAccountId}:`, fetchError);\n      // Non-fatal for payout resume, but notifications will lack name\n    }\n    const accountDisplayName = account?.business_name || stripeAccountId; // Use ID as fallback\n\n    // 1. Update Stripe payout schedule to daily (or your default)\n    await stripe.accounts.update(stripeAccountId, {\n      settings: { payouts: { schedule: { interval: 'daily' } } },\n    });\n    console.log(`Updated Stripe payout schedule to daily for ${stripeAccountId}`);\n\n    // 2. Update database record\n    const { error: dbError } = await supabase\n      .from('connected_accounts')\n      .update({\n        payouts_paused: false,\n        paused_by: 'user',\n        paused_reason: null, // Clear the reason\n      })\n      .eq('user_id', user.id) // Ensure user owns this account\n      .eq('stripe_account_id', stripeAccountId);\n\n    if (dbError) {\n      console.error(\n        `Error updating connected_accounts for resume payout for ${stripeAccountId}:`,\n        dbError,\n      );\n      throw new Error('Failed to update account status in database.');\n    }\n    console.log(`Updated connected_accounts for resume payout for ${stripeAccountId}`);\n\n    // 3. Trigger notification (Manual resume by user)\n    const subject = `✅ Payouts Resumed for ${accountDisplayName}`;\n    const messageBody = `Payouts have been manually resumed for Stripe account ${accountDisplayName} (${stripeAccountId}) by user ${user.email}.`;\n\n    // Send notifications (fire and forget, don't block response on these)\n    sendEmailNotificationAction(user.email, subject, messageBody);\n    sendSlackNotificationAction(\n      `✅ Payouts Resumed: Account ${accountDisplayName} (${stripeAccountId}) by user ${user.email}.`,\n    );\n\n    // 4. Revalidate path\n    revalidatePath('/settings/connected-accounts');\n    revalidatePath('/stripe-guardian/alerts'); // Also revalidate dashboard\n\n    return { success: true };\n  } catch (error) {\n    console.error(`Error resuming payouts for ${stripeAccountId}:`, error);\n    throw new Error('Could not resume payouts. Please try again.');\n  }\n}\n\nexport async function pausePayoutsServerAction(stripeAccountId: string) {\n  if (!stripeAccountId) {\n    throw new Error('Stripe Account ID is required.');\n  }\n\n  const supabase = createSupabaseServerClient();\n  const {\n    data: { user },\n  } = await supabase.auth.getUser();\n\n  if (!user) {\n    throw new Error('Unauthorized: User not logged in');\n  }\n\n  console.log(`User ${user.id} attempting to manually pause payouts for ${stripeAccountId}`);\n\n  try {\n    // 1. Update Stripe payout schedule to manual\n    await stripe.accounts.update(stripeAccountId, {\n      settings: { payouts: { schedule: { interval: 'manual' } } },\n    });\n    console.log(`Updated Stripe payout schedule to manual for ${stripeAccountId}`);\n\n    // 2. Update database record\n    const { error: dbError } = await supabase\n      .from('connected_accounts')\n      .update({\n        payouts_paused: true,\n        paused_by: 'user',\n        paused_reason: 'manual',\n      })\n      .eq('user_id', user.id) // Ensure user owns this account\n      .eq('stripe_account_id', stripeAccountId);\n\n    if (dbError) {\n      console.error(\n        `Error updating connected_accounts for manual pause for ${stripeAccountId}:`,\n        dbError,\n      );\n      throw new Error('Failed to update account status in database.');\n    }\n    console.log(`Updated connected_accounts for manual pause for ${stripeAccountId}`);\n\n    // 3. Revalidate path\n    revalidatePath('/settings/connected-accounts');\n\n    // No notification needed for manual pause by user?\n\n    return { success: true };\n  } catch (error) {\n    console.error(`Error manually pausing payouts for ${stripeAccountId}:`, error);\n    throw new Error('Could not pause payouts. Please try again.');\n  }\n}\n\nexport async function toggleAlertsServerAction({\n  stripeAccountId,\n  action,\n  durationMinutes,\n}: {\n  stripeAccountId: string;\n  action: 'mute' | 'unmute';\n  durationMinutes?: number;\n}) {\n  if (!stripeAccountId) {\n    throw new Error('Stripe Account ID is required.');\n  }\n\n  const supabase = createSupabaseServerClient();\n  const {\n    data: { user },\n  } = await supabase.auth.getUser();\n\n  if (!user) {\n    throw new Error('Unauthorized: User not logged in');\n  }\n\n  console.log(\n    `User ${user.id} attempting to ${action} alerts for ${stripeAccountId} for ${durationMinutes || 'indefinite'} minutes.`,\n  );\n\n  let newMutedUntil: string | null = null;\n  if (action === 'mute') {\n    if (durationMinutes === Infinity || durationMinutes === undefined || durationMinutes === null) {\n      // PostgreSQL 'infinity' literal for timestamp\n      newMutedUntil = 'infinity';\n    } else if (typeof durationMinutes === 'number' && durationMinutes > 0) {\n      const now = new Date();\n      now.setMinutes(now.getMinutes() + durationMinutes);\n      newMutedUntil = now.toISOString();\n    } else {\n      // Default to a reasonable time if duration is invalid (e.g., 6 hours)\n      console.warn(\n        `Invalid durationMinutes (${durationMinutes}) provided for mute, defaulting to 360 minutes.`,\n      );\n      const now = new Date();\n      now.setMinutes(now.getMinutes() + 360);\n      newMutedUntil = now.toISOString();\n    }\n  } else {\n    // unmute\n    newMutedUntil = null;\n  }\n\n  try {\n    const { error: dbError } = await supabase\n      .from('connected_accounts')\n      .update({\n        alerts_muted_until: newMutedUntil,\n      })\n      .eq('user_id', user.id) // Ensure user owns this account\n      .eq('stripe_account_id', stripeAccountId);\n\n    if (dbError) {\n      console.error(\n        `Error updating connected_accounts for alert toggle (${action}) for ${stripeAccountId}:`,\n        dbError,\n      );\n      throw new Error('Failed to update account alert status in database.');\n    }\n    console.log(\n      `Updated connected_accounts for alert toggle (${action}) for ${stripeAccountId} until ${newMutedUntil || 'NULL'}.`,\n    );\n\n    revalidatePath('/settings/connected-accounts');\n    // Optionally revalidate dashboard if it displays mute status\n    // revalidatePath('/stripe-guardian/alerts');\n\n    return { success: true, mutedUntil: newMutedUntil };\n  } catch (error) {\n    console.error(`Error toggling alerts (${action}) for ${stripeAccountId}:`, error);\n    throw new Error(`Could not ${action} alerts. Please try again.`);\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/michaelfuscoletti/Desktop/dock108home/app/(auth)/settings/connected-accounts/page.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/michaelfuscoletti/Desktop/dock108home/app/(auth)/settings/layout.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/michaelfuscoletti/Desktop/dock108home/app/(auth)/settings/notifications/page.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/michaelfuscoletti/Desktop/dock108home/app/(auth)/settings/page.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/michaelfuscoletti/Desktop/dock108home/app/(auth)/settings/profile/page.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/michaelfuscoletti/Desktop/dock108home/app/(dashboard)/accounts/ConnectedAccountsManager.test.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/michaelfuscoletti/Desktop/dock108home/app/(dashboard)/accounts/ConnectedAccountsManager.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/michaelfuscoletti/Desktop/dock108home/app/(dashboard)/accounts/page.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/michaelfuscoletti/Desktop/dock108home/app/admin/accounts/[id]/settings/page.tsx","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":50,"column":42,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":50,"endColumn":45,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1457,1460],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1457,1460],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"'use client';\n\nimport { useEffect, useState } from 'react';\nimport { useRouter } from 'next/navigation';\nimport { createClientComponentClient } from '@supabase/auth-helpers-nextjs';\nimport { Database } from '@/types/supabase';\nimport { zodResolver } from '@hookform/resolvers/zod';\nimport { useForm } from 'react-hook-form';\nimport { z } from 'zod';\nimport Link from 'next/link';\nimport { Button } from '@/components/ui/button';\nimport { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';\nimport {\n  Form,\n  FormControl,\n  FormDescription,\n  FormField,\n  FormItem,\n  FormLabel,\n  FormMessage,\n} from '@/components/ui/form';\nimport { Checkbox } from '@/components/ui/checkbox';\nimport {\n  Select,\n  SelectContent,\n  SelectItem,\n  SelectTrigger,\n  SelectValue,\n} from '@/components/ui/select';\nimport { toast } from '@/components/ui/use-toast';\nimport { ArrowLeft, Loader2 } from 'lucide-react';\n\nconst formSchema = z.object({\n  is_active: z.boolean().default(true),\n  rule_set_id: z.string().nullable(),\n});\n\ntype FormValues = z.infer<typeof formSchema>;\n\ninterface RuleSet {\n  id: string;\n  name: string;\n}\n\nexport default function AccountSettingsPage({ params }: { params: { id: string } }) {\n  const router = useRouter();\n  const supabase = createClientComponentClient<Database>();\n  const [isSubmitting, setIsSubmitting] = useState(false);\n  const [isLoading, setIsLoading] = useState(true);\n  const [account, setAccount] = useState<any>(null);\n  const [ruleSets, setRuleSets] = useState<RuleSet[]>([]);\n  const [error, setError] = useState<string | null>(null);\n\n  const form = useForm<FormValues>({\n    resolver: zodResolver(formSchema),\n    defaultValues: {\n      is_active: true,\n      rule_set_id: null,\n    },\n  });\n\n  useEffect(() => {\n    const fetchData = async () => {\n      setIsLoading(true);\n      setError(null);\n\n      try {\n        // Fetch account details\n        const { data: accountData, error: accountError } = await supabase\n          .from('accounts')\n          .select('*')\n          .eq('id', params.id)\n          .single();\n\n        if (accountError) {\n          throw new Error(`Error fetching account: ${accountError.message}`);\n        }\n\n        if (!accountData) {\n          throw new Error('Account not found');\n        }\n\n        setAccount(accountData);\n\n        // Fetch rule sets\n        const { data: ruleSetsData, error: ruleSetsError } = await supabase\n          .from('rule_sets')\n          .select('id, name')\n          .order('name', { ascending: true });\n\n        if (ruleSetsError) {\n          throw new Error(`Error fetching rule sets: ${ruleSetsError.message}`);\n        }\n\n        setRuleSets(ruleSetsData || []);\n\n        // Set form default values\n        form.reset({\n          is_active: accountData.is_active,\n          rule_set_id: accountData.rule_set_id,\n        });\n      } catch (err) {\n        console.error('Error fetching data:', err);\n        setError(err instanceof Error ? err.message : 'Unknown error occurred');\n      } finally {\n        setIsLoading(false);\n      }\n    };\n\n    fetchData();\n  }, [params.id, supabase, form]);\n\n  const onSubmit = async (values: FormValues) => {\n    setIsSubmitting(true);\n    setError(null);\n\n    try {\n      // Update account settings\n      const { error: updateError } = await supabase\n        .from('accounts')\n        .update({\n          is_active: values.is_active,\n          rule_set_id: values.rule_set_id,\n        })\n        .eq('id', params.id);\n\n      if (updateError) {\n        throw new Error(updateError.message);\n      }\n\n      toast({\n        title: 'Settings updated',\n        description: 'Account settings have been updated successfully.',\n      });\n\n      // Refresh account data\n      const { data: accountData, error: accountError } = await supabase\n        .from('accounts')\n        .select('*')\n        .eq('id', params.id)\n        .single();\n\n      if (!accountError && accountData) {\n        setAccount(accountData);\n      }\n    } catch (error) {\n      console.error('Error updating account settings:', error);\n      setError(error instanceof Error ? error.message : 'Unknown error occurred');\n      toast({\n        title: 'Error',\n        description: `Failed to update settings: ${error instanceof Error ? error.message : 'Unknown error'}`,\n        variant: 'destructive',\n      });\n    } finally {\n      setIsSubmitting(false);\n    }\n  };\n\n  if (isLoading) {\n    return (\n      <div className=\"flex items-center justify-center min-h-[60vh]\">\n        <Loader2 className=\"h-8 w-8 animate-spin text-muted-foreground\" />\n      </div>\n    );\n  }\n\n  if (error) {\n    return (\n      <div className=\"space-y-6\">\n        <div className=\"flex items-center gap-2\">\n          <Button variant=\"outline\" size=\"icon\" asChild>\n            <Link href=\"/admin/accounts\">\n              <ArrowLeft className=\"h-4 w-4\" />\n              <span className=\"sr-only\">Back</span>\n            </Link>\n          </Button>\n          <h1 className=\"text-3xl font-bold tracking-tight\">Error</h1>\n        </div>\n        <Card>\n          <CardContent className=\"pt-6\">\n            <p className=\"text-destructive\">{error}</p>\n            <Button className=\"mt-4\" onClick={() => router.push('/admin/accounts')}>\n              Return to Accounts\n            </Button>\n          </CardContent>\n        </Card>\n      </div>\n    );\n  }\n\n  return (\n    <div className=\"space-y-6\">\n      <div className=\"flex items-center gap-2\">\n        <Button variant=\"outline\" size=\"icon\" asChild>\n          <Link href=\"/admin/accounts\">\n            <ArrowLeft className=\"h-4 w-4\" />\n            <span className=\"sr-only\">Back</span>\n          </Link>\n        </Button>\n        <h1 className=\"text-3xl font-bold tracking-tight\">Account Settings</h1>\n      </div>\n\n      <Card>\n        <CardHeader>\n          <CardTitle>{account?.display_name || 'Unnamed Account'}</CardTitle>\n        </CardHeader>\n        <CardContent>\n          <div className=\"mb-6 text-sm\">\n            <div className=\"grid grid-cols-2 gap-1\">\n              <div className=\"text-muted-foreground\">Stripe ID:</div>\n              <div className=\"font-mono\">{account?.stripe_id}</div>\n              <div className=\"text-muted-foreground\">Created:</div>\n              <div>{new Date(account?.created_at).toLocaleDateString()}</div>\n            </div>\n          </div>\n\n          <Form {...form}>\n            <form onSubmit={form.handleSubmit(onSubmit)} className=\"space-y-6\">\n              <FormField\n                control={form.control}\n                name=\"is_active\"\n                render={({ field }) => (\n                  <FormItem className=\"flex flex-row items-start space-x-3 space-y-0 rounded-md border p-4\">\n                    <FormControl>\n                      <Checkbox checked={field.value} onCheckedChange={field.onChange} />\n                    </FormControl>\n                    <div className=\"space-y-1 leading-none\">\n                      <FormLabel>Active</FormLabel>\n                      <FormDescription>\n                        When active, alerts will be processed for this account\n                      </FormDescription>\n                    </div>\n                  </FormItem>\n                )}\n              />\n\n              <FormField\n                control={form.control}\n                name=\"rule_set_id\"\n                render={({ field }) => (\n                  <FormItem>\n                    <FormLabel>Rule Set</FormLabel>\n                    <Select onValueChange={field.onChange} value={field.value || ''}>\n                      <FormControl>\n                        <SelectTrigger>\n                          <SelectValue placeholder=\"Select a rule set\" />\n                        </SelectTrigger>\n                      </FormControl>\n                      <SelectContent>\n                        <SelectItem value=\"\">Default (No custom rules)</SelectItem>\n                        {ruleSets.map((ruleSet) => (\n                          <SelectItem key={ruleSet.id} value={ruleSet.id}>\n                            {ruleSet.name}\n                          </SelectItem>\n                        ))}\n                      </SelectContent>\n                    </Select>\n                    <FormDescription>\n                      Assign a rule set to customize alert behavior for this account\n                    </FormDescription>\n                    <FormMessage />\n                  </FormItem>\n                )}\n              />\n\n              <div className=\"flex justify-end space-x-2\">\n                <Button\n                  type=\"button\"\n                  variant=\"outline\"\n                  onClick={() => router.push('/admin/accounts')}\n                  disabled={isSubmitting}\n                >\n                  Cancel\n                </Button>\n                <Button type=\"submit\" disabled={isSubmitting}>\n                  {isSubmitting ? 'Saving...' : 'Save Changes'}\n                </Button>\n              </div>\n            </form>\n          </Form>\n        </CardContent>\n      </Card>\n    </div>\n  );\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/michaelfuscoletti/Desktop/dock108home/app/admin/accounts/page.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/michaelfuscoletti/Desktop/dock108home/app/admin/layout.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/michaelfuscoletti/Desktop/dock108home/app/admin/notification-channels/create-notification-channel.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/michaelfuscoletti/Desktop/dock108home/app/admin/notification-channels/notification-channel-actions.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/michaelfuscoletti/Desktop/dock108home/app/admin/notification-channels/page.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/michaelfuscoletti/Desktop/dock108home/app/admin/page.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/michaelfuscoletti/Desktop/dock108home/app/admin/rule-sets/page.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/michaelfuscoletti/Desktop/dock108home/app/admin/rulesets/[id]/edit/page.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/michaelfuscoletti/Desktop/dock108home/app/admin/rulesets/[id]/page.tsx","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":25,"column":42,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":25,"endColumn":45,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[876,879],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[876,879],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":26,"column":44,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":26,"endColumn":47,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[931,934],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[931,934],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":162,"column":67,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":162,"endColumn":70,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5257,5260],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5257,5260],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"'use client';\n\nimport { useEffect, useState } from 'react';\nimport { useRouter } from 'next/navigation';\nimport { createClientComponentClient } from '@supabase/auth-helpers-nextjs';\nimport { Database } from '@/types/supabase';\nimport Link from 'next/link';\nimport { Button } from '@/components/ui/button';\nimport { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';\nimport {\n  Table,\n  TableBody,\n  TableCell,\n  TableHead,\n  TableHeader,\n  TableRow,\n} from '@/components/ui/table';\nimport { Badge } from '@/components/ui/badge';\nimport { ArrowLeft, Edit, Loader2 } from 'lucide-react';\n\nexport default function RuleSetDetailsPage({ params }: { params: { id: string } }) {\n  const router = useRouter();\n  const supabase = createClientComponentClient<Database>();\n  const [isLoading, setIsLoading] = useState(true);\n  const [ruleSet, setRuleSet] = useState<any>(null);\n  const [accounts, setAccounts] = useState<any[]>([]);\n  const [error, setError] = useState<string | null>(null);\n\n  useEffect(() => {\n    const fetchData = async () => {\n      setIsLoading(true);\n      setError(null);\n\n      try {\n        // Fetch rule set details\n        const { data: ruleSetData, error: ruleSetError } = await supabase\n          .from('rule_sets')\n          .select(`\n            *,\n            notification_channels (\n              id,\n              name,\n              type\n            )\n          `)\n          .eq('id', params.id)\n          .single();\n\n        if (ruleSetError) {\n          throw new Error(`Error fetching rule set: ${ruleSetError.message}`);\n        }\n\n        if (!ruleSetData) {\n          throw new Error('Rule set not found');\n        }\n\n        setRuleSet(ruleSetData);\n\n        // Fetch accounts using this rule set\n        const { data: accountsData, error: accountsError } = await supabase\n          .from('accounts')\n          .select('*')\n          .eq('rule_set_id', params.id)\n          .order('display_name', { ascending: true });\n\n        if (accountsError) {\n          throw new Error(`Error fetching accounts: ${accountsError.message}`);\n        }\n\n        setAccounts(accountsData || []);\n      } catch (err) {\n        console.error('Error fetching data:', err);\n        setError(err instanceof Error ? err.message : 'Unknown error occurred');\n      } finally {\n        setIsLoading(false);\n      }\n    };\n\n    fetchData();\n  }, [params.id, supabase]);\n\n  if (isLoading) {\n    return (\n      <div className=\"flex items-center justify-center min-h-[60vh]\">\n        <Loader2 className=\"h-8 w-8 animate-spin text-muted-foreground\" />\n      </div>\n    );\n  }\n\n  if (error) {\n    return (\n      <div className=\"space-y-6\">\n        <div className=\"flex items-center gap-2\">\n          <Button variant=\"outline\" size=\"icon\" asChild>\n            <Link href=\"/admin/rulesets\">\n              <ArrowLeft className=\"h-4 w-4\" />\n              <span className=\"sr-only\">Back</span>\n            </Link>\n          </Button>\n          <h1 className=\"text-3xl font-bold tracking-tight\">Error</h1>\n        </div>\n        <Card>\n          <CardContent className=\"pt-6\">\n            <p className=\"text-destructive\">{error}</p>\n            <Button\n              className=\"mt-4\"\n              onClick={() => router.push('/admin/rulesets')}\n            >\n              Return to Rule Sets\n            </Button>\n          </CardContent>\n        </Card>\n      </div>\n    );\n  }\n\n  return (\n    <div className=\"space-y-6\">\n      <div className=\"flex items-center justify-between\">\n        <div className=\"flex items-center gap-2\">\n          <Button variant=\"outline\" size=\"icon\" asChild>\n            <Link href=\"/admin/rulesets\">\n              <ArrowLeft className=\"h-4 w-4\" />\n              <span className=\"sr-only\">Back</span>\n            </Link>\n          </Button>\n          <h1 className=\"text-3xl font-bold tracking-tight\">{ruleSet.name}</h1>\n        </div>\n        <Button asChild>\n          <Link href={`/admin/rulesets/${params.id}/edit`}>\n            <Edit className=\"h-4 w-4 mr-2\" /> Edit Rule Set\n          </Link>\n        </Button>\n      </div>\n\n      <div className=\"grid gap-6 grid-cols-1 lg:grid-cols-2\">\n        <Card>\n          <CardHeader>\n            <CardTitle>Rule Set Details</CardTitle>\n          </CardHeader>\n          <CardContent>\n            <div className=\"space-y-4\">\n              <div>\n                <h3 className=\"font-semibold text-sm text-muted-foreground\">Description</h3>\n                <p className=\"mt-1\">{ruleSet.description || 'No description provided'}</p>\n              </div>\n              \n              <div>\n                <h3 className=\"font-semibold text-sm text-muted-foreground\">Status</h3>\n                <Badge \n                  className=\"mt-1\"\n                  variant={ruleSet.is_active ? \"default\" : \"secondary\"}\n                >\n                  {ruleSet.is_active ? 'Active' : 'Inactive'}\n                </Badge>\n              </div>\n              \n              <div>\n                <h3 className=\"font-semibold text-sm text-muted-foreground\">Notification Channel</h3>\n                <p className=\"mt-1\">\n                  {ruleSet.notification_channels && ruleSet.notification_channels.length > 0\n                    ? ruleSet.notification_channels.map((channel: any) => (\n                        <Badge key={channel.id} variant=\"outline\" className=\"mr-2\">\n                          {channel.name} ({channel.type})\n                        </Badge>\n                      ))\n                    : 'No notification channel assigned'}\n                </p>\n              </div>\n              \n              <div>\n                <h3 className=\"font-semibold text-sm text-muted-foreground\">Created</h3>\n                <p className=\"mt-1\">{new Date(ruleSet.created_at).toLocaleString()}</p>\n              </div>\n              \n              <div>\n                <h3 className=\"font-semibold text-sm text-muted-foreground\">Last Modified</h3>\n                <p className=\"mt-1\">{new Date(ruleSet.updated_at).toLocaleString()}</p>\n              </div>\n            </div>\n          </CardContent>\n        </Card>\n\n        <Card>\n          <CardHeader>\n            <CardTitle>Rules Configuration</CardTitle>\n          </CardHeader>\n          <CardContent>\n            <pre className=\"bg-muted p-4 rounded-md overflow-auto text-xs font-mono h-[300px]\">\n              {JSON.stringify(ruleSet.rules_config, null, 2) || '{}'}\n            </pre>\n          </CardContent>\n        </Card>\n      </div>\n\n      <Card>\n        <CardHeader>\n          <CardTitle>Accounts Using This Rule Set</CardTitle>\n        </CardHeader>\n        <CardContent>\n          {accounts.length === 0 ? (\n            <p className=\"text-muted-foreground\">No accounts are currently using this rule set.</p>\n          ) : (\n            <Table>\n              <TableHeader>\n                <TableRow>\n                  <TableHead>Account Name</TableHead>\n                  <TableHead>Stripe ID</TableHead>\n                  <TableHead>Status</TableHead>\n                  <TableHead className=\"w-[100px]\">Actions</TableHead>\n                </TableRow>\n              </TableHeader>\n              <TableBody>\n                {accounts.map((account) => (\n                  <TableRow key={account.id}>\n                    <TableCell className=\"font-medium\">\n                      {account.display_name || 'Unnamed Account'}\n                    </TableCell>\n                    <TableCell className=\"font-mono text-xs\">{account.stripe_id}</TableCell>\n                    <TableCell>\n                      <Badge variant={account.is_active ? 'default' : 'secondary'}>\n                        {account.is_active ? 'Active' : 'Disabled'}\n                      </Badge>\n                    </TableCell>\n                    <TableCell>\n                      <Button variant=\"outline\" size=\"sm\" asChild>\n                        <Link href={`/admin/accounts/${account.id}/settings`}>\n                          View Settings\n                        </Link>\n                      </Button>\n                    </TableCell>\n                  </TableRow>\n                ))}\n              </TableBody>\n            </Table>\n          )}\n        </CardContent>\n      </Card>\n    </div>\n  );\n} ","usedDeprecatedRules":[]},{"filePath":"/Users/michaelfuscoletti/Desktop/dock108home/app/admin/rulesets/create/page.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/michaelfuscoletti/Desktop/dock108home/app/admin/rulesets/page.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/michaelfuscoletti/Desktop/dock108home/app/admin/settings/notification-settings-form.tsx","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":51,"column":20,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":51,"endColumn":23,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1648,1651],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1648,1651],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":111,"column":19,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":111,"endColumn":22,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3823,3826],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3823,3826],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"'use client';\n\nimport { useState } from 'react';\nimport { createClientComponentClient } from '@supabase/auth-helpers-nextjs';\nimport { Database } from '@/types/supabase';\nimport { useRouter } from 'next/navigation';\nimport { zodResolver } from '@hookform/resolvers/zod';\nimport { useForm } from 'react-hook-form';\nimport * as z from 'zod';\nimport { toast } from 'sonner';\n\nimport { Button } from '@/components/ui/button';\nimport {\n  Form,\n  FormControl,\n  FormDescription,\n  FormField,\n  FormItem,\n  FormLabel,\n  FormMessage,\n} from '@/components/ui/form';\nimport { Input } from '@/components/ui/input';\nimport { Checkbox } from '@/components/ui/checkbox';\nimport { Textarea } from '@/components/ui/textarea';\nimport { Separator } from '@/components/ui/separator';\nimport { AlertCircle, Loader2 } from 'lucide-react';\nimport { Alert, AlertDescription, AlertTitle } from '@/components/ui/alert';\n// import { updateAdminSettingsServerAction } from './actions'; // Commented out\n\n// Define form schema\nconst formSchema = z.object({\n  default_notification_channels: z.array(z.string()).optional(),\n  alert_threshold: z.coerce.number().min(0).max(100).optional(),\n  email_recipients: z.string().optional(),\n  slack_webhook_url: z.string().url().optional().or(z.literal('')),\n  teams_webhook_url: z.string().url().optional().or(z.literal('')),\n  send_daily_summary: z.boolean().default(false),\n  summary_time: z.string().optional(),\n});\n\ntype FormValues = z.infer<typeof formSchema>;\n\nexport type NotificationChannel = {\n  id: string;\n  name: string;\n  type: string;\n  created_at: string;\n};\n\ninterface NotificationSettingsFormProps {\n  initialSettings: any;\n  // notificationChannels: NotificationChannel[]; // Commented out unused prop\n}\n\nexport default function NotificationSettingsForm({\n  initialSettings,\n  // notificationChannels, // Commented out unused prop\n}: NotificationSettingsFormProps) {\n  const [isSubmitting, setIsSubmitting] = useState(false);\n  const [error, setError] = useState<string | null>(null);\n  const router = useRouter();\n  const supabase = createClientComponentClient<Database>();\n\n  // Convert email_recipients array to string for form\n  const emailRecipientsStr = initialSettings.email_recipients\n    ? Array.isArray(initialSettings.email_recipients)\n      ? initialSettings.email_recipients.join(', ')\n      : initialSettings.email_recipients\n    : '';\n\n  // Initialize form with existing settings\n  const form = useForm<FormValues>({\n    resolver: zodResolver(formSchema),\n    defaultValues: {\n      default_notification_channels: initialSettings.default_notification_channels || [],\n      alert_threshold: initialSettings.alert_threshold || 3,\n      email_recipients: emailRecipientsStr,\n      slack_webhook_url: initialSettings.slack_webhook_url || '',\n      teams_webhook_url: initialSettings.teams_webhook_url || '',\n      send_daily_summary: initialSettings.send_daily_summary || false,\n      summary_time: initialSettings.summary_time || '08:00',\n    },\n  });\n\n  async function onSubmit(values: FormValues) {\n    setIsSubmitting(true);\n    setError(null);\n\n    try {\n      // Process email recipients\n      const emailRecipients = values.email_recipients\n        ? values.email_recipients.split(',').map((email) => email.trim())\n        : null;\n\n      const settingsData = {\n        ...values,\n        email_recipients: emailRecipients,\n        updated_at: new Date().toISOString(),\n      };\n\n      // Always UPSERT the global settings row\n      const { error: upsertError } = await supabase\n        .from('settings')\n        .upsert({ ...settingsData, id: 'global_settings' })\n        .eq('id', 'global_settings'); // Match on ID for upsert\n\n      if (upsertError) throw upsertError;\n\n      toast.success('Global settings updated successfully');\n      router.refresh();\n    } catch (err: any) {\n      console.error('Error saving settings:', err);\n      setError(err.message || 'Failed to save settings');\n      toast.error('Failed to update settings');\n    } finally {\n      setIsSubmitting(false);\n    }\n  }\n\n  return (\n    <div className=\"space-y-6\">\n      {error && (\n        <Alert variant=\"destructive\">\n          <AlertCircle className=\"h-4 w-4\" />\n          <AlertTitle>Error</AlertTitle>\n          <AlertDescription>{error}</AlertDescription>\n        </Alert>\n      )}\n\n      <Form {...form}>\n        <form onSubmit={form.handleSubmit(onSubmit)} className=\"space-y-8\">\n          <div className=\"space-y-4\">\n            <h3 className=\"text-lg font-medium\">Alert Notification Settings</h3>\n            <Separator />\n\n            <FormField\n              control={form.control}\n              name=\"alert_threshold\"\n              render={({ field }) => (\n                <FormItem>\n                  <FormLabel>Alert Threshold</FormLabel>\n                  <FormControl>\n                    <Input type=\"number\" min={0} max={100} {...field} />\n                  </FormControl>\n                  <FormDescription>\n                    Number of alerts required before sending notifications\n                  </FormDescription>\n                  <FormMessage />\n                </FormItem>\n              )}\n            />\n\n            <div className=\"grid grid-cols-1 md:grid-cols-2 gap-6\">\n              <FormField\n                control={form.control}\n                name=\"slack_webhook_url\"\n                render={({ field }) => (\n                  <FormItem>\n                    <FormLabel>Slack Webhook URL</FormLabel>\n                    <FormControl>\n                      <Input placeholder=\"https://hooks.slack.com/...\" {...field} />\n                    </FormControl>\n                    <FormDescription>Webhook URL for Slack notifications</FormDescription>\n                    <FormMessage />\n                  </FormItem>\n                )}\n              />\n\n              <FormField\n                control={form.control}\n                name=\"teams_webhook_url\"\n                render={({ field }) => (\n                  <FormItem>\n                    <FormLabel>Microsoft Teams Webhook URL</FormLabel>\n                    <FormControl>\n                      <Input placeholder=\"https://outlook.office.com/webhook/...\" {...field} />\n                    </FormControl>\n                    <FormDescription>Webhook URL for Microsoft Teams notifications</FormDescription>\n                    <FormMessage />\n                  </FormItem>\n                )}\n              />\n            </div>\n\n            <FormField\n              control={form.control}\n              name=\"email_recipients\"\n              render={({ field }) => (\n                <FormItem>\n                  <FormLabel>Email Recipients</FormLabel>\n                  <FormControl>\n                    <Textarea placeholder=\"email1@example.com, email2@example.com\" {...field} />\n                  </FormControl>\n                  <FormDescription>Comma-separated list of email addresses</FormDescription>\n                  <FormMessage />\n                </FormItem>\n              )}\n            />\n          </div>\n\n          <div className=\"space-y-4\">\n            <h3 className=\"text-lg font-medium\">Daily Summary Settings</h3>\n            <Separator />\n\n            <FormField\n              control={form.control}\n              name=\"send_daily_summary\"\n              render={({ field }) => (\n                <FormItem className=\"flex flex-row items-start space-x-3 space-y-0 rounded-md border p-4\">\n                  <FormControl>\n                    <Checkbox checked={field.value} onCheckedChange={field.onChange} />\n                  </FormControl>\n                  <div className=\"space-y-1 leading-none\">\n                    <FormLabel>Send Daily Summary</FormLabel>\n                    <FormDescription>\n                      Send a daily summary of alerts to all notification channels\n                    </FormDescription>\n                  </div>\n                </FormItem>\n              )}\n            />\n\n            {form.watch('send_daily_summary') && (\n              <FormField\n                control={form.control}\n                name=\"summary_time\"\n                render={({ field }) => (\n                  <FormItem>\n                    <FormLabel>Summary Time (UTC)</FormLabel>\n                    <FormControl>\n                      <Input type=\"time\" {...field} />\n                    </FormControl>\n                    <FormDescription>\n                      Time of day to send the summary (in UTC timezone)\n                    </FormDescription>\n                    <FormMessage />\n                  </FormItem>\n                )}\n              />\n            )}\n          </div>\n\n          <div className=\"flex justify-end\">\n            <Button type=\"submit\" disabled={isSubmitting}>\n              {isSubmitting && <Loader2 className=\"mr-2 h-4 w-4 animate-spin\" />}\n              Save Settings\n            </Button>\n          </div>\n        </form>\n      </Form>\n    </div>\n  );\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/michaelfuscoletti/Desktop/dock108home/app/admin/settings/page.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/michaelfuscoletti/Desktop/dock108home/app/api/accounts/[id]/disconnect/route.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/michaelfuscoletti/Desktop/dock108home/app/api/accounts/[id]/route.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":88,"column":19,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":88,"endColumn":22,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3494,3497],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3494,3497],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":158,"column":19,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":158,"endColumn":22,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6019,6022],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6019,6022],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { createServerClient } from '@supabase/ssr';\nimport { cookies } from 'next/headers';\nimport { NextRequest, NextResponse } from 'next/server';\nimport { Database } from '@/types/supabase';\nimport { createAdminClient } from '@/lib/supabase/admin'; // Use admin for updates?\nimport { z } from 'zod';\n\n// Placeholder for pausing rules/notifications\nasync function pauseAccountMonitoring(accountId: string) {\n  console.warn(`TODO: Implement pauseAccountMonitoring for ${accountId}`);\n  // This function would interact with your rule engine or notification system\n  // to stop processing/alerting for the disconnected account.\n}\n\n// Schema to validate the PATCH request body\nconst updateSchema = z.object({\n  rule_set_id: z.string().uuid().nullable(), // Allow null to set back to default\n});\n\n// Helper function to check user role (Replace with your actual implementation)\nasync function checkUserRole(userId: string, role: string): Promise<boolean> {\n  console.warn(`TODO: Implement checkUserRole for user ${userId}, role ${role}. Returning false.`);\n  // Example using raw_app_meta_data:\n  // const supabaseAdmin = createAdminClient();\n  // const { data, error } = await supabaseAdmin.auth.admin.getUserById(userId);\n  // if (error) return false;\n  // return data.user?.user_metadata?.role === role;\n  return false; // Placeholder\n}\n\nexport async function DELETE(request: NextRequest, { params }: { params: { id: string } }) {\n  const accountId = params.id; // This is the Stripe Account ID (e.g., acct_...)\n\n  // Basic validation\n  if (!accountId || !accountId.startsWith('acct_')) {\n    return NextResponse.json({ error: 'Invalid account ID format.' }, { status: 400 });\n  }\n\n  const cookieStore = cookies();\n  const supabase = createServerClient<Database>(\n    process.env.NEXT_PUBLIC_SUPABASE_URL!,\n    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,\n    { cookies: { get: (name) => cookieStore.get(name)?.value } },\n  );\n\n  try {\n    // Get current user\n    const {\n      data: { user },\n      error: userError,\n    } = await supabase.auth.getUser();\n    if (userError || !user) {\n      return NextResponse.json({ error: 'Not authenticated' }, { status: 401 });\n    }\n\n    // Use Admin client to update status, RLS might block user update\n    const supabaseAdmin = createAdminClient();\n\n    // Update the status in the database\n    // We select 'id' to check if the update affected any row owned by the user\n    // Note: RLS on SELECT applies even when using admin client if not bypassed?\n    // Alternative: check ownership before update.\n    const { data, error: updateError } = await supabaseAdmin\n      .from('stripe_accounts')\n      .update({ status: 'disconnected' })\n      .eq('stripe_account_id', accountId)\n      .eq('user_id', user.id) // Ensure user owns this account before updating\n      .select('id')\n      .maybeSingle();\n\n    if (updateError) {\n      console.error(`Error disconnecting account ${accountId}:`, updateError);\n      return NextResponse.json({ error: 'Failed to disconnect account.' }, { status: 500 });\n    }\n\n    if (!data) {\n      // This means no row was found matching the accountId AND userId\n      return NextResponse.json(\n        { error: 'Account not found or permission denied.' },\n        { status: 404 },\n      );\n    }\n\n    // Successfully marked as disconnected, now pause monitoring\n    await pauseAccountMonitoring(accountId);\n\n    return NextResponse.json({ message: 'Account disconnected successfully.' }, { status: 200 });\n  } catch (error: any) {\n    console.error(`Unexpected error disconnecting ${accountId}:`, error);\n    return NextResponse.json({ error: 'Internal server error' }, { status: 500 });\n  }\n}\n\nexport async function PATCH(request: NextRequest, { params }: { params: { id: string } }) {\n  const accountId = params.id; // Stripe Account ID\n\n  // Basic validation\n  if (!accountId || !accountId.startsWith('acct_')) {\n    return NextResponse.json({ error: 'Invalid account ID format.' }, { status: 400 });\n  }\n\n  const cookieStore = cookies();\n  const supabase = createServerClient<Database>(\n    process.env.NEXT_PUBLIC_SUPABASE_URL!,\n    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,\n    { cookies: { get: (name) => cookieStore.get(name)?.value } },\n  );\n\n  try {\n    // Get current user\n    const {\n      data: { user },\n      error: userError,\n    } = await supabase.auth.getUser();\n    if (userError || !user) {\n      return NextResponse.json({ error: 'Not authenticated' }, { status: 401 });\n    }\n\n    // Authorization: Check if user has 'admin' role\n    const isAdmin = await checkUserRole(user.id, 'admin');\n    if (!isAdmin) {\n      return NextResponse.json({ error: 'Forbidden: Requires admin role.' }, { status: 403 });\n    }\n\n    // Validate request body\n    const body = await request.json();\n    const validationResult = updateSchema.safeParse(body);\n    if (!validationResult.success) {\n      return NextResponse.json(\n        { error: 'Invalid request body', details: validationResult.error.flatten() },\n        { status: 400 },\n      );\n    }\n\n    const { rule_set_id } = validationResult.data;\n\n    // Use Admin client to perform the update\n    const supabaseAdmin = createAdminClient();\n\n    // Update the rule_set_id\n    const { error: updateError } = await supabaseAdmin\n      .from('stripe_accounts')\n      .update({ rule_set_id: rule_set_id })\n      .eq('stripe_account_id', accountId);\n    // No user_id check here as admin can update any account\n\n    if (updateError) {\n      // Handle specific errors like foreign key violation if rule_set_id doesn't exist\n      if (updateError.code === '23503') {\n        // foreign_key_violation\n        return NextResponse.json({ error: 'Invalid rule_set_id provided.' }, { status: 400 });\n      }\n      console.error(`Error updating rule_set_id for ${accountId}:`, updateError);\n      return NextResponse.json({ error: 'Failed to update rule set.' }, { status: 500 });\n    }\n\n    return NextResponse.json({ message: 'Rule set updated successfully.' }, { status: 200 });\n  } catch (error: any) {\n    if (error instanceof SyntaxError) {\n      // Handle JSON parsing error\n      return NextResponse.json({ error: 'Invalid JSON in request body' }, { status: 400 });\n    }\n    console.error(`Unexpected error updating ${accountId}:`, error);\n    return NextResponse.json({ error: 'Internal server error' }, { status: 500 });\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/michaelfuscoletti/Desktop/dock108home/app/api/accounts/[id]/webhook/rotate/route.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/michaelfuscoletti/Desktop/dock108home/app/api/accounts/route.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":66,"column":19,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":66,"endColumn":22,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2424,2427],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2424,2427],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { createServerClient } from '@supabase/ssr';\nimport { cookies } from 'next/headers';\nimport { /* NextRequest, */ NextResponse } from 'next/server';\nimport { Database } from '@/types/supabase';\n\n// Select fields needed by the frontend\n// Join stripe_accounts with account_backfill_status\nconst ACCOUNTS_QUERY = `\n  id, \n  stripe_account_id, \n  status, \n  scope, \n  created_at, \n  rule_set_id,\n  rule_sets ( id, name ), \n  account_backfill_status ( status, progress, error_message, updated_at )\n`;\n\n// GET: Fetch all accounts with their assigned rule set names\nexport async function GET(/* _request: NextRequest */) {\n  const cookieStore = cookies();\n  const supabase = createServerClient<Database>(\n    process.env.NEXT_PUBLIC_SUPABASE_URL!,\n    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,\n    { cookies: { get: (name) => cookieStore.get(name)?.value } },\n  );\n\n  try {\n    // Get current user - RLS relies on this being set\n    const {\n      data: { user },\n      error: userError,\n    } = await supabase.auth.getUser();\n    if (userError || !user) {\n      return NextResponse.json({ error: 'Not authenticated' }, { status: 401 });\n    }\n\n    // Fetch accounts for the user\n    // RLS on stripe_accounts ensures user can only select their own.\n    const { data: accountsData, error: accountsError } = await supabase\n      .from('stripe_accounts')\n      .select(ACCOUNTS_QUERY)\n      .order('created_at', { ascending: false });\n\n    if (accountsError) {\n      console.error('Error fetching connected accounts:', accountsError);\n      return NextResponse.json({ error: 'Failed to fetch accounts' }, { status: 500 });\n    }\n\n    // Transform data slightly for frontend consistency?\n    // e.g., flatten backfill status\n    const transformedAccounts =\n      accountsData?.map((acc) => ({\n        ...acc,\n        backfill_status: acc.account_backfill_status[0]?.status ?? 'unknown',\n        backfill_progress: acc.account_backfill_status[0]?.progress ?? 0,\n        backfill_error: acc.account_backfill_status[0]?.error_message ?? null,\n        backfill_updated_at: acc.account_backfill_status[0]?.updated_at ?? null,\n        rule_set_name: acc.rule_sets?.name ?? 'Default', // Provide default name if null/no join\n        // Remove nested objects if not needed\n        account_backfill_status: undefined,\n        rule_sets: undefined,\n      })) ?? [];\n\n    return NextResponse.json(transformedAccounts);\n  } catch (error: any) {\n    console.error('Unexpected error in /api/accounts GET:', error);\n    return NextResponse.json({ error: 'Internal server error' }, { status: 500 });\n  }\n}\n\n// POST /api/accounts - Link a new Stripe account\nexport async function POST(/* _request: Request */) {\n  console.log('POST /api/accounts called');\n  // const supabase = createServerClient<Database>( // Removed unused variable\n  //   process.env.NEXT_PUBLIC_SUPABASE_URL!,\n  //   process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,\n  //   { cookies: { get: (name) => cookies().get(name)?.value } },\n  // );\n\n  // ... existing code ...\n  // The actual logic for POST (likely creating a Stripe connect link)\n  // should use a Supabase client if it needs user info or to store state.\n  // If the entire POST logic was removed, this function might be obsolete.\n  // For now, just removing the unused client.\n  return NextResponse.json({ message: 'POST handler needs implementation' }, { status: 501 });\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/michaelfuscoletti/Desktop/dock108home/app/api/admin/accounts/route.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":62,"column":19,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":62,"endColumn":22,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2056,2059],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2056,2059],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":148,"column":19,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":148,"endColumn":22,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4754,4757],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4754,4757],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { NextResponse } from 'next/server';\nimport { cookies } from 'next/headers';\nimport { createRouteHandlerClient } from '@supabase/auth-helpers-nextjs';\nimport { Database } from '@/types/supabase';\nimport { z } from 'zod';\n\n// Helper function to check admin role (can be shared/imported)\nasync function checkAdmin(\n  supabase: ReturnType<typeof createRouteHandlerClient<Database>>,\n): Promise<boolean> {\n  const {\n    data: { user },\n    error: userError,\n  } = await supabase.auth.getUser();\n  return !userError && !!user && user.app_metadata?.role === 'admin';\n}\n\n// Zod schema for updating account's rule set\nconst updateAccountSchema = z.object({\n  rule_set_id: z.string().uuid({ message: 'Invalid Rule Set ID.' }).nullable(), // Allow setting to null\n});\n\n// GET: Fetch all accounts with their assigned rule set names\nexport async function GET(/* _request: Request */) {\n  console.log('GET /api/admin/accounts called');\n  const cookieStore = cookies();\n  const supabase = createRouteHandlerClient<Database>({ cookies: () => cookieStore });\n\n  const isAdmin = await checkAdmin(supabase);\n  if (!isAdmin) {\n    return NextResponse.json({ error: 'Forbidden' }, { status: 403 });\n  }\n\n  try {\n    // Fetch accounts and join with rule_sets to get the name\n    // Adjust column names ('stripe_account_id', 'account_name', 'status') as per your actual schema\n    const { data, error } = await supabase\n      .from('accounts')\n      .select(\n        `\n        id, \n        stripe_account_id, \n        account_name, \n        status, \n        created_at, \n        rule_set_id,\n        rule_sets ( name )\n      `,\n      )\n      .order('created_at', { ascending: false });\n\n    if (error) throw error;\n\n    // Process data to flatten the rule set name\n    const processedData = data.map((account) => ({\n      ...account,\n      rule_set_name: account.rule_sets?.name || 'Default', // Show 'Default' or similar if null/no rule set\n      rule_sets: undefined, // Remove the nested object\n    }));\n\n    return NextResponse.json(processedData);\n  } catch (error: any) {\n    console.error('Error fetching accounts:', error);\n    return NextResponse.json(\n      { error: 'Failed to fetch accounts', details: error.message },\n      { status: 500 },\n    );\n  }\n}\n\n// PATCH: Update the rule_set_id for a specific account\nexport async function PATCH(\n  _request: Request,\n  {} /* params */ : { params: { accountId?: string } },\n) {\n  const cookieStore = cookies();\n  const supabase = createRouteHandlerClient<Database>({ cookies: () => cookieStore });\n\n  const isAdmin = await checkAdmin(supabase);\n  if (!isAdmin) {\n    return NextResponse.json({ error: 'Forbidden' }, { status: 403 });\n  }\n\n  // Get account ID from URL path (e.g., /api/admin/accounts/[accountId])\n  // This requires the route file to be named `app/api/admin/accounts/[accountId]/route.ts`\n  // OR extract from query/body if not using dynamic route segments.\n  // For simplicity, let's assume it comes in the request body for now, similar to PUT.\n  // Revisit this if using dynamic route segments.\n\n  // Let's expect the account ID in the URL search params like /api/admin/accounts?id=xxx\n  const { searchParams } = new URL(_request.url);\n  const accountId = searchParams.get('id');\n\n  if (!accountId || !z.string().uuid().safeParse(accountId).success) {\n    return NextResponse.json(\n      { error: 'Valid Account ID is required in query parameters' },\n      { status: 400 },\n    );\n  }\n\n  try {\n    const body = await _request.json();\n    const validation = updateAccountSchema.safeParse(body);\n\n    if (!validation.success) {\n      return NextResponse.json(\n        { error: 'Invalid input', details: validation.error.errors },\n        { status: 400 },\n      );\n    }\n\n    const { rule_set_id } = validation.data;\n\n    // If rule_set_id is provided, verify it exists before assigning\n    if (rule_set_id) {\n      const { data: ruleSetExists, error: ruleSetError } = await supabase\n        .from('rule_sets')\n        .select('id')\n        .eq('id', rule_set_id)\n        .maybeSingle();\n\n      if (ruleSetError) throw ruleSetError;\n      if (!ruleSetExists) {\n        return NextResponse.json(\n          { error: 'Specified Rule Set ID does not exist.' },\n          { status: 404 },\n        );\n      }\n    }\n\n    // Update the account\n    const { data, error } = await supabase\n      .from('accounts')\n      .update({ rule_set_id: rule_set_id })\n      .eq('id', accountId)\n      .select('id, rule_set_id') // Select updated fields\n      .single();\n\n    if (error) {\n      if (error.code === 'PGRST116') {\n        // Not found\n        return NextResponse.json({ error: 'Account not found' }, { status: 404 });\n      }\n      throw error;\n    }\n\n    return NextResponse.json(data);\n  } catch (error: any) {\n    console.error('Error updating account rule set:', error);\n    return NextResponse.json(\n      { error: 'Failed to update account rule set', details: error.message },\n      { status: 500 },\n    );\n  }\n}\n\n// PUT: Update account details (e.g., assign rule set, toggle active status)\nexport async function PUT(_request: Request, {} /* _params */ : { params: { id: string } }) {\n  console.log('PUT /api/admin/accounts called'); // Removed ID log as params is unused\n  // const supabaseAdmin = createAdminClient(); // Removed\n  // ... existing code ...\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/michaelfuscoletti/Desktop/dock108home/app/api/admin/retention-status/route.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/michaelfuscoletti/Desktop/dock108home/app/api/admin/rule-sets/route.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":53,"column":19,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":53,"endColumn":22,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1749,1752],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1749,1752],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":102,"column":19,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":102,"endColumn":22,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3136,3139],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3136,3139],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":183,"column":19,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":183,"endColumn":22,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5548,5551],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5548,5551],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":242,"column":19,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":242,"endColumn":22,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7591,7594],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7591,7594],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { NextResponse } from 'next/server';\nimport { cookies } from 'next/headers';\nimport { createRouteHandlerClient } from '@supabase/auth-helpers-nextjs';\nimport { Database, Json } from '@/types/supabase';\nimport { z } from 'zod';\n\n// Zod schema for basic JSON object validation (can be refined)\nconst ruleSetConfigSchema = z\n  .record(z.any())\n  .refine((val) => typeof val === 'object' && val !== null && !Array.isArray(val), {\n    message: 'Rule config must be a valid JSON object.',\n  });\n\n// Zod schema for POST/PUT payload\nconst ruleSetPayloadSchema = z.object({\n  id: z.string().uuid().optional(), // Optional for POST, required for PUT\n  name: z.string().min(1, { message: 'Rule set name cannot be empty.' }),\n  config: ruleSetConfigSchema,\n});\n\n// Helper function to check admin role\nasync function checkAdmin(\n  supabase: ReturnType<typeof createRouteHandlerClient<Database>>,\n): Promise<boolean> {\n  const {\n    data: { user },\n    error: userError,\n  } = await supabase.auth.getUser();\n  if (userError || !user) {\n    return false;\n  }\n  // Adjust based on where the role is stored (e.g., user.app_metadata?.role)\n  return user.app_metadata?.role === 'admin';\n}\n\n// GET: Fetch all rule sets\nexport async function GET(/* request: Request */) {\n  console.log('GET /api/admin/rule-sets called');\n  const cookieStore = cookies();\n  const supabase = createRouteHandlerClient<Database>({ cookies: () => cookieStore });\n\n  const isAdmin = await checkAdmin(supabase);\n  if (!isAdmin) {\n    return NextResponse.json({ error: 'Forbidden' }, { status: 403 });\n  }\n\n  try {\n    const { data, error } = await supabase.from('rule_sets').select('*').order('name');\n\n    if (error) throw error;\n\n    return NextResponse.json(data);\n  } catch (error: any) {\n    console.error('Error fetching rule sets:', error);\n    return NextResponse.json(\n      { error: 'Failed to fetch rule sets', details: error.message },\n      { status: 500 },\n    );\n  }\n}\n\n// POST: Create a new rule set\nexport async function POST(request: Request) {\n  const cookieStore = cookies();\n  const supabase = createRouteHandlerClient<Database>({ cookies: () => cookieStore });\n\n  const isAdmin = await checkAdmin(supabase);\n  if (!isAdmin) {\n    return NextResponse.json({ error: 'Forbidden' }, { status: 403 });\n  }\n\n  try {\n    const body = await request.json();\n    const validation = ruleSetPayloadSchema.safeParse(body);\n\n    if (!validation.success) {\n      return NextResponse.json(\n        { error: 'Invalid input', details: validation.error.errors },\n        { status: 400 },\n      );\n    }\n\n    const { name, config } = validation.data;\n\n    // Prevent creating another rule set named 'default' (case-insensitive check)\n    if (name.toLowerCase() === 'default') {\n      return NextResponse.json(\n        { error: \"Cannot create another rule set named 'default'.\" },\n        { status: 400 },\n      );\n    }\n\n    const { data, error } = await supabase\n      .from('rule_sets')\n      .insert({ name, config: config as Json })\n      .select()\n      .single();\n\n    if (error) throw error;\n\n    return NextResponse.json(data, { status: 201 });\n  } catch (error: any) {\n    console.error('Error creating rule set:', error);\n    if (error.code === '23505') {\n      // Unique constraint violation (e.g., name)\n      return NextResponse.json({ error: 'Rule set name already exists' }, { status: 409 });\n    }\n    return NextResponse.json(\n      { error: 'Failed to create rule set', details: error.message },\n      { status: 500 },\n    );\n  }\n}\n\n// PUT: Update an existing rule set\nexport async function PUT(request: Request) {\n  const cookieStore = cookies();\n  const supabase = createRouteHandlerClient<Database>({ cookies: () => cookieStore });\n\n  const isAdmin = await checkAdmin(supabase);\n  if (!isAdmin) {\n    return NextResponse.json({ error: 'Forbidden' }, { status: 403 });\n  }\n\n  try {\n    const body = await request.json();\n    // Add id validation for PUT\n    const validation = ruleSetPayloadSchema\n      .extend({\n        id: z.string().uuid({ message: 'Valid Rule Set ID is required for update.' }),\n      })\n      .safeParse(body);\n\n    if (!validation.success) {\n      return NextResponse.json(\n        { error: 'Invalid input', details: validation.error.errors },\n        { status: 400 },\n      );\n    }\n\n    const { id, name, config } = validation.data;\n\n    // Prevent renaming the 'default' rule set or renaming another TO 'default'\n    if (id) {\n      const { data: existingRuleSet, error: fetchError } = await supabase\n        .from('rule_sets')\n        .select('name')\n        .eq('id', id)\n        .single();\n\n      if (fetchError || !existingRuleSet) {\n        return NextResponse.json({ error: 'Rule set not found' }, { status: 404 });\n      }\n\n      if (existingRuleSet.name === 'default' && name !== 'default') {\n        return NextResponse.json(\n          { error: \"Cannot rename the 'default' rule set.\" },\n          { status: 400 },\n        );\n      }\n      if (existingRuleSet.name !== 'default' && name.toLowerCase() === 'default') {\n        return NextResponse.json(\n          { error: \"Cannot rename a rule set to 'default'.\" },\n          { status: 400 },\n        );\n      }\n    }\n\n    const { data, error } = await supabase\n      .from('rule_sets')\n      .update({ name, config: config as Json })\n      .eq('id', id)\n      .select()\n      .single();\n\n    if (error) throw error;\n\n    if (!data) {\n      return NextResponse.json({ error: 'Rule set not found' }, { status: 404 });\n    }\n\n    return NextResponse.json(data);\n  } catch (error: any) {\n    console.error('Error updating rule set:', error);\n    if (error.code === '23505') {\n      // Unique constraint violation (e.g., name)\n      return NextResponse.json({ error: 'Rule set name already exists' }, { status: 409 });\n    }\n    return NextResponse.json(\n      { error: 'Failed to update rule set', details: error.message },\n      { status: 500 },\n    );\n  }\n}\n\n// DELETE: Delete a rule set\nexport async function DELETE(request: Request) {\n  const cookieStore = cookies();\n  const supabase = createRouteHandlerClient<Database>({ cookies: () => cookieStore });\n\n  const isAdmin = await checkAdmin(supabase);\n  if (!isAdmin) {\n    return NextResponse.json({ error: 'Forbidden' }, { status: 403 });\n  }\n\n  const { searchParams } = new URL(request.url);\n  const id = searchParams.get('id');\n\n  if (!id || !z.string().uuid().safeParse(id).success) {\n    return NextResponse.json({ error: 'Valid Rule Set ID is required' }, { status: 400 });\n  }\n\n  try {\n    // Check if it's the 'default' rule set before deleting\n    const { data: ruleSet, error: fetchError } = await supabase\n      .from('rule_sets')\n      .select('name')\n      .eq('id', id)\n      .single();\n\n    if (fetchError) {\n      if (fetchError.code === 'PGRST116') {\n        // Not found\n        return NextResponse.json({ error: 'Rule set not found' }, { status: 404 });\n      }\n      throw fetchError; // Other fetch error\n    }\n\n    if (ruleSet?.name === 'default') {\n      return NextResponse.json({ error: \"Cannot delete the 'default' rule set.\" }, { status: 400 });\n    }\n\n    // TODO: Check if the rule set is currently assigned to any accounts before deleting?\n    // This might require querying the `accounts` table (or wherever rule sets are assigned).\n    // If assigned, return a 409 Conflict or similar error.\n\n    const { error: deleteError } = await supabase.from('rule_sets').delete().eq('id', id);\n\n    if (deleteError) throw deleteError;\n\n    return NextResponse.json({ message: 'Rule set deleted successfully' }, { status: 200 });\n  } catch (error: any) {\n    console.error('Error deleting rule set:', error);\n    return NextResponse.json(\n      { error: 'Failed to delete rule set', details: error.message },\n      { status: 500 },\n    );\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/michaelfuscoletti/Desktop/dock108home/app/api/admin/settings/route.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":59,"column":19,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":59,"endColumn":22,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2071,2074],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2071,2074],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":106,"column":19,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":106,"endColumn":22,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3412,3415],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3412,3415],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { NextResponse } from 'next/server';\nimport { cookies } from 'next/headers';\nimport { createRouteHandlerClient } from '@supabase/auth-helpers-nextjs';\nimport { Database } from '@/types/supabase';\nimport { z } from 'zod';\n\n// Zod schema for settings payload validation\nconst settingsSchema = z.object({\n  id: z.string().min(1), // Assuming a primary key like 'global_settings' or a UUID\n  slack_webhook_url: z\n    .string()\n    .url({ message: 'Invalid Slack Webhook URL format.' })\n    .or(z.literal(''))\n    .nullable(),\n  notification_emails: z\n    .array(z.string().email({ message: 'Invalid email format found.' }))\n    .nullable(),\n  slack_notifications_enabled: z.boolean().nullable(),\n  email_notifications_enabled: z.boolean().nullable(),\n  // Add other settings fields here if needed\n});\n\n// Helper function to check admin role (can be shared/imported)\nasync function checkAdmin(\n  supabase: ReturnType<typeof createRouteHandlerClient<Database>>,\n): Promise<boolean> {\n  const {\n    data: { user },\n    error: userError,\n  } = await supabase.auth.getUser();\n  return !userError && !!user && user.app_metadata?.role === 'admin';\n}\n\nconst SETTINGS_ROW_ID = 'global_settings'; // Define a constant for the settings row ID\n\n// GET: Fetch global settings\nexport async function GET(/* request: Request */) {\n  console.log('GET /api/admin/settings called');\n  const cookieStore = cookies();\n  const supabase = createRouteHandlerClient<Database>({ cookies: () => cookieStore });\n\n  const isAdmin = await checkAdmin(supabase);\n  if (!isAdmin) {\n    return NextResponse.json({ error: 'Forbidden' }, { status: 403 });\n  }\n\n  try {\n    // Attempt to fetch the specific settings row\n    const { data, error } = await supabase\n      .from('settings')\n      .select('*')\n      .eq('id', SETTINGS_ROW_ID) // Use the constant ID\n      .maybeSingle(); // Use maybeSingle as it might not exist initially\n\n    if (error) throw error;\n\n    // Return the found settings or an empty object if null (doesn't exist yet)\n    return NextResponse.json(data || {});\n  } catch (error: any) {\n    console.error('Error fetching settings:', error);\n    return NextResponse.json(\n      { error: 'Failed to fetch settings', details: error.message },\n      { status: 500 },\n    );\n  }\n}\n\n// PUT: Update (or create) global settings\nexport async function PUT(request: Request) {\n  const cookieStore = cookies();\n  const supabase = createRouteHandlerClient<Database>({ cookies: () => cookieStore });\n\n  const isAdmin = await checkAdmin(supabase);\n  if (!isAdmin) {\n    return NextResponse.json({ error: 'Forbidden' }, { status: 403 });\n  }\n\n  try {\n    const body = await request.json();\n\n    // Ensure the ID matches the expected global ID\n    if (body.id !== SETTINGS_ROW_ID) {\n      return NextResponse.json(\n        { error: `Invalid settings ID. Expected '${SETTINGS_ROW_ID}'.` },\n        { status: 400 },\n      );\n    }\n\n    const validation = settingsSchema.safeParse(body);\n\n    if (!validation.success) {\n      return NextResponse.json(\n        { error: 'Invalid input', details: validation.error.errors },\n        { status: 400 },\n      );\n    }\n\n    const validatedData = validation.data;\n\n    // Upsert the settings using the constant ID\n    const { data, error } = await supabase.from('settings').upsert(validatedData).select().single();\n\n    if (error) throw error;\n\n    return NextResponse.json(data);\n  } catch (error: any) {\n    console.error('Error saving settings:', error);\n    return NextResponse.json(\n      { error: 'Failed to save settings', details: error.message },\n      { status: 500 },\n    );\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/michaelfuscoletti/Desktop/dock108home/app/api/alerts/[id]/[alertId]/notification-status/route.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/michaelfuscoletti/Desktop/dock108home/app/api/alerts/[id]/[alertId]/retry/route.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/michaelfuscoletti/Desktop/dock108home/app/api/alerts/[id]/route.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/michaelfuscoletti/Desktop/dock108home/app/api/backfill-status/route.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":65,"column":19,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":65,"endColumn":22,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2294,2297],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2294,2297],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { createServerClient } from '@supabase/ssr';\nimport { cookies } from 'next/headers';\nimport { NextRequest, NextResponse } from 'next/server';\nimport { Database } from '@/types/supabase';\nimport { z } from 'zod';\n\n// Input validation schema\nconst schema = z.object({\n  accountId: z.string().startsWith('acct_'),\n});\n\nexport async function GET(request: NextRequest) {\n  const { searchParams } = new URL(request.url);\n  const accountId = searchParams.get('accountId');\n\n  // Validate input\n  const validationResult = schema.safeParse({ accountId });\n  if (!validationResult.success) {\n    return NextResponse.json({ error: 'Invalid account ID format.' }, { status: 400 });\n  }\n\n  const validatedAccountId = validationResult.data.accountId;\n\n  const cookieStore = cookies();\n  const supabase = createServerClient<Database>(\n    process.env.NEXT_PUBLIC_SUPABASE_URL!,\n    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,\n    { cookies: { get: (name) => cookieStore.get(name)?.value } },\n  );\n\n  try {\n    // Get current user\n    const {\n      data: { user },\n      error: userError,\n    } = await supabase.auth.getUser();\n    if (userError || !user) {\n      return NextResponse.json({ error: 'Not authenticated' }, { status: 401 });\n    }\n\n    // Fetch status for the specific account for this user\n    // RLS policy ensures the user can only fetch their own records\n    const { data: statusData, error: statusError } = await supabase\n      .from('account_backfill_status')\n      .select('account_id, status, progress, error_message, updated_at') // Select only needed fields\n      .eq('account_id', validatedAccountId)\n      .maybeSingle(); // Expect 0 or 1 result due to RLS + accountId filter\n\n    if (statusError) {\n      console.error('Error fetching backfill status:', statusError);\n      return NextResponse.json({ error: 'Failed to fetch status' }, { status: 500 });\n    }\n\n    if (!statusData) {\n      // This can happen if the account exists but the status record hasn't been created yet,\n      // or if the accountId doesn't belong to the user (due to RLS)\n      return NextResponse.json(\n        { error: 'Backfill status not found for this account.' },\n        { status: 404 },\n      );\n    }\n\n    // Return the status data\n    return NextResponse.json(statusData);\n  } catch (error: any) {\n    console.error('Unexpected error in /api/backfill-status:', error);\n    return NextResponse.json({ error: 'Internal server error' }, { status: 500 });\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/michaelfuscoletti/Desktop/dock108home/app/api/billing/checkout/route.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":119,"column":19,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":119,"endColumn":22,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4386,4389],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4386,4389],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { NextResponse } from 'next/server';\nimport { cookies } from 'next/headers';\nimport { createRouteHandlerClient } from '@supabase/auth-helpers-nextjs';\nimport { Database } from '@/types/supabase';\nimport Stripe from 'stripe';\n\n// Initialize Stripe client (ensure STRIPE_SECRET_KEY is set)\nconst stripe = new Stripe(process.env.STRIPE_SECRET_KEY || '', {\n  apiVersion: '2024-04-10', // Use the latest API version\n  typescript: true,\n});\n\nconst stripePriceIdPro = process.env.STRIPE_PRICE_PRO;\nconst stripeWebhookSecretBilling = process.env.STRIPE_WEBHOOK_BILLING;\nconst siteUrl = process.env.NEXT_PUBLIC_URL || 'http://localhost:3000';\n\n// Log required env vars on cold start (will log once per instance)\nif (!stripePriceIdPro || !stripeWebhookSecretBilling) {\n  // Only show warning in production, not in development or preview\n  if (process.env.VERCEL_ENV === 'production') {\n    console.warn(`\n      ************************************************************\n      * WARNING: Missing Stripe Billing Environment Variables!   *\n      * Please add the following to your .env.local file:        *\n      * STRIPE_PRICE_PRO=<your_stripe_pro_plan_price_id>         *\n      * STRIPE_WEBHOOK_BILLING=<your_stripe_billing_webhook_secret> *\n      ************************************************************\n      `);\n  }\n}\n\nexport async function POST(/* request: Request */) {\n  console.log('POST /api/billing/checkout called');\n  const cookieStore = cookies();\n  const supabase = createRouteHandlerClient<Database>({ cookies: () => cookieStore });\n\n  try {\n    const {\n      data: { user },\n      error: userError,\n    } = await supabase.auth.getUser();\n\n    if (userError || !user) {\n      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });\n    }\n\n    // Fetch settings to get the Stripe Customer ID if it exists\n    const { data: settings, error: settingsError } = await supabase\n      .from('settings')\n      .select('stripe_customer_id')\n      .eq('id', 'global_settings') // Assuming global settings linked to the authenticated user?\n      // OR: .eq('user_id', user.id) if settings are per-user\n      .single();\n\n    if (settingsError && settingsError.code !== 'PGRST116') {\n      // Ignore 'not found' error\n      throw settingsError;\n    }\n\n    let customerId = settings?.stripe_customer_id;\n\n    // Create a Stripe Customer if one doesn't exist for this user\n    if (!customerId) {\n      const customer = await stripe.customers.create({\n        email: user.email,\n        // Add metadata to link Stripe Customer to your Supabase user/account\n        metadata: {\n          supabaseUserId: user.id,\n          // Add other identifiers if needed\n        },\n      });\n      customerId = customer.id;\n\n      // Update the settings table with the new Stripe Customer ID\n      // Note: This assumes a single 'global_settings' row. Adjust if settings are per-user.\n      const { error: updateError } = await supabase\n        .from('settings')\n        .update({ stripe_customer_id: customerId })\n        .eq('id', 'global_settings');\n      // OR: .eq('user_id', user.id);\n\n      if (updateError) {\n        console.error('Failed to update settings with Stripe Customer ID:', updateError);\n        // Proceed with checkout anyway, but log the error\n      }\n    }\n\n    if (!stripePriceIdPro) {\n      throw new Error('Stripe Price ID for Pro plan is not configured.');\n    }\n\n    // Create a Stripe Checkout session for subscription\n    const session = await stripe.checkout.sessions.create({\n      payment_method_types: ['card'],\n      mode: 'subscription',\n      customer: customerId,\n      line_items: [\n        {\n          price: stripePriceIdPro, // The Price ID for your Pro plan\n          quantity: 1,\n        },\n      ],\n      success_url: `${siteUrl}/billing?success=true`, // Redirect URL on successful payment\n      cancel_url: `${siteUrl}/billing?cancelled=true`, // Redirect URL if the user cancels\n      // Allow promotion codes if desired\n      // allow_promotion_codes: true,\n      // Add metadata if needed\n      // subscription_data: {\n      //   metadata: { supabaseUserId: user.id }\n      // },\n    });\n\n    if (!session.url) {\n      throw new Error('Failed to create Stripe Checkout session URL.');\n    }\n\n    // Return the session URL to redirect the user\n    return NextResponse.json({ sessionId: session.id, url: session.url });\n  } catch (error: any) {\n    console.error('Stripe Checkout Error:', error);\n    return NextResponse.json(\n      { error: 'Failed to create checkout session', details: error.message },\n      { status: 500 },\n    );\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/michaelfuscoletti/Desktop/dock108home/app/api/billing/portal/route.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":79,"column":19,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":79,"endColumn":22,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2797,2800],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2797,2800],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { NextResponse } from 'next/server';\nimport { cookies } from 'next/headers';\nimport { createRouteHandlerClient } from '@supabase/auth-helpers-nextjs';\nimport { Database } from '@/types/supabase';\nimport Stripe from 'stripe';\n\n// Initialize Stripe client\nconst stripe = new Stripe(process.env.STRIPE_SECRET_KEY || '', {\n  apiVersion: '2024-04-10',\n  typescript: true,\n});\n\nconst siteUrl = process.env.NEXT_PUBLIC_URL || 'http://localhost:3000';\n\n// Log required env vars on cold start (duplicate from checkout, but ok)\nif (!process.env.STRIPE_PRICE_PRO || !process.env.STRIPE_WEBHOOK_BILLING) {\n  // Only show warning in production, not in development or preview\n  if (process.env.VERCEL_ENV === 'production') {\n    console.warn(`\n      ************************************************************\n      * WARNING: Missing Stripe Billing Environment Variables!   *\n      * (STRIPE_PRICE_PRO, STRIPE_WEBHOOK_BILLING)               *\n      * See console logs from /api/billing/checkout for details. *\n      ************************************************************\n      `);\n  }\n}\n\nexport async function POST(/* request: Request */) {\n  console.log('POST /api/billing/portal called');\n  const cookieStore = cookies();\n  const supabase = createRouteHandlerClient<Database>({ cookies: () => cookieStore });\n\n  try {\n    const {\n      data: { user },\n      error: userError,\n    } = await supabase.auth.getUser();\n\n    if (userError || !user) {\n      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });\n    }\n\n    // Fetch the Stripe Customer ID from settings\n    const { data: settings, error: settingsError } = await supabase\n      .from('settings')\n      .select('stripe_customer_id')\n      .eq('id', 'global_settings') // Adjust if settings are per-user\n      // .eq('user_id', user.id)\n      .single();\n\n    if (settingsError || !settings?.stripe_customer_id) {\n      console.error(\n        'Billing Portal Error: Stripe Customer ID not found for user:',\n        user.id,\n        settingsError,\n      );\n      // Optionally, redirect to a page explaining the issue or try creating the customer again.\n      return NextResponse.json(\n        { error: 'Stripe customer information not found.' },\n        { status: 404 },\n      );\n    }\n\n    const stripeCustomerId = settings.stripe_customer_id;\n\n    // Create a Stripe Billing Portal session\n    const portalSession = await stripe.billingPortal.sessions.create({\n      customer: stripeCustomerId,\n      return_url: `${siteUrl}/billing`, // URL to return to after managing subscription\n    });\n\n    if (!portalSession.url) {\n      throw new Error('Failed to create Stripe Billing Portal session URL.');\n    }\n\n    // Return the portal session URL\n    return NextResponse.json({ url: portalSession.url });\n  } catch (error: any) {\n    console.error('Stripe Billing Portal Error:', error);\n    return NextResponse.json(\n      { error: 'Failed to create billing portal session', details: error.message },\n      { status: 500 },\n    );\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/michaelfuscoletti/Desktop/dock108home/app/api/contact/route.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/michaelfuscoletti/Desktop/dock108home/app/api/feedback/route.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/michaelfuscoletti/Desktop/dock108home/app/api/guardian-reactor/route.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/michaelfuscoletti/Desktop/dock108home/app/api/guardian/alerts/feedback/route.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":71,"column":19,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":71,"endColumn":22,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2608,2611],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2608,2611],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":136,"column":29,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":136,"endColumn":32,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5199,5202],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5199,5202],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":144,"column":19,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":144,"endColumn":22,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5583,5586],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5583,5586],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":239,"column":19,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":239,"endColumn":22,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[9000,9003],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[9000,9003],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { NextResponse } from 'next/server';\nimport { cookies } from 'next/headers';\nimport { createServerClient } from '@supabase/ssr';\nimport { supabaseAdmin } from '@/lib/supabase-admin'; // Use admin for upsert/read counts\nimport { Database } from '@/types/supabase';\n// import { logger } from '@/lib/logger'; // Assuming logger exists\n\n// --- Metrics Setup (Placeholder - Requires actual prom-client integration) --- //\nimport { register, Counter } from 'prom-client'; // Assuming metrics setup\n\n// Ensure this is only registered once\nlet falsePositiveCounter = register.getSingleMetric(\n  'guardian_alert_false_positive_feedback_total',\n) as Counter | undefined;\nif (!falsePositiveCounter) {\n  falsePositiveCounter = new Counter({\n    name: 'guardian_alert_false_positive_feedback_total',\n    help: 'Total number of alerts marked as false positive, partitioned by rule type.',\n    labelNames: ['rule'],\n  });\n}\n// --- End Metrics Setup --- //\n\n// Explicitly mark route as dynamic to prevent caching issues\nexport const dynamic = 'force-dynamic';\n\n// --- POST Handler (Submit/Update Feedback) --- //\nexport async function POST(req: Request) {\n  const cookieStore = cookies();\n  const supabase = createServerClient(\n    process.env.NEXT_PUBLIC_SUPABASE_URL!,\n    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,\n    {\n      cookies: {\n        get: (name) => cookieStore.get(name)?.value,\n      },\n    },\n  );\n\n  // logger.info('Received POST request to /api/guardian/alerts/feedback');\n  console.log('Received POST request to /api/guardian/alerts/feedback');\n\n  const {\n    data: { session },\n    error: sessionError,\n  } = await supabase.auth.getSession();\n\n  if (!session || sessionError) {\n    // logger.warn('Unauthorized feedback submission attempt', { error: sessionError });\n    console.warn('Unauthorized feedback submission attempt', { error: sessionError });\n    return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });\n  }\n\n  let body: { alertId: string; verdict: 'false_positive' | 'legit'; comment?: string };\n  try {\n    body = await req.json();\n    if (\n      !body.alertId ||\n      typeof body.alertId !== 'string' ||\n      !body.verdict ||\n      (body.verdict !== 'false_positive' && body.verdict !== 'legit')\n    ) {\n      throw new Error('Missing or invalid alertId or verdict');\n    }\n    // logger.info('Parsed feedback request body', { userId: session.user.id, alertId: body.alertId, verdict: body.verdict });\n    console.log('Parsed feedback request body', {\n      userId: session.user.id,\n      alertId: body.alertId,\n      verdict: body.verdict,\n    });\n  } catch (error: any) {\n    // logger.warn('Invalid feedback request body', { error: error.message });\n    console.warn('Invalid feedback request body', { error: error.message });\n    return NextResponse.json(\n      { error: 'Invalid request body', details: error.message },\n      { status: 400 },\n    );\n  }\n\n  try {\n    const feedbackData: Database['public']['Tables']['alert_feedback']['Insert'] = {\n      alert_id: body.alertId,\n      user_id: session.user.id,\n      verdict: body.verdict,\n      comment: body.comment || null,\n      // created_at and updated_at are handled by DB defaults/triggers\n    };\n\n    const { data, error: upsertError } = await supabaseAdmin\n      .from('alert_feedback')\n      .upsert(feedbackData, {\n        onConflict: 'alert_id, user_id', // Specify conflict target\n      })\n      .select('id') // Select something to confirm success\n      .single(); // Expect one row affected\n\n    if (upsertError) {\n      // logger.error('Error upserting alert feedback', { userId: session.user.id, alertId: body.alertId, error: upsertError });\n      console.error('Error upserting alert feedback', {\n        userId: session.user.id,\n        alertId: body.alertId,\n        error: upsertError,\n      });\n      throw upsertError;\n    }\n\n    // logger.info('Successfully recorded alert feedback', { userId: session.user.id, alertId: body.alertId, feedbackId: data?.id });\n    console.log('Successfully recorded alert feedback', {\n      userId: session.user.id,\n      alertId: body.alertId,\n      feedbackId: data?.id,\n    });\n\n    // --- Metrics Increment --- //\n    // Increment counter if it was a false positive\n    if (body.verdict === 'false_positive' && falsePositiveCounter) {\n      try {\n        // Need to fetch the alert rule type\n        const { data: alertData, error: alertFetchError } = await supabaseAdmin\n          .from('alerts')\n          .select('alert_type')\n          .eq('id', body.alertId)\n          .maybeSingle();\n\n        if (alertFetchError || !alertData) {\n          // logger.error('Failed to fetch alert type for metrics', { alertId: body.alertId, error: alertFetchError });\n          console.error('Failed to fetch alert type for metrics', {\n            alertId: body.alertId,\n            error: alertFetchError,\n          });\n        } else {\n          falsePositiveCounter.labels(alertData.alert_type || 'unknown').inc();\n          // logger.info('Incremented false_positive_total metric', { rule: alertData.alert_type });\n          console.log('Incremented false_positive_total metric', { rule: alertData.alert_type });\n        }\n      } catch (metricError: any) {\n        // logger.error('Error incrementing metrics counter', { error: metricError });\n        console.error('Error incrementing metrics counter', { error: metricError.message });\n      }\n    }\n    // --- End Metrics Increment --- //\n\n    return NextResponse.json({ success: true, feedbackId: data?.id }, { status: 200 }); // 200 OK indicates update/creation\n  } catch (error: any) {\n    // logger.error('Internal server error processing feedback', { userId: session.user.id, alertId: body.alertId, error: error.message });\n    console.error('Internal server error processing feedback', {\n      userId: session.user.id,\n      alertId: body.alertId,\n      error: error.message,\n    });\n    return NextResponse.json(\n      { error: 'Failed to record feedback', details: error.message },\n      { status: 500 },\n    );\n  }\n}\n\n// --- GET Handler (Fetch Feedback Counts) --- //\nexport async function GET(req: Request) {\n  const cookieStore = cookies();\n  const supabase = createServerClient(\n    process.env.NEXT_PUBLIC_SUPABASE_URL!,\n    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,\n    {\n      cookies: {\n        get: (name) => cookieStore.get(name)?.value,\n      },\n    },\n  );\n\n  // logger.info('Received GET request to /api/guardian/alerts/feedback');\n  console.log('Received GET request to /api/guardian/alerts/feedback');\n\n  const {\n    data: { session },\n    error: sessionError,\n  } = await supabase.auth.getSession();\n\n  if (!session || sessionError) {\n    // logger.warn('Unauthorized feedback count request', { error: sessionError });\n    console.warn('Unauthorized feedback count request', { error: sessionError });\n    return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });\n  }\n\n  const url = new URL(req.url);\n  const alertId = url.searchParams.get('alertId');\n\n  if (!alertId || typeof alertId !== 'string') {\n    // logger.warn('Missing or invalid alertId query parameter for GET feedback');\n    console.warn('Missing or invalid alertId query parameter for GET feedback');\n    return NextResponse.json({ error: 'Missing or invalid alertId parameter' }, { status: 400 });\n  }\n\n  // logger.info('Fetching feedback counts', { userId: session.user.id, alertId });\n  console.log('Fetching feedback counts', { userId: session.user.id, alertId });\n\n  try {\n    // Use an RPC function for aggregation might be more efficient, but direct query is fine for now.\n    const { data, error: countError } = await supabaseAdmin\n      .from('alert_feedback')\n      .select('verdict, count', { count: 'exact' }) // Select verdict and count\n      .eq('alert_id', alertId)\n      .in('verdict', ['false_positive', 'legit']) // Ensure we only count valid verdicts\n      .filter('user_id', 'not.is', 'null') // Exclude potentially null user_ids if set null on delete\n      .returns<{ verdict: string; count: number }[]>(); // Type the return\n\n    if (countError) {\n      // logger.error('Error fetching feedback counts', { userId: session.user.id, alertId, error: countError });\n      console.error('Error fetching feedback counts', {\n        userId: session.user.id,\n        alertId,\n        error: countError,\n      });\n      throw countError;\n    }\n\n    // Process the counts into the desired format\n    const counts = {\n      false_positive: 0,\n      legit: 0,\n    };\n\n    data?.forEach((row) => {\n      if (row.verdict === 'false_positive') {\n        counts.false_positive = row.count;\n      } else if (row.verdict === 'legit') {\n        counts.legit = row.count;\n      }\n    });\n\n    // logger.info('Successfully fetched feedback counts', { userId: session.user.id, alertId, counts });\n    console.log('Successfully fetched feedback counts', {\n      userId: session.user.id,\n      alertId,\n      counts,\n    });\n\n    return NextResponse.json(counts, { status: 200 });\n  } catch (error: any) {\n    // logger.error('Internal server error fetching feedback counts', { userId: session.user.id, alertId, error: error.message });\n    console.error('Internal server error fetching feedback counts', {\n      userId: session.user.id,\n      alertId,\n      error: error.message,\n    });\n    return NextResponse.json(\n      { error: 'Failed to fetch feedback counts', details: error.message },\n      { status: 500 },\n    );\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/michaelfuscoletti/Desktop/dock108home/app/api/guardian/alerts/mark-read/route.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/michaelfuscoletti/Desktop/dock108home/app/api/metrics/route.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":74,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":74,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2891,2894],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2891,2894],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":86,"column":19,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":86,"endColumn":22,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3252,3255],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3252,3255],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { NextResponse } from 'next/server';\nimport { register, retentionLastRunTimestampSeconds } from '@/lib/metrics/registry';\nimport { Buffer } from 'buffer'; // Node.js Buffer for basic auth decoding\nimport { createServerClient } from '@supabase/ssr';\nimport { cookies } from 'next/headers';\nimport { Database } from '@/types/supabase';\n\nconst JOB_NAME = 'guardian_retention'; // Must match the job name in the heartbeat table\n\n// Helper function for Basic Auth check\nfunction checkAuth(request: Request): boolean {\n  const expectedKey = process.env.PROM_METRICS_KEY;\n  // If no key is set, allow access only in non-production environments\n  if (!expectedKey) {\n    return process.env.NODE_ENV !== 'production';\n  }\n\n  const authHeader = request.headers.get('Authorization');\n  if (!authHeader || !authHeader.startsWith('Basic ')) {\n    return false;\n  }\n\n  try {\n    const base64Credentials = authHeader.substring(6);\n    const credentials = Buffer.from(base64Credentials, 'base64').toString('utf8');\n    // Expecting format like '_:YOUR_PROM_METRICS_KEY' or 'user:YOUR_PROM_METRICS_KEY'\n    const [_user, key] = credentials.split(':');\n    return key === expectedKey;\n  } catch (e) {\n    console.error('Error decoding Basic Auth credentials:', e);\n    return false;\n  }\n}\n\nexport async function GET(request: Request) {\n  // Environment/Auth Check\n  if (process.env.NODE_ENV === 'production' && !checkAuth(request)) {\n    return new NextResponse('Unauthorized', {\n      status: 401,\n      headers: { 'WWW-Authenticate': 'Basic realm=\"Restricted Area\"' },\n    });\n  }\n\n  // --- Update dynamic gauges before serving --- //\n  try {\n    const cookieStore = cookies();\n    // Use service role key for direct DB access if needed, or anon key if RLS allows\n    const supabase = createServerClient<Database>(\n      process.env.NEXT_PUBLIC_SUPABASE_URL!,\n      // Use service role key if RLS prevents anon key reading job_heartbeat\n      process.env.SUPABASE_SERVICE_ROLE_KEY || process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,\n      {\n        cookies: { get: (name: string) => cookieStore.get(name)?.value },\n        auth: { persistSession: false }, // Don't persist session for metrics endpoint\n      },\n    );\n\n    const { data, error } = await supabase\n      .from('job_heartbeat')\n      .select('ran_at')\n      .eq('job_name', JOB_NAME)\n      .maybeSingle();\n\n    if (error) {\n      console.error('[Metrics API] Error fetching retention heartbeat:', error.message);\n      // Don't update gauge if fetch fails, it will keep its last value or be absent\n    } else if (data?.ran_at) {\n      const lastRunTimestamp = new Date(data.ran_at).getTime() / 1000; // Convert to Unix seconds\n      retentionLastRunTimestampSeconds.set(lastRunTimestamp);\n    } else {\n      // Job hasn't run yet, explicitly set to 0 or a known value?\n      retentionLastRunTimestampSeconds.set(0);\n    }\n  } catch (dbError: any) {\n    console.error('[Metrics API] Exception fetching retention heartbeat:', dbError.message);\n  }\n  // --- End dynamic gauge update --- //\n\n  // Return metrics\n  try {\n    const metrics = await register.metrics();\n    return new NextResponse(metrics, {\n      status: 200,\n      headers: { 'Content-Type': register.contentType },\n    });\n  } catch (error: any) {\n    console.error('[Metrics API] Error generating metrics:', error);\n    return new NextResponse(`Error generating metrics: ${error.message}`, {\n      status: 500,\n    });\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/michaelfuscoletti/Desktop/dock108home/app/api/og/route.tsx","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":66,"column":15,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":66,"endColumn":18,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2230,2233],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2230,2233],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { ImageResponse } from '@vercel/og';\nimport { NextRequest } from 'next/server';\n\nexport const runtime = 'edge';\n\nexport async function GET(req: NextRequest) {\n  const { searchParams } = new URL(req.url);\n  const title = searchParams.get('title') || 'DOCK108'; // Default title\n\n  // Optional: Load custom font\n  // const interRegular = fetch(new URL('../../assets/Inter-Regular.ttf', import.meta.url)).then((res) => res.arrayBuffer());\n  // const interBold = fetch(new URL('../../assets/Inter-Bold.ttf', import.meta.url)).then((res) => res.arrayBuffer());\n\n  try {\n    // Fetch font data if using custom fonts\n    // const [regularFontData, boldFontData] = await Promise.all([interRegular, interBold]);\n\n    return new ImageResponse(\n      (\n        <div\n          style={{\n            height: '100%',\n            width: '100%',\n            display: 'flex',\n            flexDirection: 'column',\n            alignItems: 'center',\n            justifyContent: 'center',\n            backgroundColor: '#0f172a', // slate-900\n            color: '#cbd5e1', // slate-300\n            fontFamily: 'sans-serif', // Use default or specify loaded font\n            padding: '60px',\n          }}\n        >\n          {/* Optional: Add Logo */}\n          {/* <img \n                src={`${process.env.NEXT_PUBLIC_SITE_URL}/logo-dark-mode.png`} \n                alt=\"DOCK108 Logo\"\n                width={150} // Adjust size\n                style={{ marginBottom: '30px' }} \n            /> */}\n          <h1\n            style={{\n              fontSize: '60px',\n              fontWeight: 700,\n              textAlign: 'center',\n              lineHeight: 1.2,\n              marginBottom: '20px',\n              color: '#f8fafc', // slate-50\n            }}\n          >\n            {title}\n          </h1>\n          <p style={{ fontSize: '24px', color: '#94a3b8' /* slate-400 */ }}>dock108.ai</p>\n        </div>\n      ),\n      {\n        width: 1200,\n        height: 630,\n        // Optional: Add fonts if loaded\n        // fonts: [\n        //     { name: 'Inter', data: regularFontData, weight: 400, style: 'normal' },\n        //     { name: 'Inter', data: boldFontData, weight: 700, style: 'normal' },\n        // ],\n      },\n    );\n  } catch (e: any) {\n    console.error('Failed to generate OG image:', e.message);\n    // Optional: Fallback to redirecting to the static default image\n    // return Response.redirect(new URL('/images/og-default.png', process.env.NEXT_PUBLIC_SITE_URL).toString(), 302);\n    return new Response(`Failed to generate the image`, { status: 500 });\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/michaelfuscoletti/Desktop/dock108home/app/api/stripe/billing-webhook/route.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":63,"column":17,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":63,"endColumn":20,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2486,2489],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2486,2489],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":121,"column":19,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":121,"endColumn":22,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4892,4895],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4892,4895],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { NextResponse } from 'next/server';\nimport { headers } from 'next/headers';\nimport Stripe from 'stripe';\nimport { createClient } from '@supabase/supabase-js';\nimport { Database } from '@/types/supabase';\n\n// Initialize Stripe client\nconst stripe = new Stripe(process.env.STRIPE_SECRET_KEY || '', {\n  apiVersion: '2024-04-10',\n  typescript: true,\n});\n\nconst webhookSecret = process.env.STRIPE_WEBHOOK_BILLING;\n\n// Initialize Supabase client directly for webhook handling (no user context)\n// Use SERVICE_ROLE_KEY for elevated privileges needed to update any settings row\nconst supabaseAdmin = createClient<Database>(\n  process.env.NEXT_PUBLIC_SUPABASE_URL || '',\n  process.env.SUPABASE_SERVICE_ROLE_KEY || '',\n);\n\n// Helper function to update settings based on Stripe Customer ID\n// Adjust the query based on your settings table structure (global vs per-user)\nasync function updateSettingsByCustomerId(\n  customerId: string,\n  dataToUpdate: Partial<Database['public']['Tables']['settings']['Row']>,\n) {\n  const { data, error } = await supabaseAdmin\n    .from('settings')\n    .update(dataToUpdate)\n    .eq('stripe_customer_id', customerId)\n    // If settings are global and might not have customer ID yet, alternative logic needed\n    // Maybe: .eq('id', 'global_settings') and then update customer_id too?\n    // This assumes customer_id is reliably populated before subscription events.\n    .select('id') // Select something to confirm update occurred\n    .maybeSingle(); // Use maybeSingle in case the customer ID isn't found (shouldn't happen ideally)\n\n  if (error) {\n    console.error(`Webhook Error: Failed to update settings for customer ${customerId}:`, error);\n    throw error; // Re-throw to signal failure\n  }\n  if (!data) {\n    console.warn(`Webhook Warning: No settings found for customer ${customerId} during update.`);\n  }\n  console.log(`Webhook: Successfully updated settings for customer ${customerId}.`);\n}\n\nexport async function POST(request: Request) {\n  if (!webhookSecret) {\n    console.error('Webhook Error: STRIPE_WEBHOOK_BILLING secret is not set.');\n    return NextResponse.json({ error: 'Webhook secret not configured' }, { status: 500 });\n  }\n\n  const signature = headers().get('stripe-signature');\n  let event: Stripe.Event;\n\n  try {\n    const body = await request.text();\n    if (!signature) {\n      throw new Error('Missing stripe-signature header');\n    }\n    event = stripe.webhooks.constructEvent(body, signature, webhookSecret);\n  } catch (err: any) {\n    console.error(`Webhook signature verification failed: ${err.message}`);\n    return NextResponse.json({ error: `Webhook Error: ${err.message}` }, { status: 400 });\n  }\n\n  console.log(`Webhook Received: ${event.type}`);\n\n  try {\n    const subscription = event.data.object as Stripe.Subscription;\n    const customerId = subscription.customer as string;\n\n    switch (event.type) {\n      case 'customer.subscription.created':\n      case 'customer.subscription.updated':\n        // Check subscription status\n        const status = subscription.status;\n        const isPro = status === 'active' || status === 'trialing';\n\n        await updateSettingsByCustomerId(customerId, {\n          tier: isPro ? 'pro' : 'free',\n          stripe_subscription_id: subscription.id,\n          // Reset Slack webhook if plan becomes inactive/non-pro?\n          // slack_webhook_url: isPro ? settings.slack_webhook_url : null, // Requires fetching existing settings first\n        });\n        console.log(\n          `Webhook: Set tier to ${isPro ? 'pro' : 'free'} for customer ${customerId} (Sub ID: ${subscription.id})`,\n        );\n        break;\n\n      case 'customer.subscription.deleted':\n        // Subscription cancelled or ended\n        await updateSettingsByCustomerId(customerId, {\n          tier: 'free',\n          stripe_subscription_id: null,\n          // Consider nulling out Slack URL here too if it shouldn't persist for free users\n          // slack_webhook_url: null,\n        });\n        console.log(`Webhook: Set tier to free for customer ${customerId} (Sub Deleted)`);\n        break;\n\n      // Optional: Handle payment failures specifically if needed\n      // case 'invoice.payment_failed':\n      //     // Check if it's related to a subscription\n      //     if (subscription.id) {\n      //         // Could set tier to free or a specific 'payment_failed' status\n      //         await updateSettingsByCustomerId(customerId, {\n      //             tier: 'free', // Or a custom status\n      //             // Consider keeping subscription ID for reactivation attempts?\n      //         });\n      //         console.log(`Webhook: Payment failed for subscription ${subscription.id}, customer ${customerId}`);\n      //     }\n      //     break;\n\n      default:\n        console.log(`Webhook: Unhandled event type ${event.type}`);\n    }\n\n    return NextResponse.json({ received: true });\n  } catch (error: any) {\n    console.error('Webhook Handler Error:', error);\n    return NextResponse.json(\n      { error: 'Webhook handler failed', details: error.message },\n      { status: 500 },\n    );\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/michaelfuscoletti/Desktop/dock108home/app/api/stripe/mock/route.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/michaelfuscoletti/Desktop/dock108home/app/api/stripe/oauth/callback/route.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":217,"column":19,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":217,"endColumn":22,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[9052,9055],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[9052,9055],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// import { NextRequest, NextResponse } from 'next/server';\nimport { NextResponse } from 'next/server';\n// import { headers } from 'next/headers';\nimport Stripe from 'stripe';\nimport { createClient } from '@/lib/supabase/server';\nimport { createClient as createAdminClient } from '@/lib/supabase/admin';\n// import { createAccountWebhook } from '@/lib/stripe-webhook'; // Removed as we don't create webhooks programmatically per account\n// import { logger } from '@/lib/logger'; // Temporarily commented out\n\n// Explicitly mark this route as dynamic\nexport const dynamic = 'force-dynamic';\n\nexport async function GET(req: Request) {\n  const url = new URL(req.url); // Define url early for use in error redirects\n  console.log('Starting Stripe OAuth callback processing.'); // Replaced logger.info\n  try {\n    // Parse URL params\n    const code = url.searchParams.get('code');\n    const state = url.searchParams.get('state');\n    const cookieStore = cookies();\n    const storedState = (await cookieStore).get('guardian_oauth_state')?.value;\n\n    // Validate state to prevent CSRF attacks\n    if (!code || !state || state !== storedState) {\n      console.warn('OAuth state mismatch or missing code', { code, state, storedState }); // Replaced logger.warn\n      const redirectUrl = new URL('/login', url.origin);\n      redirectUrl.searchParams.set('error', 'oauth_state_mismatch');\n      return NextResponse.redirect(redirectUrl);\n    }\n    console.log('OAuth state validated successfully.'); // Replaced logger.info\n\n    // --- 1️⃣ Read session from cookie (server-side) ---\n    const supabase = createClient(\n      process.env.NEXT_PUBLIC_SUPABASE_URL!,\n      process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,\n      {\n        cookies: {\n          async get(name: string) {\n            return (await cookieStore).get(name)?.value;\n          },\n          // No need for set/remove in read-only scenario\n        },\n      },\n    );\n    console.log('Attempting to fetch Supabase session...'); // Replaced logger.info\n    const {\n      data: { session },\n      error: sessionError,\n    } = await supabase.auth.getSession();\n\n    if (!session || sessionError) {\n      console.warn('No valid session found during OAuth callback', {\n        error: sessionError,\n        hasSession: !!session,\n      }); // Replaced logger.warn\n      const redirectUrl = new URL('/login', url.origin);\n      redirectUrl.searchParams.set('error', 'session_expired');\n      redirectUrl.searchParams.set('redirectTo', '/stripe-guardian/onboard');\n      return NextResponse.redirect(redirectUrl);\n    }\n    console.log('Supabase session fetched successfully.', { userId: session.user.id }); // Replaced logger.info\n\n    // --- 2️⃣ Exchange OAuth code for tokens ---\n    const stripe = new Stripe(process.env.STRIPE_SECRET_KEY!, {\n      apiVersion: '2023-10-16',\n    });\n    console.log('Exchanging OAuth code for Stripe tokens...'); // Replaced logger.info\n    const token = await stripe.oauth.token({\n      grant_type: 'authorization_code',\n      code,\n    });\n    console.log('Exchanged OAuth code for Stripe tokens successfully.', {\n      accountId: token.stripe_user_id,\n      userId: session.user.id,\n    }); // Replaced logger.info\n\n    // --- 2.5️⃣ Retrieve account details to get business name ---\n    let businessName: string | null = null;\n    // Ensure stripe_user_id exists before retrieving\n    if (token.stripe_user_id) {\n      try {\n        console.log('Retrieving Stripe Account details...', { accountId: token.stripe_user_id });\n        const account = await stripe.accounts.retrieve(token.stripe_user_id);\n        businessName = account.business_profile?.name ?? null;\n        console.log('Retrieved Stripe Account details successfully.', {\n          accountId: token.stripe_user_id,\n          businessName,\n        });\n      } catch (retrieveError) {\n        console.error('Error retrieving Stripe account details:', {\n          accountId: token.stripe_user_id,\n          error: retrieveError,\n        });\n        // Decide if this is fatal. For now, let's continue without the business name.\n      }\n    } else {\n      console.warn(\n        'Missing stripe_user_id in OAuth token response, cannot retrieve account details.',\n      );\n    }\n\n    // --- 3️⃣ Upsert connected account row ---\n    const accountData = {\n      user_id: session.user.id,\n      stripe_account_id: token.stripe_user_id,\n      access_token: token.access_token,\n      refresh_token: token.refresh_token,\n      live: token.livemode,\n      business_name: businessName, // Use the existing business_name column\n    };\n    console.log('Attempting to upsert connected_accounts record...', { accountData }); // Replaced logger.info\n    const { error: upsertAccountError } = await createAdminClient\n      .from('connected_accounts')\n      .upsert(accountData);\n\n    if (upsertAccountError) {\n      console.error('Error upserting connected_accounts record.', {\n        error: upsertAccountError,\n        accountData,\n      }); // Replaced logger.error\n      throw upsertAccountError; // Re-throw to be caught by the main catch block\n    }\n    console.log('Upserted connected_accounts record successfully.', {\n      accountId: token.stripe_user_id,\n    }); // Replaced logger.info\n\n    // Seed alert_channels row if missing\n    const channelData = {\n      stripe_account_id: token.stripe_user_id,\n      email_to: session.user.email,\n    };\n    console.log('Attempting to upsert alert_channels record...', { channelData }); // Replaced logger.info\n    const { error: upsertChannelError } = await createAdminClient\n      .from('alert_channels')\n      .upsert(channelData);\n\n    if (upsertChannelError) {\n      console.error('Error upserting alert_channels record.', {\n        error: upsertChannelError,\n        channelData,\n      }); // Replaced logger.error\n      // Decide if this is critical - maybe just log and continue? Or throw?\n      // For now, let's log and continue, as the account connection is the primary goal.\n    } else {\n      console.log('Upserted alert_channels record successfully.', {\n        accountId: token.stripe_user_id,\n      }); // Replaced logger.info\n    }\n\n    // --- Trigger Backfill (G-22) --- //\n    const acctId = token.stripe_user_id;\n    if (acctId) {\n      console.log(`Initiating backfill process for account: ${acctId}`);\n      try {\n        // 1. Create/update the status record\n        const { error: statusUpsertError } = await createAdminClient.from('backfill_status').upsert(\n          {\n            stripe_account_id: acctId,\n            status: 'pending',\n            last_error: null, // Clear previous errors on new attempt\n            completed_at: null, // Clear completion time\n          },\n          {\n            onConflict: 'stripe_account_id',\n          },\n        );\n\n        if (statusUpsertError) {\n          throw new Error(`Failed to create/update backfill_status: ${statusUpsertError.message}`);\n        }\n        console.log(`Set backfill status to pending for ${acctId}`);\n\n        // 2. Trigger the backfill function (fire-and-forget)\n        // Ensure SUPABASE_URL is correctly set in environment for fetch\n        const edgeFunctionUrl = `${process.env.SUPABASE_URL}/functions/v1/guardian-backfill`;\n        console.log(`Calling edge function: ${edgeFunctionUrl}`);\n\n        fetch(edgeFunctionUrl, {\n          method: 'POST',\n          headers: {\n            'Content-Type': 'application/json',\n            // Pass service role key for secure function invocation\n            Authorization: `Bearer ${process.env.SUPABASE_SERVICE_ROLE_KEY}`,\n          },\n          body: JSON.stringify({ stripe_account_id: acctId }),\n        }).catch((fetchError) => {\n          // Log failure to trigger, but don't fail the main OAuth flow\n          console.error(`Failed to trigger guardian-backfill function for ${acctId}:`, fetchError);\n          // Optionally: update status back to error here? Or rely on retry cron?\n        });\n\n        console.log(`Successfully triggered guardian-backfill for ${acctId}`);\n      } catch (backfillTriggerError) {\n        // Log error initiating backfill, but don't fail the OAuth redirect\n        console.error(`Error initiating backfill process for ${acctId}:`, backfillTriggerError);\n      }\n    } else {\n      console.warn('Missing stripe_user_id, cannot trigger backfill.');\n    }\n\n    // --- 4️⃣ Cleanup + redirect ---\n    console.log('OAuth flow complete, preparing redirect.', { accountId: token.stripe_user_id }); // Replaced logger.info\n    const redirectUrl = new URL('/stripe-guardian/alerts', url.origin);\n    redirectUrl.searchParams.set('first', '1');\n    const response = NextResponse.redirect(redirectUrl);\n\n    // Clear the state cookie using the Response object for proper Set-Cookie header\n    response.cookies.set({\n      name: 'guardian_oauth_state',\n      value: '',\n      path: '/',\n      maxAge: -1, // Expire the cookie immediately\n    });\n\n    console.log('Redirecting user to alerts page.', { accountId: token.stripe_user_id }); // Replaced logger.info\n    return response;\n  } catch (error: any) {\n    // Catch any error type\n    // Log the specific error that occurred\n    console.error('Caught error during OAuth callback process.', {\n      // Replaced logger.error\n      error: error,\n      message: error?.message,\n      stack: error?.stack,\n    });\n\n    // Redirect to login page with a generic error\n    const redirectUrl = new URL('/login', url.origin); // Use url defined at the start\n    redirectUrl.searchParams.set('error', 'oauth_failed');\n    redirectUrl.searchParams.set('details', 'Check server logs for specifics.'); // Add hint for debugging\n    return NextResponse.redirect(redirectUrl);\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/michaelfuscoletti/Desktop/dock108home/app/api/stripe/oauth/start/route.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/michaelfuscoletti/Desktop/dock108home/app/api/stripe/webhook/__tests__/route.test.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'Stripe' is defined but never used. Allowed unused vars must match /^_/u.","line":26,"column":18,"nodeType":null,"messageId":"unusedVar","endLine":26,"endColumn":24}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { jest, describe, it, expect, beforeEach, afterEach } from '@jest/globals';\nimport { NextRequest } from 'next/server';\nimport { POST, GET } from '../route';\n// import { Readable } from 'stream'; // Removed\n// import { createRouteHandlerClient } from '@supabase/auth-helpers-nextjs'; // Removed\n// import Stripe from 'stripe'; // Removed unused import\n\n// Mock the stripe instance and supabase\njest.mock('@/lib/stripe', () => {\n  const mockStripe = {\n    webhooks: {\n      constructEvent: jest.fn(),\n    },\n  };\n  return { stripe: mockStripe, Stripe: { errors: { StripeSignatureVerificationError: class {} } } };\n});\n\njest.mock('@/lib/supabase-admin', () => ({\n  supabaseAdmin: {\n    from: jest.fn().mockReturnThis(),\n    insert: jest.fn().mockResolvedValue({ error: null }),\n  },\n}));\n\n// Import mocks after mocking\nimport { stripe, Stripe } from '@/lib/stripe';\nimport { supabaseAdmin } from '@/lib/supabase-admin';\n\n// TODO: Re-enable after fixing test stabilization issues (Response undefined) in #<issue_number>\ndescribe.skip('Stripe webhook handler', () => {\n  const originalEnv = process.env;\n\n  beforeEach(() => {\n    jest.spyOn(console, 'error').mockImplementation(() => {});\n    jest.resetModules();\n    process.env = { ...originalEnv };\n    process.env.STRIPE_SECRET_KEY = 'test_key';\n    process.env.STRIPE_WEBHOOK_SECRET = 'whsec_test_secret';\n\n    // Reset mock state\n    jest.clearAllMocks();\n  });\n\n  afterEach(() => {\n    (console.error as jest.Mock).mockRestore();\n    process.env = originalEnv;\n  });\n\n  it('returns 405 for GET method', async () => {\n    // const req = new NextRequest('https://example.com/api/stripe/webhook', { // Removed\n    //   method: 'GET',\n    // });\n\n    const response = await GET();\n    expect(response.status).toBe(405);\n    const body = await response.json();\n    expect(body.error).toBe('Method Not Allowed');\n  });\n\n  it('returns 400 for missing signature', async () => {\n    const req = new NextRequest('https://example.com/api/stripe/webhook', {\n      method: 'POST',\n      body: JSON.stringify({ id: 'evt_test' }),\n    });\n\n    const response = await POST(req);\n    expect(response.status).toBe(400);\n    const body = await response.json();\n    expect(body.error).toBe('Signature verification failed');\n  });\n\n  it('returns 400 for invalid signature', async () => {\n    const mockBody = JSON.stringify({ id: 'evt_test' });\n    const req = new NextRequest('https://example.com/api/stripe/webhook', {\n      method: 'POST',\n      body: mockBody,\n      headers: {\n        'stripe-signature': 'invalid_signature',\n      },\n    });\n\n    // Mock the signature verification to fail\n    (stripe.webhooks.constructEvent as any).mockImplementation(() => {\n      throw new Error('Invalid signature');\n    });\n\n    const response = await POST(req);\n    expect(response.status).toBe(400);\n    const body = await response.json();\n    expect(body.error).toBe('Signature verification failed');\n  });\n\n  it('returns 200 for valid signature', async () => {\n    const mockEvent = {\n      id: 'evt_test',\n      type: 'payout.paid',\n      created: Math.floor(Date.now() / 1000),\n      data: {\n        object: {\n          id: 'po_test',\n          amount: 1000,\n        },\n      },\n    };\n\n    const mockBody = JSON.stringify(mockEvent);\n    const req = new NextRequest('https://example.com/api/stripe/webhook', {\n      method: 'POST',\n      body: mockBody,\n      headers: {\n        'stripe-signature': 'valid_signature',\n      },\n    });\n\n    // Mock the signature verification to succeed\n    (stripe.webhooks.constructEvent as any).mockReturnValue(mockEvent);\n\n    // Mock the Supabase insert success\n    (supabaseAdmin.from('payout_events').insert as any).mockResolvedValue({ error: null });\n\n    const response = await POST(req);\n    expect(response.status).toBe(200);\n    const body = await response.json();\n    expect(body.received).toBe(true);\n\n    // Verify that constructEvent was called with the right arguments\n    expect(stripe.webhooks.constructEvent).toHaveBeenCalledWith(\n      mockBody,\n      'valid_signature',\n      process.env.STRIPE_WEBHOOK_SECRET,\n    );\n\n    // Verify that database insert was called\n    expect(supabaseAdmin.from).toHaveBeenCalledWith('payout_events');\n    expect(supabaseAdmin.from('payout_events').insert).toHaveBeenCalled();\n  });\n\n  it('returns 500 if database insert fails', async () => {\n    const mockEvent = {\n      id: 'evt_test',\n      type: 'payout.paid',\n      created: Math.floor(Date.now() / 1000),\n      data: {\n        object: {\n          id: 'po_test',\n          amount: 1000,\n        },\n      },\n    };\n\n    const mockBody = JSON.stringify(mockEvent);\n    const req = new NextRequest('https://example.com/api/stripe/webhook', {\n      method: 'POST',\n      body: mockBody,\n      headers: {\n        'stripe-signature': 'valid_signature',\n      },\n    });\n\n    // Mock the signature verification to succeed\n    (stripe.webhooks.constructEvent as any).mockReturnValue(mockEvent);\n\n    // Mock the Supabase insert to fail\n    (supabaseAdmin.from('payout_events').insert as any).mockResolvedValue({\n      error: new Error('Database error'),\n    });\n\n    const response = await POST(req);\n    expect(response.status).toBe(500);\n    const body = await response.json();\n    expect(body.error).toBe('Database error');\n  });\n});\n","usedDeprecatedRules":[]},{"filePath":"/Users/michaelfuscoletti/Desktop/dock108home/app/api/stripe/webhook/route.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":38,"column":37,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":38,"endColumn":40,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1730,1733],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1730,1733],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":53,"column":17,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":53,"endColumn":20,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2308,2311],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2308,2311],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":85,"column":19,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":85,"endColumn":22,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3443,3446],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3443,3446],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":151,"column":30,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":151,"endColumn":33,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6307,6310],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6307,6310],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":211,"column":24,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":211,"endColumn":27,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[8865,8868],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[8865,8868],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":229,"column":17,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":229,"endColumn":20,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[9558,9561],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[9558,9561],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":6,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { NextRequest, NextResponse } from 'next/server';\nimport { stripe } from '@/lib/stripe'; // Assuming stripe instance is correctly initialized\nimport Stripe from 'stripe'; // Import Stripe for types\nimport { supabaseAdmin } from '@/lib/supabase-admin';\nimport { log, generateRequestId } from '@/lib/logger';\nimport { isGuardianSupportedEvent } from '@/lib/guardian/stripeEvents';\nimport { validateStripeEvent, isStrictValidationEnabled } from '@/lib/guardian/validateStripeEvent';\nimport { ZodError } from 'zod';\n// import { createClient } from '@/lib/supabase/admin'; // Removed unused\n// import { headers } from 'next/headers'; // Removed unused\n// import { processWebhookEvent } from '@/lib/guardian/webhookHandler'; // Removed unused\n// import { buffer } from 'node:stream/consumers'; // Removed unused\n\nexport const runtime = 'edge';\nexport const maxDuration = 5; // 5 seconds maximum for the webhook handler\n\n// Print environment variable hint on startup using the logger\nif (isStrictValidationEnabled()) {\n  log.info('Stripe event validation is ENABLED (default)');\n  log.info('Add to .env if you need to disable validation locally: STRICT_STRIPE_VALIDATION=false');\n} else {\n  log.warn('Stripe event validation is DISABLED - This should only be used for development');\n}\n\n/**\n * Handles Stripe webhook events\n * - Verifies signature\n * - Identifies source account\n * - Checks if event type is supported\n * - Validates event shape against schema\n * - Stores raw event payload in event_buffer\n * - Forwards to guardian-reactor\n * - Returns 200 OK quickly\n */\nexport async function POST(req: NextRequest) {\n  const startTime = performance.now();\n  const reqId = generateRequestId();\n  const baseLogData: Record<string, any> = { req_id: reqId, service: 'webhook-handler' }; // Base data for logs\n\n  log.info({ ...baseLogData, method: req.method, url: req.url }, 'Incoming webhook request');\n\n  if (req.method !== 'POST') {\n    log.warn({ ...baseLogData, status: 405 }, 'Method not allowed');\n    return NextResponse.json({ error: 'Method Not Allowed' }, { status: 405 });\n  }\n\n  const sig = req.headers.get('stripe-signature');\n  const accountIdHeader = req.headers.get('stripe-account'); // Stripe Connect account ID\n  let rawBody: string;\n\n  try {\n    rawBody = await req.text();\n  } catch (err: any) {\n    log.error({ ...baseLogData, err: err?.message, status: 400 }, 'Failed to read request body');\n    return NextResponse.json({ error: 'Invalid body' }, { status: 400 });\n  }\n\n  let event: Stripe.Event | null = null; // Use Stripe.Event type\n  let verifiedAccountId: string | null = null;\n  let status = 500; // Default to internal error\n  let eventId: string | undefined;\n  let eventType: string | undefined;\n\n  try {\n    if (!sig) {\n      log.error({ ...baseLogData, status: 400 }, 'Missing Stripe signature header');\n      status = 400;\n      return NextResponse.json({ error: 'Missing signature header' }, { status: 400 });\n    }\n\n    const webhookSecret = process.env.STRIPE_WEBHOOK_SECRET;\n    if (!webhookSecret) {\n      log.error(\n        { ...baseLogData, status: 500 },\n        'Missing STRIPE_WEBHOOK_SECRET environment variable',\n      );\n      throw new Error('Webhook secret not configured');\n    }\n\n    try {\n      // Use the specific Stripe type\n      event = stripe.webhooks.constructEvent(rawBody, sig, webhookSecret) as Stripe.Event;\n      eventId = event.id;\n      eventType = event.type;\n    } catch (err: any) {\n      log.error(\n        { ...baseLogData, err: err?.message, status: 400 },\n        'Webhook signature verification failed',\n      );\n      status = 400;\n      return NextResponse.json({ error: 'Signature verification failed' }, { status: 400 });\n    }\n\n    const eventLogData = { ...baseLogData, stripe_event_id: eventId, event_type: eventType };\n\n    if (!eventType || !isGuardianSupportedEvent(eventType)) {\n      log.warn({ ...eventLogData, status: 200 }, 'Unsupported event type received, skipping.'); // Return 200 OK to Stripe\n      status = 200;\n      return NextResponse.json({ message: 'Unsupported event type' }, { status: 200 });\n    }\n\n    // Optional: Strict validation\n    if (isStrictValidationEnabled()) {\n      try {\n        validateStripeEvent(event); // Pass the strongly-typed event\n      } catch (err) {\n        status = 400;\n        if (err instanceof ZodError) {\n          log.error(\n            { ...eventLogData, zodErrors: err.errors, status: 400 },\n            'Event validation failed',\n          );\n          // Return 200 to Stripe, but log error. Don't buffer invalid events.\n          return NextResponse.json({ message: 'Event validation failed' }, { status: 200 });\n        }\n        // Check for specific error message if validateStripeEvent throws it\n        if (err instanceof Error && err.message.includes('Unsupported event type')) {\n          log.warn(\n            { ...eventLogData, status: 200 },\n            'Unsupported event type received (validation), skipping.',\n          );\n          return NextResponse.json({ message: 'Unsupported event type' }, { status: 200 });\n        }\n        // For unknown validation errors, log and potentially let it bubble up (or return 500)\n        log.error({ ...eventLogData, err, status: 500 }, 'Unknown validation error');\n        throw err; // Re-throw unknown errors for outer catch\n      }\n    }\n\n    // Determine the responsible account ID\n    verifiedAccountId = accountIdHeader ?? event.account ?? null;\n\n    if (!verifiedAccountId) {\n      log.error({ ...eventLogData, status: 400 }, 'Missing account ID in header or event');\n      // Return 200 to Stripe, cannot process without account ID.\n      return NextResponse.json({ message: 'Missing account ID' }, { status: 200 });\n    }\n\n    const finalLogData = { ...eventLogData, stripe_account_id: verifiedAccountId };\n    log.info(\n      { ...finalLogData, validation_enabled: isStrictValidationEnabled() },\n      'Webhook signature and payload verified',\n    );\n\n    // Store the raw event in the buffer\n    // Use generated types for insert payload\n    const bufferData: TablesInsert<'event_buffer'> = {\n      stripe_event_id: eventId, // eventId is string | undefined, checked above\n      stripe_account_id: verifiedAccountId, // checked above\n      type: eventType, // checked above\n      payload: event.data as any, // Store original data part - needs careful typing or use Json\n      received_at: new Date().toISOString(),\n    };\n\n    const { data: insertedEvent, error: insertError } = await supabaseAdmin\n      .from('event_buffer')\n      .upsert(bufferData, { onConflict: 'stripe_event_id' })\n      .select('id') // Select the primary key (assuming it's 'id' and type number/bigint)\n      .single<{ id: number }>(); // Specify return type\n\n    if (insertError) {\n      log.error(\n        { ...finalLogData, db_error: insertError.message },\n        'Failed to insert event into buffer',\n      );\n      // Acknowledge receipt to Stripe, but log the error internally\n      status = 200; // Treat as success for Stripe\n    } else if (insertedEvent?.id) {\n      const eventBufferId = insertedEvent.id;\n      log.info({ ...finalLogData, event_buffer_id: eventBufferId }, 'Event stored in buffer');\n\n      // Async dispatch to reactor - Don't await, respond to Stripe quickly\n      // Ensure Supabase URL and Service Role Key are defined\n      const supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL;\n      const serviceRoleKey = process.env.SUPABASE_SERVICE_ROLE_KEY;\n      if (supabaseUrl && serviceRoleKey) {\n        fetch(`${supabaseUrl}/functions/v1/guardian-reactor`, {\n          method: 'POST',\n          headers: {\n            'Content-Type': 'application/json',\n            Authorization: `Bearer ${serviceRoleKey}`,\n            // apikey: process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!, // Anon key likely not needed for service role calls\n          },\n          body: JSON.stringify({ event_buffer_id: eventBufferId }),\n        })\n          .then(async (response) => {\n            if (!response.ok && response.status !== 204) {\n              // Allow 204 (already processed)\n              const responseText = await response.text();\n              log.error(\n                {\n                  ...finalLogData,\n                  event_buffer_id: eventBufferId,\n                  reactor_status: response.status,\n                  reactor_response: responseText,\n                },\n                'Guardian reactor async dispatch failed',\n              );\n              // DLQ insertion happens within the reactor now\n            } else {\n              log.info(\n                {\n                  ...finalLogData,\n                  event_buffer_id: eventBufferId,\n                  reactor_status: response.status,\n                },\n                'Guardian reactor async dispatch initiated',\n              );\n            }\n          })\n          .catch((err: any) => {\n            log.error(\n              { ...finalLogData, event_buffer_id: eventBufferId, err: err?.message },\n              'Guardian reactor async dispatch exception',\n            );\n            // DLQ insertion happens within the reactor now\n          });\n      } else {\n        log.error(\n          { ...finalLogData, event_buffer_id: eventBufferId },\n          'Cannot trigger reactor: Missing Supabase URL or Service Role Key',\n        );\n      }\n      status = 200; // Success from webhook perspective\n    } else {\n      log.error({ ...finalLogData }, 'Failed to get inserted event buffer ID after upsert');\n      status = 200; // Still success for Stripe\n    }\n  } catch (err: any) {\n    status = status >= 400 ? status : 500; // Keep 4xx if already set, otherwise 500\n    log.error(\n      {\n        ...baseLogData,\n        stripe_event_id: eventId,\n        stripe_account_id: verifiedAccountId,\n        err: err?.message,\n        stack: err?.stack, // Log stack for internal errors\n        status,\n      },\n      'Unhandled webhook processing error',\n    );\n    // Return generic 500 for internal errors\n    const errorResponse = { error: 'Internal Server Error' };\n    return NextResponse.json(errorResponse, { status: 500 });\n  }\n\n  // Calculate total processing time\n  const durationMs = Math.round(performance.now() - startTime);\n  log.info(\n    {\n      ...baseLogData,\n      stripe_event_id: eventId,\n      stripe_account_id: verifiedAccountId,\n      duration_ms: durationMs,\n      status,\n    },\n    'Webhook processing complete',\n  );\n\n  // Return 200 OK quickly to Stripe\n  return NextResponse.json({ received: true }, { status });\n}\n\n// Note: Removed GET handler for /api/metrics as it needs separate implementation\n","usedDeprecatedRules":[]},{"filePath":"/Users/michaelfuscoletti/Desktop/dock108home/app/api/waitlist/route.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/michaelfuscoletti/Desktop/dock108home/app/billing/page.tsx","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":70,"column":23,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":70,"endColumn":26,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2663,2666],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2663,2666],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":99,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":99,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3659,3662],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3659,3662],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":117,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":117,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4351,4354],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4351,4354],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"'use client'; // Needs client-side interaction for button clicks\n\nimport { useState, useEffect } from 'react';\nimport { useRouter } from 'next/navigation'; // Use App Router's navigation\nimport { Container } from '@/components/Container';\nimport { Button } from '@/components/ui/button';\nimport {\n  Card,\n  CardContent,\n  CardDescription,\n  CardHeader,\n  CardTitle,\n  CardFooter,\n} from '@/components/ui/card';\nimport { toast } from 'react-hot-toast';\nimport { Loader2, ExternalLink, CheckCircle } from 'lucide-react';\nimport { useUser } from '@/lib/hooks/useUser'; // Assuming a hook to get user state\nimport { createClientComponentClient } from '@supabase/auth-helpers-nextjs';\nimport { Database } from '@/types/supabase';\nimport { isPro } from '@/lib/guardian/plan'; // Import the plan helper\n// import { getSubscription } from '@/lib/supabase/user'; // Removed\n// import ManageSubscriptionButton from './ManageSubscriptionButton'; // Commented out\n\n// Define settings type again or import\ninterface SettingsRow {\n  id: string;\n  tier?: string | null;\n  stripe_customer_id?: string | null;\n  // Add other fields if needed to display usage/caps\n}\n\nexport default function BillingPage() {\n  const router = useRouter();\n  const { user, isLoading: isLoadingUser } = useUser();\n  const [settings, setSettings] = useState<SettingsRow | null>(null);\n  const [isLoadingSettings, setIsLoadingSettings] = useState(true);\n  const [isRedirectingCheckout, setIsRedirectingCheckout] = useState(false);\n  const [isRedirectingPortal, setIsRedirectingPortal] = useState(false);\n  const supabase = createClientComponentClient<Database>();\n\n  useEffect(() => {\n    // Display toast messages based on query params from Stripe redirects\n    const searchParams = new URLSearchParams(window.location.search);\n    if (searchParams.get('success')) {\n      toast.success('Subscription successful! Welcome to Pro.');\n      // Clear query params after showing toast\n      router.replace('/billing', { scroll: false });\n    }\n    if (searchParams.get('cancelled')) {\n      toast.error('Checkout cancelled.');\n      router.replace('/billing', { scroll: false });\n    }\n  }, [router]);\n\n  useEffect(() => {\n    async function fetchSettings() {\n      if (!user) return; // Only fetch if user is loaded\n\n      setIsLoadingSettings(true);\n      try {\n        // Fetch settings - Adjust query if settings are not global\n        const { data, error } = await supabase\n          .from('settings')\n          .select('*')\n          .eq('id', 'global_settings') // Or .eq('user_id', user.id)\n          .maybeSingle();\n\n        if (error) throw error;\n        setSettings(data);\n      } catch (error: any) {\n        console.error('Error fetching settings:', error);\n        toast.error('Failed to load billing information.');\n      } finally {\n        setIsLoadingSettings(false);\n      }\n    }\n\n    if (!isLoadingUser && user) {\n      fetchSettings();\n    }\n    if (!isLoadingUser && !user) {\n      // Handle case where user is definitely not logged in\n      setIsLoadingSettings(false);\n      // Optionally redirect to login\n      // router.push('/login?redirectTo=/billing');\n    }\n  }, [user, isLoadingUser, supabase, router]);\n\n  const handleUpgrade = async () => {\n    setIsRedirectingCheckout(true);\n    toast.loading('Redirecting to checkout...');\n    try {\n      const response = await fetch('/api/billing/checkout', { method: 'POST' });\n      const data = await response.json();\n      if (!response.ok || !data.url) {\n        throw new Error(data.error || 'Failed to initiate checkout.');\n      }\n      window.location.href = data.url; // Redirect to Stripe Checkout\n    } catch (error: any) {\n      toast.dismiss();\n      toast.error(`Checkout failed: ${error.message}`);\n      setIsRedirectingCheckout(false);\n    }\n    // No finally block needed as successful redirect leaves the page\n  };\n\n  const handleManageSubscription = async () => {\n    setIsRedirectingPortal(true);\n    toast.loading('Redirecting to billing portal...');\n    try {\n      const response = await fetch('/api/billing/portal', { method: 'POST' });\n      const data = await response.json();\n      if (!response.ok || !data.url) {\n        throw new Error(data.error || 'Failed to open billing portal.');\n      }\n      window.location.href = data.url; // Redirect to Stripe Billing Portal\n    } catch (error: any) {\n      toast.dismiss();\n      toast.error(`Failed to open portal: ${error.message}`);\n      setIsRedirectingPortal(false);\n    }\n  };\n\n  const isLoading = isLoadingUser || isLoadingSettings;\n  const userIsPro = settings ? isPro(settings) : false;\n\n  return (\n    <Container className=\"py-10 max-w-3xl mx-auto\">\n      <h1 className=\"text-3xl font-bold tracking-tight mb-6\">Billing & Plan</h1>\n\n      {isLoading ? (\n        <div className=\"flex justify-center items-center h-40\">\n          <Loader2 className=\"h-8 w-8 animate-spin text-slate-500\" />\n        </div>\n      ) : !user ? (\n        <Card>\n          <CardHeader>\n            <CardTitle>Authentication Required</CardTitle>\n          </CardHeader>\n          <CardContent>\n            <p>Please log in to manage your billing information.</p>\n          </CardContent>\n          <CardFooter>\n            <Button onClick={() => router.push('/login?redirectTo=/billing')}>Log In</Button>\n          </CardFooter>\n        </Card>\n      ) : (\n        <Card>\n          <CardHeader>\n            <CardTitle>Your Current Plan</CardTitle>\n            <CardDescription>\n              You are currently on the{' '}\n              <span className={`font-semibold ${userIsPro ? 'text-green-600' : 'text-blue-600'}`}>\n                {userIsPro ? 'Pro' : 'Free'}\n              </span>{' '}\n              plan.\n            </CardDescription>\n          </CardHeader>\n          <CardContent className=\"space-y-4\">\n            {userIsPro ? (\n              <div>\n                <p className=\"text-sm text-slate-600 mb-4\">\n                  You have full access to all Guardian features. Manage your subscription, view\n                  invoices, or update payment methods via the Stripe Billing Portal.\n                </p>\n                <Button onClick={handleManageSubscription} disabled={isRedirectingPortal}>\n                  {isRedirectingPortal ? (\n                    <Loader2 className=\"mr-2 h-4 w-4 animate-spin\" />\n                  ) : (\n                    <ExternalLink className=\"mr-2 h-4 w-4\" />\n                  )}\n                  Manage Subscription\n                </Button>\n              </div>\n            ) : (\n              <div>\n                <p className=\"text-sm text-slate-600 mb-1\">The Free plan includes:</p>\n                <ul className=\"list-disc list-inside text-sm text-slate-600 mb-4\">\n                  <li>Up to 50 alerts per month</li>\n                  <li>Core fraud detection rules</li>\n                  <li>Email notifications</li>\n                </ul>\n                <p className=\"text-sm text-slate-600 mb-4\">\n                  Upgrade to Pro for unlimited alerts, Slack notifications, advanced rules, and\n                  priority support.\n                </p>\n                <Button\n                  onClick={handleUpgrade}\n                  disabled={isRedirectingCheckout}\n                  className=\"bg-blue-600 hover:bg-blue-700 text-white\"\n                >\n                  {isRedirectingCheckout ? (\n                    <Loader2 className=\"mr-2 h-4 w-4 animate-spin\" />\n                  ) : (\n                    <CheckCircle className=\"mr-2 h-4 w-4\" />\n                  )}\n                  Upgrade to Pro\n                </Button>\n              </div>\n            )}\n          </CardContent>\n        </Card>\n      )}\n    </Container>\n  );\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/michaelfuscoletti/Desktop/dock108home/app/blog/[slug]/opengraph-image.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/michaelfuscoletti/Desktop/dock108home/app/blog/[slug]/page.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/michaelfuscoletti/Desktop/dock108home/app/blog/layout.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/michaelfuscoletti/Desktop/dock108home/app/blog/page.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/michaelfuscoletti/Desktop/dock108home/app/components/MetricCard.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/michaelfuscoletti/Desktop/dock108home/app/components/StripeAccountSelect.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/michaelfuscoletti/Desktop/dock108home/app/components/UpgradeBanner.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/michaelfuscoletti/Desktop/dock108home/app/contact/ContactForm.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/michaelfuscoletti/Desktop/dock108home/app/contact/page.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/michaelfuscoletti/Desktop/dock108home/app/context/useAlertNotifications.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/michaelfuscoletti/Desktop/dock108home/app/crondeck/layout.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/michaelfuscoletti/Desktop/dock108home/app/crondeck/metadata.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/michaelfuscoletti/Desktop/dock108home/app/crondeck/opengraph-image.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/michaelfuscoletti/Desktop/dock108home/app/crondeck/page.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/michaelfuscoletti/Desktop/dock108home/app/docs/[...slug]/page.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/michaelfuscoletti/Desktop/dock108home/app/docs/layout.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/michaelfuscoletti/Desktop/dock108home/app/docs/page.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/michaelfuscoletti/Desktop/dock108home/app/guardian-demo/DemoViewer.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/michaelfuscoletti/Desktop/dock108home/app/guardian-demo/__tests__/scenarios.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/michaelfuscoletti/Desktop/dock108home/app/guardian-demo/__tests__/useDemoScenario.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/michaelfuscoletti/Desktop/dock108home/app/guardian-demo/__tests__/useDemoScenario.timers.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/michaelfuscoletti/Desktop/dock108home/app/guardian-demo/getScenarios.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/michaelfuscoletti/Desktop/dock108home/app/guardian-demo/layout.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/michaelfuscoletti/Desktop/dock108home/app/guardian-demo/page.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/michaelfuscoletti/Desktop/dock108home/app/guardian-demo/types.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":15,"column":20,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":15,"endColumn":23,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[345,348],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[345,348],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Represents a single event in a fraud scenario\n */\nexport type ScenarioEvent = {\n  /** Milliseconds to wait after the previous event before firing this one */\n  delayMs: number;\n  \n  /** Stripe event type */\n  type: string;\n  \n  /** Event payload data (Stripe object) */\n  payload: {\n    id: string;\n    object: string;\n    [key: string]: any;\n  };\n};\n\n/**\n * A complete fraud scenario consisting of a sequence of events\n */\nexport type Scenario = ScenarioEvent[]; ","usedDeprecatedRules":[]},{"filePath":"/Users/michaelfuscoletti/Desktop/dock108home/app/guardian-demo/useDemoScenario.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":9,"column":27,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":9,"endColumn":30,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[251,254],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[251,254],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"'use client';\n\nimport { useEffect, useRef, useState, useCallback } from 'react';\nimport { DemoEvent } from './useFakeStripeEvents';\n\nexport type ScenarioEvent = {\n  delayMs: number;\n  type: 'account.updated' | 'payout.paid';\n  payload: Record<string, any>;\n};\n\nexport type ScenarioOptions = {\n  onExpire?: () => void;\n  speed?: number;\n};\n\nexport function useDemoScenario(scenarioName: string | null, options: ScenarioOptions = {}) {\n  const { onExpire, speed = 1 } = options;\n  const [events, setEvents] = useState<DemoEvent[]>([]);\n  const [scenarioEvents, setScenarioEvents] = useState<ScenarioEvent[]>([]);\n  const [currentIndex, setCurrentIndex] = useState<number>(0);\n  const [isLoading, setIsLoading] = useState<boolean>(false);\n  const [error, setError] = useState<string | null>(null);\n  const [isRunning, setIsRunning] = useState<boolean>(false);\n  const [totalDelayMs, setTotalDelayMs] = useState<number>(0);\n\n  const timersRef = useRef<NodeJS.Timeout[]>([]);\n  const startRef = useRef<number>(Date.now());\n  const fetchControllerRef = useRef<AbortController | null>(null);\n  const pendingEventsRef = useRef<\n    Array<{ event: ScenarioEvent; index: number; scheduledAt: number }>\n  >([]);\n\n  // Clear all timers on unmount or reset\n  const clearAllTimers = useCallback(() => {\n    if (timersRef.current.length > 0) {\n      timersRef.current.forEach(clearTimeout);\n      timersRef.current = [];\n    }\n    pendingEventsRef.current = [];\n    setIsRunning(false);\n  }, []);\n\n  const reset = useCallback(() => {\n    clearAllTimers();\n    setEvents([]);\n    setCurrentIndex(0);\n    startRef.current = Date.now();\n  }, [clearAllTimers]);\n\n  const restart = (newScenarioName?: string) => {\n    reset();\n    if (newScenarioName) {\n      loadScenario(newScenarioName);\n    } else if (scenarioName) {\n      scheduleEvents();\n    }\n  };\n\n  // Load scenario data\n  const loadScenario = useCallback(\n    async (name: string) => {\n      if (!name) return;\n\n      // Cancel any pending fetch\n      if (fetchControllerRef.current) {\n        fetchControllerRef.current.abort();\n      }\n\n      // Create new controller for this fetch\n      fetchControllerRef.current = new AbortController();\n      const signal = fetchControllerRef.current.signal;\n\n      setIsLoading(true);\n      setError(null);\n\n      try {\n        const response = await fetch(`/guardian-demo/scenarios/${name}.json`, { signal });\n        if (!response.ok) {\n          throw new Error(`Failed to load scenario: ${response.statusText}`);\n        }\n\n        const data: ScenarioEvent[] = await response.json();\n        setScenarioEvents(data);\n\n        // Calculate total delay time from all events\n        const total = data.reduce((sum, event) => sum + event.delayMs, 0);\n        setTotalDelayMs(total);\n\n        setIsLoading(false);\n        setCurrentIndex(0);\n\n        // Clear any existing events and timers before scheduling new ones\n        reset();\n      } catch (err) {\n        // Don't set error if aborted\n        if (err instanceof Error && err.name === 'AbortError') {\n          return;\n        }\n        setError(err instanceof Error ? err.message : 'Failed to load scenario');\n        setIsLoading(false);\n      }\n    },\n    [reset],\n  );\n\n  // Schedule the events based on the scenario\n  const scheduleEvents = useCallback(() => {\n    clearAllTimers();\n    const now = Date.now();\n    startRef.current = now;\n    setIsRunning(true);\n\n    // Track pending events with information about when they were scheduled\n    pendingEventsRef.current = scenarioEvents.map((event, index) => ({\n      event,\n      index,\n      scheduledAt: now,\n    }));\n\n    // Schedule all events\n    scenarioEvents.forEach((event, index) => {\n      const timer = setTimeout(\n        () => {\n          // Generate a truly unique ID by including a timestamp\n          const uniqueId = `${event.payload.id || 'event'}-${event.type}-${index}-${Date.now()}`;\n\n          // Convert scenario event to DemoEvent\n          const demoEvent: DemoEvent = {\n            id: uniqueId,\n            type: event.type,\n            amount: event.type === 'payout.paid' ? event.payload.amount : undefined,\n            created: Date.now(),\n            flagged:\n              event.payload.flagged === true ||\n              (event.payload.metadata && event.payload.metadata.guardian_action === 'paused'),\n          };\n\n          // Remove this event from pending events ref\n          pendingEventsRef.current = pendingEventsRef.current.filter(\n            (pe) => !(pe.index === index && pe.event === event),\n          );\n\n          setEvents((prev) => [...prev.slice(-49), demoEvent]);\n          setCurrentIndex(index + 1);\n\n          // If this is the last event, stop the scenario and set timer to expire after 5 minutes\n          if (index === scenarioEvents.length - 1) {\n            setIsRunning(false);\n\n            const expireTimer = setTimeout(() => {\n              reset();\n              onExpire?.();\n            }, 300_000); // 5 minutes\n\n            timersRef.current.push(expireTimer);\n          }\n        },\n        Math.max(0, event.delayMs / speed),\n      );\n\n      timersRef.current.push(timer);\n    });\n  }, [clearAllTimers, scenarioEvents, speed, onExpire, reset]);\n\n  // Reschedule events when speed changes\n  const rescheduleEvents = useCallback(() => {\n    if (pendingEventsRef.current.length === 0) return;\n\n    clearAllTimers();\n    const now = Date.now();\n    const elapsed = now - startRef.current;\n    setIsRunning(true);\n\n    // For each pending event, calculate the new delay based on elapsed time\n    pendingEventsRef.current.forEach(({ event, index }) => {\n      const originalDelay = event.delayMs;\n      // Adjust delay based on elapsed time\n      const adjustedDelay = Math.max(0, originalDelay - elapsed);\n\n      // Schedule with new delay\n      const timer = setTimeout(\n        () => {\n          // Generate a truly unique ID by including a timestamp\n          const uniqueId = `${event.payload.id || 'event'}-${event.type}-${index}-${Date.now()}`;\n\n          // Convert scenario event to DemoEvent\n          const demoEvent: DemoEvent = {\n            id: uniqueId,\n            type: event.type,\n            amount: event.type === 'payout.paid' ? event.payload.amount : undefined,\n            created: Date.now(),\n            flagged:\n              event.payload.flagged === true ||\n              (event.payload.metadata && event.payload.metadata.guardian_action === 'paused'),\n          };\n\n          // Remove this event from pending events ref\n          pendingEventsRef.current = pendingEventsRef.current.filter(\n            (pe) => !(pe.index === index && pe.event === event),\n          );\n\n          setEvents((prev) => [...prev.slice(-49), demoEvent]);\n          setCurrentIndex(index + 1);\n\n          // If this is the last event, stop running and set timer to expire\n          if (index === scenarioEvents.length - 1) {\n            setIsRunning(false);\n\n            const expireTimer = setTimeout(() => {\n              reset();\n              onExpire?.();\n            }, 300_000); // 5 minutes\n\n            timersRef.current.push(expireTimer);\n          }\n        },\n        Math.max(0, adjustedDelay / speed),\n      );\n\n      timersRef.current.push(timer);\n    });\n  }, [clearAllTimers, scenarioEvents, speed, onExpire, reset]);\n\n  // Load scenario effect\n  useEffect(() => {\n    if (scenarioName) {\n      clearAllTimers();\n      loadScenario(scenarioName);\n    }\n\n    return () => {\n      if (fetchControllerRef.current) {\n        fetchControllerRef.current.abort();\n        fetchControllerRef.current = null;\n      }\n      clearAllTimers();\n    };\n  }, [scenarioName, clearAllTimers, loadScenario]);\n\n  // Schedule events when scenario data is loaded\n  useEffect(() => {\n    if (scenarioEvents.length > 0) {\n      scheduleEvents();\n    }\n  }, [scenarioEvents, scheduleEvents]);\n\n  // Reschedule when speed changes\n  useEffect(() => {\n    if (scenarioEvents.length > 0 && pendingEventsRef.current.length > 0) {\n      rescheduleEvents();\n    }\n  }, [speed, scenarioEvents.length, rescheduleEvents]);\n\n  return {\n    events,\n    currentIndex,\n    total: scenarioEvents.length,\n    isLoading,\n    error,\n    restart,\n    reset,\n    isRunning,\n    totalDelayMs,\n  };\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/michaelfuscoletti/Desktop/dock108home/app/guardian-demo/useFakeStripeEvents.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/michaelfuscoletti/Desktop/dock108home/app/layout.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/michaelfuscoletti/Desktop/dock108home/app/login/page.tsx","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":66,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":66,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1759,1762],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1759,1762],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"'use client';\n\nimport { Suspense, useEffect, useState } from 'react';\nimport { useRouter, useSearchParams } from 'next/navigation';\nimport { Loader2 } from 'lucide-react';\nimport { createClient } from '@/utils/supabase/client';\nimport Link from 'next/link';\n\nimport { Button } from '@/components/ui/button';\nimport { Input } from '@/components/ui/input';\nimport { Label } from '@/components/ui/label';\nimport {\n  Card,\n  CardContent,\n  CardDescription,\n  CardFooter,\n  CardHeader,\n  CardTitle,\n} from '@/components/ui/card';\n\n// Client component that safely uses useSearchParams\nfunction LoginForm() {\n  const router = useRouter();\n  const searchParams = useSearchParams();\n  const redirectTo = searchParams.get('redirectTo');\n  const defaultRedirect = '/stripe-guardian/alerts';\n\n  const [email, setEmail] = useState('');\n  const [password, setPassword] = useState('');\n  const [loading, setLoading] = useState(false);\n  const [error, setError] = useState('');\n  const supabase = createClient();\n\n  useEffect(() => {\n    // Check if already logged in and redirect to dashboard\n    const checkSession = async () => {\n      const {\n        data: { session },\n      } = await supabase.auth.getSession();\n      if (session) {\n        router.replace('/stripe-guardian/alerts');\n      }\n    };\n\n    checkSession();\n  }, [router, supabase]);\n\n  const handleLogin = async (e: React.FormEvent) => {\n    e.preventDefault();\n    setLoading(true);\n    setError('');\n\n    try {\n      const { error } = await supabase.auth.signInWithPassword({\n        email,\n        password,\n      });\n\n      if (error) {\n        throw error;\n      }\n\n      // Redirect after successful login\n      router.push(redirectTo || defaultRedirect);\n      router.refresh();\n    } catch (error: any) {\n      setError(error.message || 'An error occurred during sign in');\n    } finally {\n      setLoading(false);\n    }\n  };\n\n  return (\n    <div className=\"flex min-h-screen items-center justify-center bg-slate-900 p-4\">\n      <Card className=\"w-full max-w-md bg-slate-800 text-white\">\n        <CardHeader className=\"space-y-1\">\n          <CardTitle className=\"text-2xl font-bold\">Sign in to DOCK108</CardTitle>\n          <CardDescription className=\"text-slate-400\">\n            Enter your email and password to access your account\n          </CardDescription>\n        </CardHeader>\n        <CardContent>\n          <form onSubmit={handleLogin} className=\"space-y-4\">\n            <div className=\"space-y-2\">\n              <Label htmlFor=\"email\">Email</Label>\n              <Input\n                id=\"email\"\n                type=\"email\"\n                placeholder=\"email@example.com\"\n                value={email}\n                onChange={(e) => setEmail(e.target.value)}\n                required\n                className=\"bg-slate-700 border-slate-600\"\n              />\n            </div>\n            <div className=\"space-y-2\">\n              <Label htmlFor=\"password\">Password</Label>\n              <Input\n                id=\"password\"\n                type=\"password\"\n                value={password}\n                onChange={(e) => setPassword(e.target.value)}\n                required\n                className=\"bg-slate-700 border-slate-600\"\n              />\n            </div>\n            {error && <div className=\"text-red-500 text-sm\">{error}</div>}\n            <Button type=\"submit\" disabled={loading} className=\"w-full\">\n              {loading ? (\n                <>\n                  <Loader2 className=\"mr-2 h-4 w-4 animate-spin\" />\n                  Signing in...\n                </>\n              ) : (\n                'Sign in'\n              )}\n            </Button>\n          </form>\n        </CardContent>\n        <CardFooter className=\"flex flex-col space-y-2\">\n          <div className=\"text-center text-sm text-slate-400\">\n            Don&apos;t have an account?\n            <Link href=\"/sign-up\" className=\"ml-1 font-medium text-blue-400 hover:underline\">\n              Sign up for Beta\n            </Link>\n          </div>\n        </CardFooter>\n      </Card>\n    </div>\n  );\n}\n\n// Main page component with Suspense boundary\nexport default function LoginPage() {\n  return (\n    <Suspense\n      fallback={\n        <div className=\"flex min-h-screen items-center justify-center bg-slate-900\">\n          <Loader2 className=\"h-8 w-8 animate-spin text-primary\" />\n        </div>\n      }\n    >\n      <LoginForm />\n    </Suspense>\n  );\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/michaelfuscoletti/Desktop/dock108home/app/notary-ci/layout.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/michaelfuscoletti/Desktop/dock108home/app/notary-ci/opengraph-image.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/michaelfuscoletti/Desktop/dock108home/app/notary-ci/page.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/michaelfuscoletti/Desktop/dock108home/app/opengraph-image.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/michaelfuscoletti/Desktop/dock108home/app/page.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/michaelfuscoletti/Desktop/dock108home/app/providers.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/michaelfuscoletti/Desktop/dock108home/app/rss.xml/route.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/michaelfuscoletti/Desktop/dock108home/app/sign-up/page.tsx","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":71,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":71,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2142,2145],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2142,2145],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"'use client';\n\nimport { useState } from 'react';\nimport { createClient } from '@/utils/supabase/client';\nimport { Button } from '@/components/ui/button';\nimport { Input } from '@/components/ui/input';\nimport { Label } from '@/components/ui/label';\nimport {\n  Card,\n  CardContent,\n  CardDescription,\n  CardFooter,\n  CardHeader,\n  CardTitle,\n} from '@/components/ui/card';\nimport { Loader2 } from 'lucide-react';\nimport Link from 'next/link';\n\nexport default function SignupPage() {\n  const supabase = createClient();\n  const [email, setEmail] = useState('');\n  const [password, setPassword] = useState('');\n  const [confirmPassword, setConfirmPassword] = useState('');\n  const [loading, setLoading] = useState(false);\n  const [error, setError] = useState('');\n  const [message, setMessage] = useState(''); // For success messages\n\n  const handleSignup = async (e: React.FormEvent) => {\n    e.preventDefault();\n    setError('');\n    setMessage('');\n\n    if (password !== confirmPassword) {\n      setError('Passwords do not match.');\n      return;\n    }\n\n    // Basic password complexity check (example: min 8 chars)\n    if (password.length < 8) {\n      setError('Password must be at least 8 characters long.');\n      return;\n    }\n\n    setLoading(true);\n\n    try {\n      // Sign up the user with Supabase Auth\n      const { error: signUpError } = await supabase.auth.signUp({\n        email,\n        password,\n        // Optional: Redirect user after email confirmation\n        // options: {\n        //   emailRedirectTo: `${location.origin}/auth/callback`,\n        // },\n      });\n\n      if (signUpError) {\n        throw signUpError;\n      }\n\n      // Show success message - user needs to confirm email\n      setMessage('Check your email to confirm your account!');\n      // Optionally clear form or redirect after a delay\n      // setEmail('');\n      // setPassword('');\n      // setConfirmPassword('');\n      // router.push('/login?message=confirm_email'); // Redirect to login with message\n\n      // **Deferred for Beta:** Stripe Connect initiation logic would go here.\n      // For now, we just create the user account.\n    } catch (error: any) {\n      console.error('Signup error:', error);\n      setError(error.message || 'An error occurred during sign up.');\n    } finally {\n      setLoading(false);\n    }\n  };\n\n  return (\n    <div className=\"flex min-h-screen items-center justify-center bg-slate-900 p-4\">\n      <Card className=\"w-full max-w-md bg-slate-800 text-white\">\n        <CardHeader className=\"space-y-1\">\n          <CardTitle className=\"text-2xl font-bold\">Sign Up for DOCK108 Beta</CardTitle>\n          <CardDescription className=\"text-slate-400\">\n            Create your account to get started with the free beta.\n          </CardDescription>\n        </CardHeader>\n        <CardContent>\n          {message ? (\n            <div className=\"text-center text-green-400 p-4 border border-green-600 bg-green-900/30 rounded-md\">\n              {message}\n            </div>\n          ) : (\n            <form onSubmit={handleSignup} className=\"space-y-4\">\n              <div className=\"space-y-2\">\n                <Label htmlFor=\"email\">Email</Label>\n                <Input\n                  id=\"email\"\n                  type=\"email\"\n                  placeholder=\"email@example.com\"\n                  value={email}\n                  onChange={(e) => setEmail(e.target.value)}\n                  required\n                  className=\"bg-slate-700 border-slate-600\"\n                />\n              </div>\n              <div className=\"space-y-2\">\n                <Label htmlFor=\"password\">Password</Label>\n                <Input\n                  id=\"password\"\n                  type=\"password\"\n                  placeholder=\"********\"\n                  value={password}\n                  onChange={(e) => setPassword(e.target.value)}\n                  required\n                  minLength={8}\n                  className=\"bg-slate-700 border-slate-600\"\n                />\n              </div>\n              <div className=\"space-y-2\">\n                <Label htmlFor=\"confirm-password\">Confirm Password</Label>\n                <Input\n                  id=\"confirm-password\"\n                  type=\"password\"\n                  placeholder=\"********\"\n                  value={confirmPassword}\n                  onChange={(e) => setConfirmPassword(e.target.value)}\n                  required\n                  minLength={8}\n                  className=\"bg-slate-700 border-slate-600\"\n                />\n              </div>\n              {error && <div className=\"text-red-500 text-sm\">{error}</div>}\n              <Button type=\"submit\" disabled={loading} className=\"w-full\">\n                {loading ? (\n                  <>\n                    <Loader2 className=\"mr-2 h-4 w-4 animate-spin\" />\n                    Creating Account...\n                  </>\n                ) : (\n                  'Sign Up'\n                )}\n              </Button>\n            </form>\n          )}\n        </CardContent>\n        {!message && (\n          <CardFooter className=\"flex flex-col space-y-2\">\n            <div className=\"text-center text-sm text-slate-400\">\n              Already have an account?\n              <Link href=\"/login\" className=\"ml-1 font-medium text-blue-400 hover:underline\">\n                Sign In\n              </Link>\n            </div>\n          </CardFooter>\n        )}\n      </Card>\n    </div>\n  );\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/michaelfuscoletti/Desktop/dock108home/app/stripe-guardian/alerts/[id]/AlertFeedback.tsx","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":47,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":47,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2026,2029],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2026,2029],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":88,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":88,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3704,3707],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3704,3707],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"'use client';\n\nimport { useState, useEffect, useCallback } from 'react';\nimport { Button } from '@/components/ui/button';\nimport { Textarea } from '@/components/ui/textarea';\nimport { toast } from 'react-hot-toast';\nimport { Loader2 } from 'lucide-react';\n// import { logger } from '@/lib/logger'; // Assuming logger exists\n\ninterface AlertFeedbackProps {\n  alertId: string | number; // Alert ID can be number or UUID string\n}\n\ninterface FeedbackCounts {\n  false_positive: number;\n  legit: number;\n}\n\nexport function AlertFeedback({ alertId }: AlertFeedbackProps) {\n  const [feedbackState, setFeedbackState] = useState<'idle' | 'submitting' | 'submitted'>('idle');\n  const [selectedVerdict, setSelectedVerdict] = useState<'false_positive' | 'legit' | null>(null);\n  const [comment, setComment] = useState('');\n  const [showComment, setShowComment] = useState(false);\n  const [feedbackCounts, setFeedbackCounts] = useState<FeedbackCounts>({\n    false_positive: 0,\n    legit: 0,\n  });\n  const [isLoadingCounts, setIsLoadingCounts] = useState(true);\n  const [_userVote, setUserVote] = useState<'false_positive' | 'legit' | null>(null); // Track the logged-in user's specific vote\n\n  // Fetch initial counts and user's vote (if any)\n  const fetchFeedbackData = useCallback(async () => {\n    setIsLoadingCounts(true);\n    try {\n      // Fetch aggregate counts\n      const countsRes = await fetch(`/api/guardian/alerts/feedback?alertId=${alertId}`);\n      if (!countsRes.ok) throw new Error('Failed to fetch feedback counts');\n      const countsData: FeedbackCounts = await countsRes.json();\n      setFeedbackCounts(countsData);\n\n      // TODO: Fetch the current user's specific vote if needed to pre-fill state\n      // This might require another API endpoint or modifying the GET response\n      // For now, we rely on local state after submission.\n\n      // logger.info('Fetched feedback counts', { alertId, counts: countsData });\n      console.log('Fetched feedback counts', { alertId, counts: countsData });\n    } catch (error: any) {\n      // logger.error('Error fetching feedback data', { alertId, error: error.message });\n      console.error('Error fetching feedback data', { alertId, error: error.message });\n      toast.error('Could not load feedback counts.');\n    } finally {\n      setIsLoadingCounts(false);\n    }\n  }, [alertId]);\n\n  useEffect(() => {\n    fetchFeedbackData();\n  }, [fetchFeedbackData]);\n\n  const handleSubmit = async (verdict: 'false_positive' | 'legit') => {\n    setFeedbackState('submitting');\n    setSelectedVerdict(verdict);\n    let feedbackComment = verdict === 'false_positive' ? comment : undefined;\n\n    // logger.info('Submitting feedback', { alertId, verdict, hasComment: !!feedbackComment });\n    console.log('Submitting feedback', { alertId, verdict, hasComment: !!feedbackComment });\n\n    try {\n      const response = await fetch('/api/guardian/alerts/feedback', {\n        method: 'POST',\n        headers: { 'Content-Type': 'application/json' },\n        body: JSON.stringify({ alertId, verdict, comment: feedbackComment }),\n      });\n\n      if (!response.ok) {\n        const errorData = await response.json();\n        throw new Error(errorData.error || 'Failed to submit feedback');\n      }\n\n      // logger.info('Feedback submitted successfully', { alertId, verdict });\n      console.log('Feedback submitted successfully', { alertId, verdict });\n      toast.success('Thank you for your feedback!');\n      setFeedbackState('submitted');\n      setUserVote(verdict); // Update user's current vote locally\n      // Refresh counts after submission\n      fetchFeedbackData();\n      setShowComment(false); // Hide comment box after successful submission\n    } catch (error: any) {\n      // logger.error('Error submitting feedback', { alertId, verdict, error: error.message });\n      console.error('Error submitting feedback', { alertId, verdict, error: error.message });\n      toast.error(`Failed to submit feedback: ${error.message}`);\n      setFeedbackState('idle'); // Reset state on error\n      setSelectedVerdict(null);\n    }\n  };\n\n  // Handle clicking a verdict button\n  const handleVoteClick = (verdict: 'false_positive' | 'legit') => {\n    if (feedbackState === 'submitting') return;\n\n    // If clicking the same verdict again (effectively an undo/change mind before submit)\n    if (selectedVerdict === verdict && feedbackState !== 'submitted') {\n      setSelectedVerdict(null);\n      setShowComment(false);\n      setComment('');\n      return;\n    }\n\n    // If changing vote or making initial vote\n    setSelectedVerdict(verdict);\n    if (verdict === 'false_positive') {\n      setShowComment(true);\n    } else {\n      setShowComment(false);\n      setComment(''); // Clear comment if switching to legit\n      // Submit immediately if choosing legit\n      handleSubmit(verdict);\n    }\n  };\n\n  // Handle submitting the comment for false positive\n  const handleFalsePositiveSubmit = () => {\n    if (selectedVerdict === 'false_positive') {\n      handleSubmit('false_positive');\n    }\n  };\n\n  // Allow user to change their mind after submitting\n  const handleUndo = () => {\n    setFeedbackState('idle');\n    setSelectedVerdict(null);\n    setUserVote(null); // Clear local memory of user vote\n    setShowComment(false);\n    setComment('');\n    // Note: This doesn't delete the feedback from the DB, just resets UI state\n    // To truly undo, a DELETE API call would be needed.\n    // Current behavior: allows user to re-vote which updates their previous vote.\n  };\n\n  return (\n    <div className=\"mt-6\">\n      <h3 className=\"text-md font-semibold text-slate-700 mb-3\">Was this alert correct?</h3>\n\n      {feedbackState === 'submitted' ? (\n        <div className=\"flex items-center space-x-4 p-4 bg-green-50 border border-green-200 rounded-md\">\n          <span className=\"text-green-700\">Thank you for your feedback!</span>\n          <Button variant=\"link\" onClick={handleUndo} className=\"text-sm p-0 h-auto\">\n            (Change my vote)\n          </Button>\n        </div>\n      ) : (\n        <div className=\"space-y-4\">\n          <div className=\"flex items-center space-x-4\">\n            <Button\n              variant={selectedVerdict === 'false_positive' ? 'destructive' : 'ghost'}\n              onClick={() => handleVoteClick('false_positive')}\n              disabled={feedbackState === 'submitting'}\n              size=\"sm\"\n            >\n              {feedbackState === 'submitting' && selectedVerdict === 'false_positive' ? (\n                <Loader2 className=\"mr-2 h-4 w-4 animate-spin\" />\n              ) : (\n                '🚫'\n              )}\n              False Positive\n            </Button>\n            <Button\n              variant={selectedVerdict === 'legit' ? 'success' : 'ghost'} // Need a 'success' variant or use default\n              onClick={() => handleVoteClick('legit')}\n              disabled={feedbackState === 'submitting'}\n              size=\"sm\"\n            >\n              {feedbackState === 'submitting' && selectedVerdict === 'legit' ? (\n                <Loader2 className=\"mr-2 h-4 w-4 animate-spin\" />\n              ) : (\n                '✅'\n              )}\n              Legit\n            </Button>\n          </div>\n\n          {showComment && selectedVerdict === 'false_positive' && (\n            <div className=\"space-y-2\">\n              <Textarea\n                placeholder=\"Optional: Why was this a false positive? (e.g., known customer activity)\"\n                value={comment}\n                onChange={(e) => setComment(e.target.value)}\n                rows={3}\n                disabled={feedbackState === 'submitting'}\n              />\n              <Button\n                onClick={handleFalsePositiveSubmit}\n                disabled={feedbackState === 'submitting'}\n                size=\"sm\"\n              >\n                {feedbackState === 'submitting' ? (\n                  <Loader2 className=\"mr-2 h-4 w-4 animate-spin\" />\n                ) : null}\n                Submit False Positive Feedback\n              </Button>\n            </div>\n          )}\n        </div>\n      )}\n\n      {/* Display Counts */}\n      <div className=\"mt-4 text-sm text-slate-500\">\n        {isLoadingCounts ? (\n          <span className=\"flex items-center\">\n            <Loader2 className=\"mr-1 h-3 w-3 animate-spin\" /> Loading feedback counts...\n          </span>\n        ) : (\n          <span>\n            Current Feedback: {feedbackCounts.false_positive} False Positive /{' '}\n            {feedbackCounts.legit} Legit\n          </span>\n        )}\n      </div>\n    </div>\n  );\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/michaelfuscoletti/Desktop/dock108home/app/stripe-guardian/alerts/[id]/page.tsx","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":11,"column":13,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":11,"endColumn":16,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[487,490],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[487,490],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":69,"column":34,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":69,"endColumn":37,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2534,2537],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2534,2537],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { createServerClient } from '@supabase/ssr';\nimport { cookies } from 'next/headers';\nimport { notFound } from 'next/navigation';\nimport { Database } from '@/types/supabase';\nimport { Container } from '@/components/Container';\nimport { AlertFeedback } from './AlertFeedback'; // Client component for feedback\nimport NotificationStatus from '@/components/alerts/NotificationStatus'; // Import the new component\n\n// Fetch data server-side\nasync function getAlertDetails(\n  supabase: any,\n  alertId: string,\n): Promise<Database['public']['Tables']['alerts']['Row'] | null> {\n  // TODO: Add RLS check or ensure this query respects user's access to the alert's account\n  const { data: alert, error } = await supabase\n    .from('alerts')\n    .select('*, connected_accounts(business_name)') // Fetch related account name\n    .eq('id', alertId)\n    .maybeSingle();\n\n  if (error) {\n    console.error('Error fetching alert details:', error);\n    return null;\n  }\n  // Basic check if user should see this alert (improve with proper RLS or explicit check)\n  // This is a placeholder - ideally RLS enforces this\n  // const { data: userAccounts } = await supabase.from('connected_accounts').select('stripe_account_id').eq('user_id', userId);\n  // if (!userAccounts?.some(acc => acc.stripe_account_id === alert?.stripe_account_id)) {\n  //   return null;\n  // }\n\n  return alert;\n}\n\nexport default async function AlertDetailPage({ params }: { params: { id: string } }) {\n  const cookieStore = cookies();\n  const supabase = createServerClient<Database>(\n    process.env.NEXT_PUBLIC_SUPABASE_URL!,\n    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,\n    {\n      cookies: {\n        get: (name: string) => cookieStore.get(name)?.value,\n      },\n    },\n  );\n\n  const {\n    data: { session },\n  } = await supabase.auth.getSession();\n  if (!session) {\n    // Handle unauthenticated access if needed, e.g., redirect to login\n    // For now, assume AuthGuard handles this, but fetching requires user ID\n    notFound(); // Or redirect\n  }\n\n  const alert = await getAlertDetails(supabase, params.id);\n\n  if (!alert) {\n    notFound();\n  }\n\n  // Check if the user is an admin (example assumes role is in user_metadata)\n  // Adjust based on where the role is actually stored (e.g., app_metadata or a separate table)\n  const isAdmin = session?.user?.user_metadata?.role === 'admin';\n\n  // Format dates, etc.\n  const createdAtFormatted = alert.created_at ? new Date(alert.created_at).toLocaleString() : 'N/A';\n  const accountName =\n    (alert.connected_accounts as any)?.business_name ?? alert.stripe_account_id ?? 'N/A';\n\n  return (\n    <Container className=\"py-10\">\n      <h1 className=\"text-3xl font-bold tracking-tight mb-2\">Alert Details</h1>\n      <p className=\"text-sm text-slate-500 mb-6\">Review the details of this security alert.</p>\n\n      <div className=\"bg-white rounded-lg shadow p-6 space-y-4\">\n        <div>\n          <h2 className=\"text-lg font-semibold text-slate-800\">{alert.alert_type}</h2>\n          <p className=\"text-sm text-slate-600\">\n            Severity:{' '}\n            <span\n              className={`font-medium ${alert.severity === 'high' ? 'text-red-600' : alert.severity === 'medium' ? 'text-yellow-600' : 'text-gray-600'}`}\n            >\n              {alert.severity}\n            </span>\n          </p>\n        </div>\n        <p className=\"text-slate-700\">{alert.message}</p>\n        <div className=\"grid grid-cols-2 gap-4 text-sm\">\n          <p>\n            <strong className=\"text-slate-600\">Account:</strong> {accountName}\n          </p>\n          <p>\n            <strong className=\"text-slate-600\">Account ID:</strong> {alert.stripe_account_id}\n          </p>\n          <p>\n            <strong className=\"text-slate-600\">Created:</strong> {createdAtFormatted}\n          </p>\n          <p>\n            <strong className=\"text-slate-600\">Payout ID:</strong> {alert.stripe_payout_id || 'N/A'}\n          </p>\n          <p>\n            <strong className=\"text-slate-600\">Resolved:</strong> {alert.resolved ? 'Yes' : 'No'}\n          </p>\n          <p>\n            <strong className=\"text-slate-600\">Event ID:</strong> {alert.event_id || 'N/A'}\n          </p>\n        </div>\n\n        {/* --- Notification Status Component --- */}\n        <NotificationStatus\n          deliveryStatus={alert.delivery_status as Record<string, string> | null}\n          isAdmin={isAdmin}\n        />\n\n        <hr className=\"my-6\" />\n\n        {/* --- Feedback Component --- */}\n        <AlertFeedback alertId={alert.id} />\n      </div>\n    </Container>\n  );\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/michaelfuscoletti/Desktop/dock108home/app/stripe-guardian/alerts/layout.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/michaelfuscoletti/Desktop/dock108home/app/stripe-guardian/alerts/page.tsx","messages":[{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useEffect has a missing dependency: 'selectedAccountId'. Either include it or remove the dependency array.","line":202,"column":6,"nodeType":"ArrayExpression","endLine":202,"endColumn":16,"suggestions":[{"desc":"Update the dependencies array to be: [selectedAccountId, supabase]","fix":{"range":[7616,7626],"text":"[selectedAccountId, supabase]"}}]},{"ruleId":"react/no-unescaped-entities","severity":2,"message":"`'` can be escaped with `&apos;`, `&lsquo;`, `&#39;`, `&rsquo;`.","line":681,"column":24,"nodeType":"JSXText","messageId":"unescapedEntityAlts","suggestions":[{"messageId":"replaceWithAlt","data":{"alt":"&apos;"},"fix":{"range":[25963,26230],"text":"\n                    Stops Stripe from automatically sending funds to your bank. Guardian may turn\n                    this off automatically when fraud is suspected. You can resume payouts once\n                    you&apos;ve reviewed the transactions.\n                  "},"desc":"Replace with `&apos;`."},{"messageId":"replaceWithAlt","data":{"alt":"&lsquo;"},"fix":{"range":[25963,26230],"text":"\n                    Stops Stripe from automatically sending funds to your bank. Guardian may turn\n                    this off automatically when fraud is suspected. You can resume payouts once\n                    you&lsquo;ve reviewed the transactions.\n                  "},"desc":"Replace with `&lsquo;`."},{"messageId":"replaceWithAlt","data":{"alt":"&#39;"},"fix":{"range":[25963,26230],"text":"\n                    Stops Stripe from automatically sending funds to your bank. Guardian may turn\n                    this off automatically when fraud is suspected. You can resume payouts once\n                    you&#39;ve reviewed the transactions.\n                  "},"desc":"Replace with `&#39;`."},{"messageId":"replaceWithAlt","data":{"alt":"&rsquo;"},"fix":{"range":[25963,26230],"text":"\n                    Stops Stripe from automatically sending funds to your bank. Guardian may turn\n                    this off automatically when fraud is suspected. You can resume payouts once\n                    you&rsquo;ve reviewed the transactions.\n                  "},"desc":"Replace with `&rsquo;`."}]}],"suppressedMessages":[{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useEffect has a missing dependency: 'searchParams'. Either include it or remove the dependency array.","line":144,"column":6,"nodeType":"ArrayExpression","endLine":144,"endColumn":8,"suggestions":[{"desc":"Update the dependencies array to be: [searchParams]","fix":{"range":[5461,5463],"text":"[searchParams]"}}],"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":1,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"'use client';\n\nimport React, { useEffect, useState, Suspense, useMemo, useTransition } from 'react';\nimport { format, startOfMonth, formatRelative } from 'date-fns';\nimport { Loader2, Info } from 'lucide-react';\nimport toast from 'react-hot-toast';\nimport { createClient } from '@/utils/supabase/client';\nimport { useSearchParams /*, useRouter */ } from 'next/navigation'; // Removed useRouter\nimport { Switch } from '@/components/ui/switch';\nimport { Tooltip, TooltipContent, TooltipProvider, TooltipTrigger } from '@/components/ui/tooltip';\nimport {\n  resumePayoutsServerAction,\n  pausePayoutsServerAction,\n} from 'app/(auth)/settings/connected-accounts/actions';\n// import { alertCapFor } from '@/lib/guardian/plan'; // Removed unused\nimport { UpgradeBanner } from '@/app/components/UpgradeBanner';\n\nimport { Container } from '@/components/Container';\nimport { Badge } from '@/components/ui/badge';\nimport { Button } from '@/components/ui/button';\nimport { Tabs, TabsContent, TabsList, TabsTrigger } from '@/components/ui/tabs';\nimport {\n  Select,\n  SelectContent,\n  SelectItem,\n  SelectTrigger,\n  SelectValue,\n} from '@/components/ui/select';\n// import StripeAccountSelect from '@/app/components/StripeAccountSelect'; // Removed unused\nimport MetricCard from '@/app/components/MetricCard';\n// import { Database } from '@/types/supabase'; // Removed unused\n\n// Type for connected account data needed\ntype ConnectedAccount = {\n  stripe_account_id: string;\n  business_name: string | null;\n  payouts_paused: boolean;\n  paused_by: string | null;\n  paused_reason: string | null;\n};\n\n// Alert type definition\ntype Alert = {\n  id: number;\n  alert_type: string;\n  severity: 'low' | 'medium' | 'high';\n  message: string;\n  stripe_payout_id: string | null;\n  stripe_account_id: string;\n  resolved: boolean;\n  created_at: string;\n  risk_score: number | null;\n};\n\n// Alert channels type definition\n// type AlertChannels = { // Removed unused type\n//   id: number;\n//   stripe_account_id: string;\n//   slack_webhook_url: string | null;\n//   email_to: string | null;\n//   auto_pause: boolean;\n// };\n\n// Settings type definition - Define locally if import commented out\ntype Settings = {\n  id: string;\n  user_id: string;\n  tier: string | null;\n  free_tier_alert_limit?: number;\n  pro_tier_alert_limit?: number;\n  enterprise_tier_alert_limit?: number;\n  slack_notifications_enabled?: boolean;\n  email_notifications_enabled?: boolean;\n  // Add other relevant settings fields as needed\n};\n\n// StripeEvent might be needed? Define a basic structure or remove usage\n// type StripeEvent = Record<string, any>; // Removed unused type\n// Define AlertStatus locally if needed\n// type AlertStatus = 'open' | 'resolved' | 'muted'; // Removed unused type\n\n// Wrap the core logic in a component to use Suspense\nfunction AlertsPageContent() {\n  const [initialLoading, setInitialLoading] = useState(true); // Loading accounts\n  const [loadingAlerts, setLoadingAlerts] = useState(false); // Loading data for selected account\n  const [alerts, setAlerts] = useState<Alert[]>([]);\n  const [allAccounts, setAllAccounts] = useState<ConnectedAccount[]>([]);\n  const [selectedAccountId, setSelectedAccountId] = useState<string | null>(null);\n  const [autoPause, setAutoPause] = useState(false);\n  const [updatingAutoPause, setUpdatingAutoPause] = useState(false);\n  // Add new state for settings and monthly alert count\n  const [settings, setSettings] = useState<Settings | null>(null);\n  const [_monthlyAlertCount, setMonthlyAlertCount] = useState(0); // Prefixed unused\n  const [alertMetrics, setAlertMetrics] = useState<{\n    monthlyCount: number;\n    openCount: number;\n    lastProcessed: string | null;\n  }>({\n    monthlyCount: 0,\n    openCount: 0,\n    lastProcessed: null,\n  });\n\n  // Add state for selected account's payout status\n  const [isTogglingPayouts, startToggleTransition] = useTransition();\n\n  const supabase = createClient();\n  const searchParams = useSearchParams();\n\n  // Memoize the currently selected account's full data\n  const selectedAccountData = useMemo(() => {\n    return allAccounts.find((acc) => acc.stripe_account_id === selectedAccountId) || null;\n  }, [allAccounts, selectedAccountId]);\n\n  // Function to determine alert cap based on tier\n  const alertCapFor = (settings: Settings | null): number => {\n    if (!settings) return 50; // Default to free tier limit\n\n    if (settings.tier === 'pro') {\n      return settings.pro_tier_alert_limit || 1000; // Default pro tier limit\n    } else if (settings.tier === 'enterprise') {\n      return settings.enterprise_tier_alert_limit || 10000; // Default enterprise tier limit\n    } else {\n      // Free tier\n      return settings.free_tier_alert_limit || 50; // Default free tier limit\n    }\n  };\n\n  // Calculate whether to show upgrade banner\n  const showUpgradeBanner = useMemo(() => {\n    const alertCap = alertCapFor(settings);\n    return settings?.tier === 'free' && _monthlyAlertCount >= alertCap;\n  }, [settings, _monthlyAlertCount]);\n\n  // Show toast on first connect (runs only once)\n  useEffect(() => {\n    const firstConnect = searchParams.get('first');\n    if (firstConnect === '1') {\n      toast.success('✅ Account connected — Guardian is now monitoring payouts.');\n      // Use window.history.replaceState to remove query param without triggering full effect chain\n      window.history.replaceState(null, '', '/stripe-guardian/alerts');\n    }\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, []); // Empty dependency array ensures it runs only on mount\n\n  // Fetch user's connected accounts on mount\n  useEffect(() => {\n    let isMounted = true;\n    async function fetchUserAccounts() {\n      console.log('Fetching user accounts and payout status...');\n      setInitialLoading(true);\n      try {\n        const {\n          data: { session },\n        } = await supabase.auth.getSession();\n        if (!session || !isMounted) return;\n        console.log('Session obtained, fetching accounts for user:', session.user.id);\n\n        // Fetch ALL connected accounts for the user, including business_name AND payout status\n        const { data: accountsData, error: accountsError } = await supabase\n          .from('connected_accounts')\n          .select('stripe_account_id, business_name, payouts_paused, paused_by, paused_reason') // Select new fields\n          .eq('user_id', session.user.id);\n\n        if (accountsError) throw accountsError;\n        console.log('Fetched accounts data:', accountsData);\n\n        if (isMounted) {\n          if (accountsData && accountsData.length > 0) {\n            setAllAccounts(accountsData);\n            // Set the first account as selected initially\n            if (!selectedAccountId) {\n              console.log('Setting initial selected account:', accountsData[0].stripe_account_id);\n              setSelectedAccountId(accountsData[0].stripe_account_id);\n            }\n          } else {\n            console.log('No connected accounts found for user.');\n            setAllAccounts([]);\n            setSelectedAccountId(null);\n          }\n        }\n      } catch (error) {\n        console.error('Error fetching connected accounts:', error);\n        toast.error('Failed to load connected accounts');\n        if (isMounted) {\n          setAllAccounts([]);\n          setSelectedAccountId(null);\n        }\n      } finally {\n        if (isMounted) {\n          console.log('Finished initial account loading.');\n          setInitialLoading(false);\n        }\n      }\n    }\n\n    fetchUserAccounts();\n    return () => {\n      console.log('Unmounting account fetch effect');\n      isMounted = false;\n    }; // Cleanup\n  }, [supabase]); // Only depends on supabase client\n\n  // Fetch alerts and user settings when selectedAccountId changes\n  useEffect(() => {\n    if (!selectedAccountId) {\n      console.log('No account selected, clearing data.');\n      setAlerts([]); // Clear alerts if no account is selected\n      setAutoPause(false);\n      setMonthlyAlertCount(0); // Reset alert count\n      return;\n    }\n\n    let isMounted = true;\n    async function fetchAccountData() {\n      console.log(`Fetching data for selected account: ${selectedAccountId}`);\n      setLoadingAlerts(true);\n      setAlerts([]); // Clear previous account's alerts\n      setAutoPause(false); // Reset autopause state\n      setMonthlyAlertCount(0); // Reset alert count\n\n      try {\n        // Get current user ID first\n        const {\n          data: { session },\n          error: sessionError,\n        } = await supabase.auth.getSession();\n        if (sessionError || !session) {\n          throw new Error(sessionError?.message || 'User not authenticated');\n        }\n        const userId = session.user.id;\n\n        // Fetch USER settings, check plan tier\n        let { data: settingsData, error: settingsError } = await supabase\n          .from('settings')\n          .select('*')\n          .eq('user_id', userId) // Use user_id\n          .maybeSingle();\n\n        // Lazy-create user settings if they don't exist\n        if (!settingsData && settingsError && settingsError.code === 'PGRST116') {\n          // Row not found\n          console.log(`No settings found for user ${userId}, creating defaults.`);\n          const { data: newSettings, error: insertError } = await supabase\n            .from('settings')\n            .insert({\n              user_id: userId,\n              // Add reasonable defaults for other settings columns here\n              slack_notifications_enabled: false,\n              email_notifications_enabled: true,\n              // ... other defaults\n            })\n            .select()\n            .single();\n\n          if (insertError) {\n            console.error('Error creating default user settings:', insertError);\n            // Decide how to handle - maybe proceed without settings or show error\n            settingsError = insertError; // Use the insert error\n          } else {\n            settingsData = newSettings; // Use the newly created settings\n            settingsError = null; // Clear the row not found error\n          }\n        }\n\n        if (settingsError) throw settingsError;\n\n        console.log('Fetched user settings:', settingsData);\n        if (isMounted && settingsData) {\n          setSettings(settingsData);\n        }\n\n        // Get monthly alert count for the current month\n        const now = new Date();\n        const firstDayOfMonth = startOfMonth(now);\n\n        const { data: monthlyAlerts, error: monthlyAlertsError } = await supabase\n          .from('alerts')\n          .select('id')\n          .eq('stripe_account_id', selectedAccountId)\n          .gte('created_at', firstDayOfMonth.toISOString())\n          .lte('created_at', now.toISOString());\n\n        if (monthlyAlertsError) {\n          console.error('Error fetching monthly alerts:', monthlyAlertsError);\n        }\n\n        const _monthlyAlertCountResult = monthlyAlerts?.length || 0; // Prefix unused var\n\n        // Fetch alert channels for the selected account\n        console.log(`Fetching channels for ${selectedAccountId}...`);\n        const { data: channels, error: channelError } = await supabase\n          .from('alert_channels')\n          .select('auto_pause')\n          .eq('stripe_account_id', selectedAccountId)\n          .maybeSingle();\n\n        if (channelError) throw channelError;\n        console.log(`Fetched channels for ${selectedAccountId}:`, channels);\n        if (isMounted && channels) {\n          setAutoPause(channels.auto_pause || false);\n        }\n\n        // Fetch alerts for the selected account\n        console.log(`Fetching alerts for ${selectedAccountId}...`);\n        const { data: alertsData, error: alertsError } = await supabase\n          .from('alerts')\n          .select('*, risk_score')\n          .eq('stripe_account_id', selectedAccountId)\n          .order('created_at', { ascending: false });\n\n        if (alertsError) throw alertsError;\n        console.log(`Fetched alerts for ${selectedAccountId}:`, alertsData?.length);\n        if (isMounted && alertsData) {\n          setAlerts(alertsData);\n        }\n\n        // Fetch account info and settings\n        async function fetchAccountInfo() {\n          if (!selectedAccountId) return;\n\n          try {\n            // Fetch settings\n            const { data: settingsData, error: settingsError } = await supabase\n              .from('settings')\n              .select('*')\n              .eq('account_id', selectedAccountId)\n              .single();\n\n            if (settingsError && settingsError.code !== 'PGRST116') {\n              console.error('Error fetching settings:', settingsError);\n            }\n\n            setSettings(settingsData || { tier: 'free', free_tier_alert_limit: 50 });\n\n            // Calculate first day of current month\n            const firstDayOfMonth = startOfMonth(new Date());\n\n            // Fetch monthly alert count\n            const { count: monthlyCount, error: monthlyCountError } = await supabase\n              .from('alerts')\n              .select('*', { count: 'exact', head: true })\n              .eq('account_id', selectedAccountId)\n              .gte('created_at', firstDayOfMonth.toISOString());\n\n            if (monthlyCountError) throw monthlyCountError;\n\n            // Fetch open alert count\n            const { count: openCount, error: openCountError } = await supabase\n              .from('alerts')\n              .select('*', { count: 'exact', head: true })\n              .eq('account_id', selectedAccountId)\n              .eq('status', 'open');\n\n            if (openCountError) throw openCountError;\n\n            // Fetch last processed event timestamp\n            const { data: lastEvent, error: lastEventError } = await supabase\n              .from('processed_events')\n              .select('created_at')\n              .eq('account_id', selectedAccountId)\n              .order('created_at', { ascending: false })\n              .limit(1)\n              .single();\n\n            if (lastEventError && lastEventError.code !== 'PGRST116') {\n              console.error('Error fetching last event:', lastEventError);\n            }\n\n            setAlertMetrics({\n              monthlyCount: monthlyCount || 0,\n              openCount: openCount || 0,\n              lastProcessed: lastEvent?.created_at || null,\n            });\n\n            setMonthlyAlertCount(monthlyCount || 0);\n          } catch (error) {\n            console.error('Error fetching account info:', error);\n          }\n        }\n\n        fetchAccountInfo();\n      } catch (error) {\n        console.error('Error fetching data for account:', selectedAccountId, error);\n        toast.error(`Failed to load data for account ${selectedAccountId}`);\n      } finally {\n        if (isMounted) {\n          console.log(`Finished fetching data for ${selectedAccountId}`);\n          setLoadingAlerts(false);\n        }\n      }\n    }\n\n    fetchAccountData();\n\n    return () => {\n      console.log(`Unmounting data fetch effect for ${selectedAccountId}`);\n      isMounted = false;\n    }; // Cleanup effect\n  }, [supabase, selectedAccountId]); // Added selectedAccountId\n\n  // Set up real-time subscription based on selectedAccountId\n  useEffect(() => {\n    if (!selectedAccountId) {\n      console.log('No account selected, skipping realtime subscription.');\n      return;\n    }\n\n    const channelId = `alerts-changes-${selectedAccountId}`;\n    console.log(`Setting up realtime channel: ${channelId}`);\n    const channel = supabase\n      .channel(channelId)\n      .on(\n        'postgres_changes',\n        {\n          event: '*',\n          schema: 'public',\n          table: 'alerts',\n          filter: `stripe_account_id=eq.${selectedAccountId}`, // Filter by selected account\n        },\n        (payload) => {\n          console.log(`Realtime payload received on ${channelId}:`, payload);\n          if (payload.eventType === 'INSERT') {\n            setAlerts((prev) => [payload.new as Alert, ...prev]);\n            toast.success('New alert received!');\n          } else if (payload.eventType === 'UPDATE') {\n            setAlerts((prev) =>\n              prev.map((alert) => (alert.id === payload.new.id ? (payload.new as Alert) : alert)),\n            );\n          } else if (payload.eventType === 'DELETE') {\n            setAlerts((prev) => prev.filter((alert) => alert.id !== payload.old.id));\n          }\n        },\n      )\n      .subscribe((status, err) => {\n        if (status === 'SUBSCRIBED') {\n          console.log(`Realtime subscribed on channel: ${channelId}`);\n        } else if (status === 'CHANNEL_ERROR' || status === 'TIMED_OUT') {\n          console.error(`Realtime error on ${channelId}:`, status, err);\n          toast.error('Realtime connection error. Refresh might be needed.');\n        }\n      });\n\n    // Cleanup function to remove the channel when component unmounts or selectedAccountId changes\n    return () => {\n      console.log(`Removing realtime channel: ${channelId}`);\n      supabase.removeChannel(channel).catch((err) => console.error('Error removing channel:', err));\n    };\n  }, [selectedAccountId, supabase]);\n\n  // Toggle auto-pause setting for the selected account\n  const toggleAutoPause = async (value: boolean) => {\n    if (!selectedAccountId) return;\n\n    setUpdatingAutoPause(true);\n    try {\n      const { error } = await supabase\n        .from('alert_channels')\n        .update({ auto_pause: value })\n        .eq('stripe_account_id', selectedAccountId);\n\n      if (error) throw error;\n\n      setAutoPause(value);\n      toast.success(`Auto-pause ${value ? 'enabled' : 'disabled'} for ${selectedAccountId}`);\n    } catch (error) {\n      console.error('Error updating auto-pause:', error);\n      toast.error('Failed to update auto-pause setting');\n    } finally {\n      setUpdatingAutoPause(false);\n    }\n  };\n\n  // --- Add handler for Payouts Toggle ---\n  const handleTogglePayouts = () => {\n    if (!selectedAccountData) return;\n\n    const account = selectedAccountData;\n    startToggleTransition(async () => {\n      const action = account.payouts_paused ? resumePayoutsServerAction : pausePayoutsServerAction;\n      const optimisticUpdate = !account.payouts_paused;\n\n      // Optimistic UI Update - Modify the allAccounts state directly\n      setAllAccounts((prev) =>\n        prev.map((acc) =>\n          acc.stripe_account_id === account.stripe_account_id\n            ? { ...acc, payouts_paused: optimisticUpdate }\n            : acc,\n        ),\n      );\n\n      try {\n        await action(account.stripe_account_id);\n        toast.success(`Payouts ${optimisticUpdate ? 'paused' : 'resumed'} successfully.`);\n        // Re-fetching/revalidation should handle the final state\n      } catch (error) {\n        // Rollback optimistic update on error\n        setAllAccounts((prev) =>\n          prev.map((acc) =>\n            acc.stripe_account_id === account.stripe_account_id\n              ? { ...acc, payouts_paused: account.payouts_paused } // Revert to original state\n              : acc,\n          ),\n        );\n        toast.error(error instanceof Error ? error.message : 'Failed to update payout status.');\n      }\n      // No finally block needed to reset loading state as useTransition handles it\n    });\n  };\n\n  // Mark an alert as resolved (API call likely needs account context if not implicit)\n  const markResolved = async (id: number) => {\n    // If the API endpoint `/api/alerts/${id}` doesn't implicitly know the account,\n    // you might need to pass selectedAccountId in the body or as a query param.\n    // For now, assuming the API can handle it based on user session + alert ID.\n    try {\n      setAlerts((prev) =>\n        prev.map((alert) => (alert.id === id ? { ...alert, resolved: true } : alert)),\n      );\n      const response = await fetch(`/api/alerts/${id}`, {\n        method: 'PATCH',\n        headers: { 'Content-Type': 'application/json' },\n        body: JSON.stringify({ resolved: true }),\n      });\n      if (!response.ok) throw new Error('Failed to update alert');\n      toast.success('Alert marked as resolved');\n    } catch (error) {\n      console.error('Error resolving alert:', error);\n      toast.error('Failed to resolve alert');\n      setAlerts((prev) =>\n        prev.map((alert) => (alert.id === id ? { ...alert, resolved: false } : alert)),\n      );\n    }\n  };\n\n  // --- Helper to get tooltip content ---\n  const getPauseTooltipContent = (account: ConnectedAccount | null): string => {\n    if (!account) return '';\n    if (account.payouts_paused) {\n      let reason = `Paused by ${account.paused_by || 'unknown'}`;\n      if (account.paused_reason) reason += `: ${account.paused_reason.replace(/_/g, ' ')}`;\n      return reason;\n    } else {\n      return 'Automatic payouts active.';\n    }\n  };\n\n  // Loading state for initial account fetch\n  if (initialLoading) {\n    return (\n      <Container className=\"py-10\">\n        <div className=\"flex justify-center items-center h-64\">\n          <Loader2 className=\"h-8 w-8 animate-spin text-slate-500\" />{' '}\n          <span className=\"ml-2\">Loading accounts...</span>\n        </div>\n      </Container>\n    );\n  }\n\n  // State when user has no connected accounts at all\n  if (allAccounts.length === 0) {\n    return (\n      <Container className=\"py-10\">\n        <div className=\"bg-white rounded-lg shadow p-8 text-center\">\n          <h3 className=\"font-medium text-lg mb-2\">No account connected</h3>\n          <p className=\"text-slate-500 mb-6\">\n            Connect your Stripe account to start monitoring payouts and receive alerts.\n          </p>\n          <Button asChild>\n            <a href=\"/stripe-guardian/onboard\">Connect Stripe Account</a>\n          </Button>\n        </div>\n      </Container>\n    );\n  }\n\n  // Filter alerts for the selected account (safe check)\n  const filteredAlerts = selectedAccountId\n    ? alerts.filter((alert) => alert.stripe_account_id === selectedAccountId)\n    : [];\n  const activeAlerts = filteredAlerts.filter((alert) => !alert.resolved);\n  const resolvedAlerts = filteredAlerts.filter((alert) => alert.resolved);\n\n  return (\n    <Container className=\"py-10\">\n      <div className=\"flex flex-col md:flex-row items-start md:items-center justify-between mb-8 gap-4\">\n        <h1 className=\"text-3xl font-bold tracking-tight\">Payout Guardian Alerts</h1>\n\n        {/* Account Selector Dropdown - only show if multiple accounts exist */}\n        {allAccounts.length > 1 && (\n          <div className=\"flex items-center space-x-3\">\n            <span className=\"text-sm font-medium text-slate-700\">Account:</span>\n            <Select value={selectedAccountId ?? ''} onValueChange={setSelectedAccountId}>\n              <SelectTrigger className=\"w-auto min-w-[250px]\">\n                {' '}\n                {/* Adjust width */}\n                <SelectValue placeholder=\"Select account...\" />\n              </SelectTrigger>\n              <SelectContent>\n                {allAccounts.map((acc) => (\n                  <SelectItem key={acc.stripe_account_id} value={acc.stripe_account_id}>\n                    <div className=\"flex flex-col\">\n                      <span className=\"font-medium\">{acc.business_name ?? 'Unnamed Account'}</span>\n                      <span className=\"text-xs text-slate-500 font-mono\">\n                        {acc.stripe_account_id}\n                      </span>\n                    </div>\n                  </SelectItem>\n                ))}\n              </SelectContent>\n            </Select>\n          </div>\n        )}\n        {/* Display selected account ID and name if only one account */}\n        {allAccounts.length === 1 && selectedAccountId && (\n          <div className=\"flex items-center space-x-2 p-2 bg-slate-100 rounded-md\">\n            <span className=\"text-sm font-medium text-slate-700\">Account:</span>\n            <div className=\"flex flex-col items-start\">\n              <span className=\"text-sm font-medium text-slate-800\">\n                {allAccounts[0].business_name ?? 'Unnamed Account'}\n              </span>\n              <span className=\"text-xs text-slate-500 font-mono\">{selectedAccountId}</span>\n            </div>\n          </div>\n        )}\n      </div>\n\n      {/* Display alert metrics */}\n      <div className=\"mb-8 grid gap-6 md:grid-cols-3\">\n        <MetricCard\n          title=\"Current Month Alerts\"\n          value={_monthlyAlertCount}\n          description={\n            settings?.tier === 'free'\n              ? `Free tier limit: ${alertCapFor(settings)}`\n              : 'Enterprise tier'\n          }\n        />\n        <MetricCard\n          title=\"Open Alerts\"\n          value={activeAlerts.length}\n          description=\"Unresolved alerts\"\n        />\n        <MetricCard\n          title=\"Last Event Processed\"\n          value={\n            alertMetrics.lastProcessed\n              ? formatRelative(new Date(alertMetrics.lastProcessed), new Date())\n              : '-'\n          }\n          description=\"Last webhook event\"\n        />\n      </div>\n\n      {/* Show upgrade banner for users exceeding free tier limits */}\n      {showUpgradeBanner && (\n        <UpgradeBanner monthlyAlertCount={_monthlyAlertCount} alertLimit={alertCapFor(settings)} />\n      )}\n\n      {/* Auto-pause and Tabs section - only show if an account is selected */}\n      {selectedAccountId && selectedAccountData && (\n        <>\n          <TooltipProvider delayDuration={300}>\n            {' '}\n            {/* Ensure TooltipProvider wraps the toggles */}\n            <div className=\"flex items-center justify-end space-x-6 mb-4\">\n              {' '}\n              {/* Use space-x for spacing */}\n              {/* Payout Pause Toggle */}\n              <div className=\"flex items-center space-x-2\">\n                <Tooltip>\n                  <TooltipTrigger asChild>\n                    <span className=\"text-sm font-medium text-slate-600 flex items-center\">\n                      Pause Payouts\n                      <Info className=\"h-3 w-3 ml-1 text-muted-foreground\" />\n                    </span>\n                  </TooltipTrigger>\n                  <TooltipContent className=\"max-w-xs\">\n                    Stops Stripe from automatically sending funds to your bank. Guardian may turn\n                    this off automatically when fraud is suspected. You can resume payouts once\n                    you've reviewed the transactions.\n                  </TooltipContent>\n                </Tooltip>\n                <Tooltip>\n                  <TooltipTrigger asChild>\n                    {/* Wrap Switch in a div to attach tooltip trigger easily */}\n                    <div className=\"flex items-center\">\n                      <Switch\n                        id={`payout-toggle-${selectedAccountId}`}\n                        checked={selectedAccountData.payouts_paused}\n                        onCheckedChange={handleTogglePayouts}\n                        disabled={isTogglingPayouts}\n                        aria-label=\"Toggle Payouts\"\n                      />\n                      {isTogglingPayouts && <Loader2 className=\"h-4 w-4 ml-2 animate-spin\" />}\n                    </div>\n                  </TooltipTrigger>\n                  <TooltipContent>{getPauseTooltipContent(selectedAccountData)}</TooltipContent>\n                </Tooltip>\n              </div>\n              {/* Auto Pause Toggle */}\n              <div className=\"flex items-center space-x-2\">\n                <Tooltip>\n                  <TooltipTrigger asChild>\n                    <span className=\"text-sm font-medium text-slate-600 flex items-center\">\n                      Auto-Pause Payouts\n                      <Info className=\"h-3 w-3 ml-1 text-muted-foreground\" />\n                    </span>\n                  </TooltipTrigger>\n                  <TooltipContent className=\"max-w-xs\">\n                    Automatically pause payouts on this account when a high-severity alert is\n                    triggered. Recommended for enhanced security.\n                  </TooltipContent>\n                </Tooltip>\n                <Switch\n                  id={`auto-pause-toggle-${selectedAccountId}`}\n                  checked={autoPause}\n                  onCheckedChange={toggleAutoPause}\n                  disabled={updatingAutoPause}\n                  aria-label=\"Toggle Auto-Pause\"\n                />\n                {updatingAutoPause && <Loader2 className=\"h-4 w-4 ml-2 animate-spin\" />}\n              </div>\n            </div>\n          </TooltipProvider>\n\n          {/* Alert Tabs */}\n          <Tabs defaultValue=\"active\">\n            <TabsList className=\"mb-4\">\n              <TabsTrigger value=\"active\">Active Alerts ({activeAlerts.length})</TabsTrigger>\n              <TabsTrigger value=\"resolved\">Resolved Alerts ({resolvedAlerts.length})</TabsTrigger>\n            </TabsList>\n            <TabsContent value=\"active\">\n              {loadingAlerts ? (\n                <div className=\"flex justify-center items-center h-40\">\n                  <Loader2 className=\"h-6 w-6 animate-spin text-slate-500\" />\n                  <span className=\"ml-2\">Loading alerts...</span>\n                </div>\n              ) : activeAlerts.length > 0 ? (\n                <AlertTable alerts={activeAlerts} onMarkResolved={markResolved} />\n              ) : (\n                <div className=\"text-center py-10 text-slate-500\">\n                  No active alerts for this account.\n                </div>\n              )}\n            </TabsContent>\n            <TabsContent value=\"resolved\">\n              {loadingAlerts ? (\n                <div className=\"flex justify-center items-center h-40\">\n                  <Loader2 className=\"h-6 w-6 animate-spin text-slate-500\" />\n                  <span className=\"ml-2\">Loading alerts...</span>\n                </div>\n              ) : resolvedAlerts.length > 0 ? (\n                <AlertTable alerts={resolvedAlerts} />\n              ) : (\n                <div className=\"text-center py-10 text-slate-500\">\n                  No resolved alerts for this account yet.\n                </div>\n              )}\n            </TabsContent>\n          </Tabs>\n        </>\n      )}\n      {/* Show loading spinner when switching accounts but not initial load */}\n      {!selectedAccountId && !initialLoading && allAccounts.length > 0 && (\n        <div className=\"flex justify-center items-center h-64\">\n          <Loader2 className=\"h-8 w-8 animate-spin text-slate-500\" />\n          <span className=\"ml-2\">Selecting account...</span>\n        </div>\n      )}\n    </Container>\n  );\n}\n\n// Alert table component\nfunction AlertTable({\n  alerts,\n  onMarkResolved,\n}: {\n  alerts: Alert[];\n  onMarkResolved?: (id: number) => void;\n}) {\n  const getSeverityBadge = (severity: string) => {\n    switch (severity) {\n      case 'high':\n        return (\n          <Badge variant=\"destructive\" className=\"capitalize\">\n            {severity}\n          </Badge>\n        );\n      case 'medium':\n        return (\n          <Badge variant=\"warning\" className=\"capitalize\">\n            {severity}\n          </Badge>\n        );\n      case 'low':\n      default:\n        return (\n          <Badge variant=\"secondary\" className=\"capitalize\">\n            {severity}\n          </Badge>\n        );\n    }\n  };\n\n  return (\n    <div className=\"overflow-x-auto\">\n      <table className=\"min-w-full divide-y divide-slate-200\">\n        <thead className=\"bg-slate-50\">\n          <tr>\n            <th className=\"px-6 py-3 text-left text-xs font-medium text-slate-500 uppercase tracking-wider\">\n              Timestamp\n            </th>\n            <th className=\"px-6 py-3 text-left text-xs font-medium text-slate-500 uppercase tracking-wider\">\n              Type\n            </th>\n            <th className=\"px-6 py-3 text-left text-xs font-medium text-slate-500 uppercase tracking-wider\">\n              Severity\n            </th>\n            <th className=\"px-6 py-3 text-left text-xs font-medium text-slate-500 uppercase tracking-wider\">\n              Message\n            </th>\n            <th className=\"px-6 py-3 text-left text-xs font-medium text-slate-500 uppercase tracking-wider\">\n              Risk Score\n            </th>\n            <th className=\"px-6 py-3 text-left text-xs font-medium text-slate-500 uppercase tracking-wider\">\n              Payout ID\n            </th>\n            <th className=\"px-6 py-3 text-left text-xs font-medium text-slate-500 uppercase tracking-wider\">\n              Actions\n            </th>\n          </tr>\n        </thead>\n        <tbody className=\"bg-white divide-y divide-slate-200\">\n          {alerts.map((alert) => (\n            <tr key={alert.id}>\n              <td className=\"px-6 py-4 whitespace-nowrap text-sm text-slate-500\">\n                {format(new Date(alert.created_at), 'MMM d, yyyy, h:mm a')}\n              </td>\n              <td className=\"px-6 py-4 whitespace-nowrap text-sm text-slate-900\">\n                {alert.alert_type}\n              </td>\n              <td className=\"px-6 py-4 whitespace-nowrap\">{getSeverityBadge(alert.severity)}</td>\n              <td className=\"px-6 py-4 text-sm text-slate-900 max-w-md truncate\">\n                {alert.message}\n              </td>\n              <td className=\"px-6 py-4 whitespace-nowrap text-sm text-slate-500\">\n                {alert.risk_score ?? 'N/A'}\n              </td>\n              <td className=\"px-6 py-4 whitespace-nowrap text-sm text-slate-500 font-mono\">\n                {alert.stripe_payout_id ? (\n                  <a\n                    href={`https://dashboard.stripe.com/payouts/${alert.stripe_payout_id}`}\n                    target=\"_blank\"\n                    rel=\"noopener noreferrer\"\n                    className=\"text-blue-600 hover:underline\"\n                  >\n                    {alert.stripe_payout_id.substring(0, 15)}...\n                  </a>\n                ) : (\n                  'N/A'\n                )}\n              </td>\n              <td className=\"px-6 py-4 whitespace-nowrap text-sm font-medium\">\n                {!alert.resolved && onMarkResolved && (\n                  <Button variant=\"outline\" size=\"sm\" onClick={() => onMarkResolved(alert.id)}>\n                    Mark Resolved\n                  </Button>\n                )}\n              </td>\n            </tr>\n          ))}\n        </tbody>\n      </table>\n    </div>\n  );\n}\n\n// Need to export the component wrapped in Suspense\nexport default function AlertsPage() {\n  return (\n    <Suspense fallback={<AlertsLoadingFallback />}>\n      <AlertsPageContent />\n    </Suspense>\n  );\n}\n\n// Fallback component for Suspense\nfunction AlertsLoadingFallback() {\n  return (\n    <Container className=\"py-10\">\n      <div className=\"flex justify-center items-center h-64\">\n        <Loader2 className=\"h-8 w-8 animate-spin text-slate-500\" />\n        <span className=\"ml-2\">Loading page...</span>\n      </div>\n    </Container>\n  );\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/michaelfuscoletti/Desktop/dock108home/app/stripe-guardian/analytics/page.tsx","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":157,"column":23,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":157,"endColumn":26,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5344,5347],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5344,5347],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":187,"column":23,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":187,"endColumn":26,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6306,6309],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6306,6309],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"'use client';\n\nimport React, { useState, useEffect, useMemo } from 'react';\nimport { useQuery } from '@tanstack/react-query';\nimport { createClient } from '@/utils/supabase/client';\nimport {\n  LineChart,\n  Line,\n  BarChart,\n  Bar,\n  XAxis,\n  YAxis,\n  CartesianGrid,\n  Tooltip,\n  ResponsiveContainer,\n  AreaChart,\n  Area,\n} from 'recharts';\nimport { Container } from '@/components/Container';\nimport { Card, CardContent, CardHeader, CardTitle, CardDescription } from '@/components/ui/card';\nimport { Alert as ShadcnAlert, AlertDescription, AlertTitle } from '@/components/ui/alert';\nimport { Loader2, AlertTriangle } from 'lucide-react';\nimport { format } from 'date-fns'; // For formatting dates on axes/tooltips\nimport { useUser } from '@/lib/hooks/useUser'; // Assuming hook to get user/profile\nimport { isPro } from '@/lib/guardian/plan'; // Assuming plan helper exists\nimport StripeAccountSelect from '@/app/components/StripeAccountSelect'; // Import account selector\nimport { Database } from '@/types/supabase'; // Reverted import path\n\n// Define SettingsRow type locally or import if available elsewhere\ntype SettingsRow = Database['public']['Tables']['settings']['Row'];\ntype ConnectedAccount = Database['public']['Tables']['connected_accounts']['Row'];\n\n// Placeholder types for view data - adjust based on actual view structure\ntype AlertsByDayData = { day: string; alerts: number }[];\ntype AlertsRuleRankData = { alert_type: string; alerts: number }[];\ntype FpRateRuleData = {\n  alert_type: string;\n  total_alerts: number;\n  fp_count: number;\n  fp_rate: number;\n}[];\ntype AvgRiskScoreData = { day: string; avg_risk: number }[];\n\n// --- Data Fetching Functions --- //\nconst fetchAnalyticsView = async (\n  viewName: string,\n  _accountId?: string | null,\n  _isPro?: boolean,\n) => {\n  const supabase = createClient();\n\n  // Note: Views currently DO NOT support account filtering.\n  // This function fetches global data regardless of accountId/isPro.\n  // Filtering logic needs to be added to the SQL views or use RPC functions.\n  // For now, the UI gating relies on the isPro flag passed to the component.\n  let query = supabase.from(viewName).select('*');\n\n  // Placeholder for future filtering logic:\n  // if (isPro && accountId) {\n  //   // Need RPC or modified view: e.g., supabase.rpc('get_view_data_for_account', { view_name: viewName, p_account_id: accountId })\n  // }\n\n  const { data, error } = await query;\n\n  if (error) {\n    console.error(`Error fetching ${viewName}:`, error);\n    throw new Error(`Failed to fetch ${viewName}: ${error.message}`);\n  }\n  return data;\n};\n\n// --- Helper to format date string --- //\nconst formatDateTick = (dateString: string) => {\n  try {\n    return format(new Date(dateString), 'MMM d'); // Format like 'Apr 26'\n  } catch {\n    return dateString; // Fallback\n  }\n};\n\n// --- Reusable Chart Card Component --- //\ninterface ChartCardProps {\n  title: string;\n  description: string;\n  isLoading: boolean;\n  isError: boolean;\n  error: Error | null;\n  children: React.ReactNode;\n}\n\nconst ChartCard: React.FC<ChartCardProps> = ({\n  title,\n  description,\n  isLoading,\n  isError,\n  error,\n  children,\n}) => {\n  return (\n    <Card>\n      <CardHeader>\n        <CardTitle>{title}</CardTitle>\n        <CardDescription>{description}</CardDescription>\n      </CardHeader>\n      <CardContent className=\"h-[300px]\">\n        {' '}\n        {/* Fixed height for consistency */}\n        {isLoading ? (\n          <div className=\"flex justify-center items-center h-full\">\n            <Loader2 className=\"h-8 w-8 animate-spin text-muted-foreground\" />\n          </div>\n        ) : isError ? (\n          <div className=\"flex justify-center items-center h-full\">\n            <ShadcnAlert variant=\"destructive\" className=\"w-auto\">\n              <AlertTriangle className=\"h-4 w-4\" />\n              <AlertTitle>Error loading data</AlertTitle>\n              <AlertDescription>{error?.message || 'An unknown error occurred'}</AlertDescription>\n            </ShadcnAlert>\n          </div>\n        ) : (\n          children\n        )}\n      </CardContent>\n    </Card>\n  );\n};\n\n// --- Main Analytics Page Component --- //\nexport default function AnalyticsPage() {\n  const supabase = createClient();\n  const { user, /* profile, */ isLoading: isLoadingUser } = useUser(); // Get user/profile info\n  const [allAccounts, setAllAccounts] = useState<ConnectedAccount[]>([]);\n  const [selectedAccountId, setSelectedAccountId] = useState<string | null>(null);\n  const [isLoadingAccounts, setIsLoadingAccounts] = useState(true);\n  const [settings, setSettings] = useState<SettingsRow | null>(null); // State for settings\n  const [isLoadingSettings, setIsLoadingSettings] = useState(true);\n\n  // Determine if user is Pro based on settings\n  const isProUser = useMemo(() => isPro(settings), [settings]);\n\n  // Fetch settings on mount or when user changes\n  useEffect(() => {\n    async function fetchSettingsData() {\n      if (!user) {\n        setIsLoadingSettings(false);\n        return;\n      }\n      setIsLoadingSettings(true);\n      try {\n        const { data, error } = await supabase\n          .from('settings')\n          .select('*')\n          .eq('id', 'global_settings') // Assuming global for now, adjust if per-user/account\n          .maybeSingle();\n        if (error) throw error;\n        setSettings(data);\n      } catch (error: any) {\n        console.error('Error fetching settings:', error);\n        // Optionally show toast\n      } finally {\n        setIsLoadingSettings(false);\n      }\n    }\n    fetchSettingsData();\n  }, [user, supabase]);\n\n  // Fetch connected accounts on mount or when user changes (needed for Pro dropdown)\n  useEffect(() => {\n    async function fetchUserAccounts() {\n      if (!user) {\n        setIsLoadingAccounts(false);\n        return;\n      }\n      setIsLoadingAccounts(true);\n      try {\n        const { data, error } = await supabase\n          .from('connected_accounts')\n          .select('*') // Select needed fields for dropdown\n          .eq('user_id', user.id);\n\n        if (error) throw error;\n        setAllAccounts(data || []);\n        // Set initial selection if not already set and accounts exist\n        if (!selectedAccountId && data && data.length > 0) {\n          setSelectedAccountId(data[0].stripe_account_id);\n        }\n      } catch (error: any) {\n        console.error('Error fetching connected accounts:', error);\n        setAllAccounts([]); // Clear accounts on error\n        // Optionally show toast\n      } finally {\n        setIsLoadingAccounts(false);\n      }\n    }\n    fetchUserAccounts();\n  }, [user, supabase, selectedAccountId]); // Add selectedAccountId dependency?\n\n  // Memoize fetchAccountId based on PRO status and selected account ID\n  const fetchAccountId = useMemo(() => {\n    // const { accountId, isPro } = args; // Removed unused destructured args\n    // Current logic always fetches global data, will change when filtering is implemented\n    // if (isPro && accountId) {\n\n    // This appears to be dead code - removed the reference to undefined error variable\n\n    // const profile = data; // Removed unused variable\n\n    // if (!profile?.is_pro) {\n    return null; // Always fetch global for now\n  }, []);\n\n  // --- React Query Hooks --- //\n  // Pass fetchAccountId to queryKey and queryFn\n  const {\n    data: alertsByDay,\n    isLoading: isLoadingAlertsByDay,\n    isError: isErrorAlertsByDay,\n    error: errorAlertsByDay,\n  } = useQuery<AlertsByDayData>({\n    queryKey: ['analytics', 'alerts_by_day', fetchAccountId],\n    queryFn: () => fetchAnalyticsView('alerts_by_day', fetchAccountId, isProUser),\n    enabled: !isLoadingSettings && !isLoadingUser, // Only fetch when user/settings known\n  });\n\n  const {\n    data: alertsRuleRank,\n    isLoading: isLoadingRuleRank,\n    isError: isErrorRuleRank,\n    error: errorRuleRank,\n  } = useQuery<AlertsRuleRankData>({\n    queryKey: ['analytics', 'alerts_rule_rank', fetchAccountId],\n    queryFn: () => fetchAnalyticsView('alerts_rule_rank', fetchAccountId, isProUser),\n    enabled: !isLoadingSettings && !isLoadingUser,\n  });\n\n  const {\n    data: fpRateRule,\n    isLoading: isLoadingFpRate,\n    isError: isErrorFpRate,\n    error: errorFpRate,\n  } = useQuery<FpRateRuleData>({\n    queryKey: ['analytics', 'fp_rate_rule', fetchAccountId],\n    queryFn: () => fetchAnalyticsView('fp_rate_rule', fetchAccountId, isProUser),\n    enabled: !isLoadingSettings && !isLoadingUser,\n  });\n\n  const {\n    data: avgRiskScore,\n    isLoading: isLoadingAvgRisk,\n    isError: isErrorAvgRisk,\n    error: errorAvgRisk,\n  } = useQuery<AvgRiskScoreData>({\n    queryKey: ['analytics', 'avg_risk_score', fetchAccountId],\n    queryFn: () => fetchAnalyticsView('avg_risk_score', fetchAccountId, isProUser),\n    enabled: !isLoadingSettings && !isLoadingUser,\n  });\n\n  // Memoize formatted data for charts to prevent re-renders\n  const formattedFpRateData = useMemo(() => {\n    return fpRateRule?.map((item) => ({ ...item, fp_percent: item.fp_rate * 100 })) || [];\n  }, [fpRateRule]);\n\n  // Combined loading state\n  const isLoading = isLoadingUser || isLoadingSettings || isLoadingAccounts;\n\n  if (isLoading) {\n    return (\n      <Container className=\"py-10\">\n        <div className=\"flex justify-center items-center h-64\">\n          <Loader2 className=\"h-8 w-8 animate-spin text-muted-foreground\" />\n        </div>\n      </Container>\n    );\n  }\n\n  return (\n    <Container className=\"py-10\">\n      <div className=\"flex flex-col md:flex-row items-start md:items-center justify-between mb-8 gap-4\">\n        <h1 className=\"text-3xl font-bold tracking-tight\">Guardian Analytics</h1>\n        {isProUser && allAccounts.length > 0 && (\n          <div className=\"w-full md:w-auto md:min-w-[250px]\">\n            <StripeAccountSelect\n              accounts={allAccounts}\n              selectedAccountId={selectedAccountId}\n              onAccountChange={setSelectedAccountId}\n            />\n          </div>\n        )}\n      </div>\n\n      {!isProUser && (\n        <ShadcnAlert className=\"mb-6\">\n          <AlertTriangle className=\"h-4 w-4\" />\n          <AlertTitle>Free Tier View</AlertTitle>\n          <AlertDescription>\n            You are viewing aggregated analytics data across all users. Upgrade to Pro to see data\n            specific to your connected accounts.\n            {/* Add link to billing page */}\n          </AlertDescription>\n        </ShadcnAlert>\n      )}\n\n      <div className=\"grid grid-cols-1 md:grid-cols-2 gap-6\">\n        {/* Card A: Alerts per day */}\n        <ChartCard\n          title=\"Alerts / Day (Last 30 Days)\"\n          description={\n            isProUser && selectedAccountId\n              ? `For account ${selectedAccountId}`\n              : 'Global daily alert volume.'\n          }\n          isLoading={isLoadingAlertsByDay}\n          isError={isErrorAlertsByDay}\n          error={errorAlertsByDay as Error | null}\n        >\n          {alertsByDay && (\n            <ResponsiveContainer width=\"100%\" height=\"100%\">\n              <LineChart data={alertsByDay} margin={{ top: 5, right: 20, bottom: 5, left: 0 }}>\n                <CartesianGrid strokeDasharray=\"3 3\" vertical={false} />\n                <XAxis dataKey=\"day\" tickFormatter={formatDateTick} fontSize={12} />\n                <YAxis allowDecimals={false} fontSize={12} />\n                <Tooltip\n                  contentStyle={{ fontSize: '12px', padding: '4px 8px' }}\n                  labelFormatter={formatDateTick}\n                />\n                <Line\n                  type=\"monotone\"\n                  dataKey=\"alerts\"\n                  stroke=\"#8884d8\"\n                  strokeWidth={2}\n                  dot={false}\n                />\n              </LineChart>\n            </ResponsiveContainer>\n          )}\n        </ChartCard>\n\n        {/* Card B: Top rules by count */}\n        <ChartCard\n          title=\"Top Rules by Count (Last 30 Days)\"\n          description={\n            isProUser && selectedAccountId\n              ? `For account ${selectedAccountId}`\n              : 'Global trigger frequency.'\n          }\n          isLoading={isLoadingRuleRank}\n          isError={isErrorRuleRank}\n          error={errorRuleRank as Error | null}\n        >\n          {alertsRuleRank && (\n            <ResponsiveContainer width=\"100%\" height=\"100%\">\n              <BarChart\n                data={alertsRuleRank}\n                layout=\"vertical\"\n                margin={{ top: 5, right: 20, bottom: 5, left: 30 }}\n              >\n                <CartesianGrid strokeDasharray=\"3 3\" horizontal={false} />\n                <XAxis type=\"number\" allowDecimals={false} fontSize={12} />\n                <YAxis\n                  dataKey=\"alert_type\"\n                  type=\"category\"\n                  width={100}\n                  fontSize={10}\n                  interval={0}\n                />\n                <Tooltip contentStyle={{ fontSize: '12px', padding: '4px 8px' }} />\n                <Bar dataKey=\"alerts\" fill=\"#82ca9d\" />\n              </BarChart>\n            </ResponsiveContainer>\n          )}\n        </ChartCard>\n\n        {/* Card C: False-positive % per rule */}\n        <ChartCard\n          title=\"False Positive Rate by Rule (Last 30 Days)\"\n          description={\n            isProUser && selectedAccountId\n              ? `For account ${selectedAccountId}`\n              : 'Global false positive rates.'\n          }\n          isLoading={isLoadingFpRate}\n          isError={isErrorFpRate}\n          error={errorFpRate as Error | null}\n        >\n          {formattedFpRateData && (\n            <ResponsiveContainer width=\"100%\" height=\"100%\">\n              <BarChart\n                data={formattedFpRateData}\n                layout=\"vertical\"\n                margin={{ top: 5, right: 20, bottom: 5, left: 30 }}\n              >\n                <CartesianGrid strokeDasharray=\"3 3\" horizontal={false} />\n                <XAxis type=\"number\" unit=\"%\" domain={[0, 100]} fontSize={12} />\n                <YAxis\n                  dataKey=\"alert_type\"\n                  type=\"category\"\n                  width={100}\n                  fontSize={10}\n                  interval={0}\n                />\n                <Tooltip\n                  formatter={(value) => `${Number(value).toFixed(1)}%`}\n                  contentStyle={{ fontSize: '12px', padding: '4px 8px' }}\n                />\n                <Bar dataKey=\"fp_percent\" fill=\"#ffc658\" name=\"False Positive %\" />\n              </BarChart>\n            </ResponsiveContainer>\n          )}\n        </ChartCard>\n\n        {/* Card D: Average risk score */}\n        <ChartCard\n          title=\"Average Risk Score (Last 7 Days)\"\n          description={\n            isProUser && selectedAccountId\n              ? `For account ${selectedAccountId}`\n              : 'Global average daily risk score.'\n          }\n          isLoading={isLoadingAvgRisk}\n          isError={isErrorAvgRisk}\n          error={errorAvgRisk as Error | null}\n        >\n          {avgRiskScore && (\n            <ResponsiveContainer width=\"100%\" height=\"100%\">\n              <AreaChart data={avgRiskScore} margin={{ top: 5, right: 20, bottom: 5, left: 0 }}>\n                <defs>\n                  <linearGradient id=\"colorAvgRisk\" x1=\"0\" y1=\"0\" x2=\"0\" y2=\"1\">\n                    <stop offset=\"5%\" stopColor=\"#ff7300\" stopOpacity={0.8} />\n                    <stop offset=\"95%\" stopColor=\"#ff7300\" stopOpacity={0} />\n                  </linearGradient>\n                </defs>\n                <CartesianGrid strokeDasharray=\"3 3\" vertical={false} />\n                <XAxis dataKey=\"day\" tickFormatter={formatDateTick} fontSize={12} />\n                <YAxis domain={[0, 100]} fontSize={12} />\n                <Tooltip\n                  formatter={(value) => Number(value).toFixed(1)}\n                  labelFormatter={formatDateTick}\n                  contentStyle={{ fontSize: '12px', padding: '4px 8px' }}\n                />\n                <Area\n                  type=\"monotone\"\n                  dataKey=\"avg_risk\"\n                  stroke=\"#ff7300\"\n                  fillOpacity={1}\n                  fill=\"url(#colorAvgRisk)\"\n                  name=\"Avg Risk\"\n                />\n              </AreaChart>\n            </ResponsiveContainer>\n          )}\n        </ChartCard>\n      </div>\n    </Container>\n  );\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/michaelfuscoletti/Desktop/dock108home/app/stripe-guardian/layout.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/michaelfuscoletti/Desktop/dock108home/app/stripe-guardian/onboard/page.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/michaelfuscoletti/Desktop/dock108home/app/stripe-guardian/opengraph-image.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/michaelfuscoletti/Desktop/dock108home/app/stripe-guardian/page.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/michaelfuscoletti/Desktop/dock108home/app/stripe-guardian/settings/accounts/page.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/michaelfuscoletti/Desktop/dock108home/app/stripe-guardian/settings/layout.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/michaelfuscoletti/Desktop/dock108home/app/stripe-guardian/settings/page.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/michaelfuscoletti/Desktop/dock108home/packages/common/src/formatters.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/michaelfuscoletti/Desktop/dock108home/packages/common/src/formatters.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/michaelfuscoletti/Desktop/dock108home/packages/common/src/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/michaelfuscoletti/Desktop/dock108home/packages/guardian-reactor/src/jobs/backfill.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":119,"column":27,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":119,"endColumn":30,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4696,4699],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4696,4699],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":172,"column":19,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":172,"endColumn":22,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6649,6652],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6649,6652],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { Stripe } from 'stripe';\nimport { createAdminClient } from '@/lib/supabase/admin';\nimport { log } from '@/lib/logger';\nimport { stripe } from '@/lib/stripe'; // Use the configured Stripe client\nimport { Database } from '@/types/supabase'; // Assuming generated types\n\nconst NINETY_DAYS_MS = 90 * 24 * 60 * 60 * 1000;\nconst BUFFER_INSERT_BATCH_SIZE = 100; // Adjust as needed\n\ntype BackfillStatusRecord = Database['public']['Tables']['account_backfill_status']['Row'];\n\nasync function updateBackfillStatus(\n  supabaseAdmin: ReturnType<typeof createAdminClient>,\n  accountId: string,\n  updates: Partial<Omit<BackfillStatusRecord, 'id' | 'account_id' | 'user_id' | 'created_at'>>,\n) {\n  const { error } = await supabaseAdmin\n    .from('account_backfill_status')\n    .update({ ...updates, updated_at: new Date().toISOString() })\n    .eq('account_id', accountId);\n\n  if (error) {\n    log.error({ accountId, error: error.message, updates }, 'Failed to update backfill status');\n    // Potentially throw or handle retry?\n  }\n}\n\nasync function getDecryptedTokens(\n  supabaseAdmin: ReturnType<typeof createAdminClient>,\n  accountId: string,\n): Promise<{ accessToken: string; refreshToken: string } | null> {\n  const keyId = process.env.SODIUM_ENCRYPTION_KEY_ID;\n  if (!keyId) {\n    log.error({ accountId }, 'SODIUM_ENCRYPTION_KEY_ID missing for token decryption.');\n    throw new Error('Encryption key configuration error.');\n  }\n\n  const { data, error } = await supabaseAdmin.rpc('get_decrypted_stripe_tokens', {\n    p_stripe_account_id: accountId,\n    p_key_id: keyId,\n  });\n\n  if (error) {\n    log.error(\n      { accountId, error: error.message },\n      'Failed to call get_decrypted_stripe_tokens RPC',\n    );\n    return null;\n  }\n\n  if (!data || !data.access_token || !data.refresh_token) {\n    log.warn({ accountId }, 'Decryption function returned null or incomplete tokens.');\n    return null;\n  }\n\n  return { accessToken: data.access_token, refreshToken: data.refresh_token };\n}\n\nexport async function processBackfill(accountId: string, userId: string): Promise<void> {\n  const supabaseAdmin = createAdminClient();\n  log.info({ accountId, userId }, 'Starting backfill process...');\n\n  try {\n    // 1. Mark as running\n    await updateBackfillStatus(supabaseAdmin, accountId, {\n      status: 'running',\n      progress: 0,\n      error_message: null,\n    });\n\n    // 2. Get Decrypted Tokens\n    // Note: This example uses the access token directly. In a real-world scenario,\n    // you might want to use the refresh token to get a fresh access token if needed,\n    // or preferably, use a restricted API key if possible for the backfill.\n    const tokens = await getDecryptedTokens(supabaseAdmin, accountId);\n    if (!tokens) {\n      throw new Error('Could not retrieve decrypted Stripe tokens.');\n    }\n\n    // Create a temporary Stripe client authenticated as the connected account\n    // WARNING: Be extremely careful with the access token. Do not log it.\n    // Consider if a more restricted key can be used/created for backfill.\n    const stripeAsAccount = new Stripe(process.env.STRIPE_SECRET_KEY!, {\n      apiVersion: stripe.VERSION, // Use same API version\n      stripeAccount: accountId,\n      // Note: Using the account's access token directly is generally discouraged for long-running server processes.\n      // The standard practice is to use the platform's secret key and the `stripeAccount` header.\n      // However, if `events.list` REQUIRES the access token for connected accounts (verify this in Stripe docs),\n      // this is necessary. If not, REMOVE this `apiKey` override.\n      apiKey: tokens.accessToken, // !! Use with caution - only if absolutely required !!\n    });\n\n    // 3. Calculate start time\n    const startTime = Math.floor((Date.now() - NINETY_DAYS_MS) / 1000);\n    const endTime = Math.floor(Date.now() / 1000); // Fetch up to now\n    const totalDuration = endTime - startTime;\n\n    log.info(\n      { accountId, startTime: new Date(startTime * 1000).toISOString() },\n      'Fetching events since 90 days ago.',\n    );\n\n    // 4. Fetch & Process Events\n    let eventBufferBatch: Partial<Database['public']['Tables']['event_buffer']['Insert']>[] = [];\n    let lastEventTimestamp = startTime;\n    let processedEventCount = 0;\n\n    for await (const event of stripeAsAccount.events.list({\n      created: { gte: startTime },\n      limit: 100,\n    })) {\n      // TODO: Filter for specific event types needed by Guardian if possible?\n      // enabled_events in webhook config doesn't filter historical events via API.\n\n      eventBufferBatch.push({\n        account_id: accountId,\n        event_id: event.id,\n        event_type: event.type,\n        payload: event as any, // Store the full event payload\n        source: 'backfill',\n        // status defaults to 'pending' in DB schema?\n      });\n\n      processedEventCount++;\n      lastEventTimestamp = event.created; // Keep track of the latest event time processed\n\n      if (eventBufferBatch.length >= BUFFER_INSERT_BATCH_SIZE) {\n        const { error: insertError } = await supabaseAdmin\n          .from('event_buffer')\n          .insert(eventBufferBatch);\n        if (insertError) {\n          throw new Error(`Failed to insert event buffer batch: ${insertError.message}`);\n        }\n        log.debug(\n          { accountId, count: eventBufferBatch.length },\n          'Inserted event batch into buffer.',\n        );\n        eventBufferBatch = []; // Reset batch\n\n        // Update progress - estimate based on time window covered\n        const elapsedDuration = lastEventTimestamp - startTime;\n        const progress = Math.min(\n          100,\n          Math.max(0, Math.floor((elapsedDuration / totalDuration) * 100)),\n        );\n        await updateBackfillStatus(supabaseAdmin, accountId, {\n          progress: progress,\n          status: 'running',\n        });\n      }\n    }\n\n    // Insert any remaining events in the last batch\n    if (eventBufferBatch.length > 0) {\n      const { error: insertError } = await supabaseAdmin\n        .from('event_buffer')\n        .insert(eventBufferBatch);\n      if (insertError) {\n        throw new Error(`Failed to insert final event buffer batch: ${insertError.message}`);\n      }\n      log.debug(\n        { accountId, count: eventBufferBatch.length },\n        'Inserted final event batch into buffer.',\n      );\n    }\n\n    log.info({ accountId, processedEventCount }, 'Backfill event fetching complete.');\n\n    // 5. Mark as complete\n    await updateBackfillStatus(supabaseAdmin, accountId, { status: 'completed', progress: 100 });\n    log.info({ accountId }, 'Backfill process completed successfully.');\n  } catch (error: any) {\n    log.error(\n      { accountId, userId, error: error.message, stack: error.stack },\n      'Error during backfill process',\n    );\n    // 6. Mark as failed\n    await updateBackfillStatus(supabaseAdmin, accountId, {\n      status: 'failed',\n      error_message: error.message,\n    });\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/michaelfuscoletti/Desktop/dock108home/packages/guardian-reactor/src/workers/notificationWorker.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":119,"column":49,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":119,"endColumn":52,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4555,4558],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4555,4558],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":193,"column":19,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":193,"endColumn":22,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7833,7836],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7833,7836],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":207,"column":27,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":207,"endColumn":30,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[8464,8467],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[8464,8467],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":247,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":247,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[9867,9870],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[9867,9870],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { SupabaseClient } from '@supabase/supabase-js';\nimport { Database, Tables /*, TablesInsert */ } from '@/types/supabase'; // Adjust path as needed\nimport { createAdminClient as getServiceSupabaseClient } from '@/lib/supabase/admin'; // Use admin client\nimport { log } from '@/lib/logger'; // Assuming logger\nimport { attemptSendEmail } from '@/supabase/functions/send-email-alert/index'; // Placeholder path - ADJUST\nimport { attemptSendSlack } from '@/supabase/functions/send-slack-alert/index'; // Placeholder path - ADJUST\nimport { notificationsSentTotal } from '@/lib/metrics/registry'; // Import metrics\n\nconst WORKER_NAME = 'notification-worker';\nconst BATCH_SIZE = 10; // How many notifications to process per iteration\nconst POLLING_INTERVAL_MS = 5000; // Check for new jobs every 5 seconds\nconst INITIAL_RETRY_DELAY_MS = 1000; // Base delay for retries\n\n// Helper to calculate exponential backoff with jitter\nfunction calculateNextAttemptTime(attempt: number): Date {\n  const delayMs = INITIAL_RETRY_DELAY_MS * Math.pow(2, attempt - 1); // 1s, 2s, 4s, 8s...\n  const jitter = delayMs * (Math.random() * 0.2 - 0.1); // Add +/- 10% jitter\n  return new Date(Date.now() + delayMs + jitter);\n}\n\n// Helper to fetch user notification preferences\nasync function getUserPrefs(supabase: SupabaseClient<Database>, userId: string) {\n  const { data, error } = await supabase\n    .from('user_notification_channels')\n    .select('email_to, email_enabled, slack_webhook_url, slack_enabled') // Fetch relevant fields\n    .eq('user_id', userId)\n    .maybeSingle();\n\n  if (error) {\n    log.error({ userId, error: error.message }, 'Error fetching user notification preferences');\n    return null;\n  }\n  return data;\n}\n\nasync function processNotificationJob(\n  supabase: SupabaseClient<Database>,\n  job: Tables<'notification_queue'>,\n) {\n  const baseLogData = {\n    worker: WORKER_NAME,\n    job_id: job.id,\n    alert_id: job.alert_id,\n    channel: job.channel,\n    attempt: job.attempt,\n  };\n  log.info(baseLogData, 'Processing notification job');\n\n  let metricStatus = 'error'; // Default metric status\n\n  try {\n    // 1. Fetch Alert\n    const { data: alert, error: alertError } = await supabase\n      .from('alerts')\n      .select('*, delivery_status') // Fetch delivery_status too\n      .eq('id', job.alert_id)\n      .single();\n\n    if (alertError || !alert) {\n      log.error(\n        { ...baseLogData, error: alertError?.message },\n        'Failed to fetch alert for notification job',\n      );\n      // Mark job as failed - cannot proceed\n      await supabase\n        .from('notification_queue')\n        .update({ status: 'failed', error_msg: 'Alert not found' })\n        .eq('id', job.id);\n      metricStatus = 'failed'; // Set status for metric reporting below\n      notificationsSentTotal.inc({ channel: job.channel, status: metricStatus });\n      return;\n    }\n\n    // 2. Fetch User ID from Connected Account\n    const { data: account, error: accountError } = await supabase\n      .from('connected_accounts')\n      .select('user_id')\n      .eq('stripe_account_id', alert.stripe_account_id)\n      .maybeSingle();\n\n    if (accountError || !account?.user_id) {\n      log.error(\n        {\n          ...baseLogData,\n          stripe_account_id: alert.stripe_account_id,\n          error: accountError?.message,\n        },\n        'Failed to fetch user_id for alert account',\n      );\n      await supabase\n        .from('notification_queue')\n        .update({ status: 'failed', error_msg: 'User ID not found for account' })\n        .eq('id', job.id);\n      metricStatus = 'failed'; // Set status for metric reporting below\n      notificationsSentTotal.inc({ channel: job.channel, status: metricStatus });\n      return;\n    }\n    const userId = account.user_id;\n\n    // 3. Fetch User Prefs\n    const userPrefs = await getUserPrefs(supabase, userId);\n    if (!userPrefs) {\n      log.warn(\n        { ...baseLogData, userId },\n        'User preferences not found, cannot determine channel config',\n      );\n      // Treat as not configured - don't retry\n      await supabase\n        .from('notification_queue')\n        .update({ status: 'failed', error_msg: 'User preferences not found' })\n        .eq('id', job.id);\n      metricStatus = 'not_configured'; // Specific status for this case\n      await updateAlertStatus(supabase, alert.id, { [job.channel]: metricStatus });\n      notificationsSentTotal.inc({ channel: job.channel, status: metricStatus });\n      return;\n    }\n\n    // 4. Check Channel Config & Send\n    let sendResult: { success: boolean; error?: any } = {\n      success: false,\n      error: 'Channel not configured or disabled',\n    };\n    let isConfigured = false;\n    const appUrl = process.env.NEXT_PUBLIC_APP_URL || 'https://www.dock108.ai';\n\n    if (job.channel === 'email' && userPrefs.email_enabled && userPrefs.email_to) {\n      isConfigured = true;\n      const resendApiKey = process.env.RESEND_API_KEY;\n      if (!resendApiKey) throw new Error('RESEND_API_KEY env var not set');\n      sendResult = await attemptSendEmail(resendApiKey, appUrl, alert, userPrefs.email_to);\n    } else if (job.channel === 'slack' && userPrefs.slack_enabled && userPrefs.slack_webhook_url) {\n      isConfigured = true;\n      sendResult = await attemptSendSlack(supabase, appUrl, alert, userPrefs.slack_webhook_url);\n    }\n\n    // 5. Update Queue and Alert Status based on result\n    if (!isConfigured) {\n      log.info(\n        { ...baseLogData, userId },\n        `Notification channel ${job.channel} is not configured or disabled for user.`,\n      );\n      await supabase\n        .from('notification_queue')\n        .update({ status: 'failed', error_msg: 'Channel not configured or disabled' })\n        .eq('id', job.id);\n      metricStatus = 'not_configured';\n      await updateAlertStatus(supabase, alert.id, { [job.channel]: metricStatus });\n    } else if (sendResult.success) {\n      log.info({ ...baseLogData }, 'Notification sent successfully');\n      await supabase.from('notification_queue').update({ status: 'sent' }).eq('id', job.id);\n      metricStatus = 'delivered';\n      await updateAlertStatus(supabase, alert.id, { [job.channel]: metricStatus });\n    } else {\n      const errorMessage =\n        sendResult.error?.message || String(sendResult.error) || 'Unknown send error';\n      log.warn({ ...baseLogData, error: errorMessage }, 'Notification send attempt failed');\n      metricStatus = 'failed'; // Set status for metric reporting below\n\n      if (job.attempt < job.max_attempts) {\n        const nextAttemptTime = calculateNextAttemptTime(job.attempt);\n        log.info(\n          { ...baseLogData, next_attempt_at: nextAttemptTime.toISOString() },\n          'Scheduling retry',\n        );\n        await supabase\n          .from('notification_queue')\n          .update({\n            status: 'queued',\n            next_attempt_at: nextAttemptTime.toISOString(),\n            error_msg: errorMessage,\n          })\n          .eq('id', job.id);\n        // Do not update alert status yet, it's still pending/retrying\n      } else {\n        log.error(\n          { ...baseLogData, error: errorMessage },\n          'Notification failed after max attempts',\n        );\n        await supabase\n          .from('notification_queue')\n          .update({ status: 'failed', error_msg: errorMessage })\n          .eq('id', job.id);\n        await updateAlertStatus(supabase, alert.id, { [job.channel]: metricStatus });\n        // Increment metric only on final failure\n        notificationsSentTotal.inc({ channel: job.channel, status: metricStatus });\n      }\n    }\n\n    // If not retrying (i.e., final failure or success/not_configured), increment metric\n    if (metricStatus !== 'failed' || job.attempt >= job.max_attempts) {\n      notificationsSentTotal.inc({ channel: job.channel, status: metricStatus });\n    }\n  } catch (error: any) {\n    log.error(\n      { ...baseLogData, error: error?.message },\n      'Critical error processing notification job',\n    );\n    metricStatus = 'error'; // Worker error status\n    notificationsSentTotal.inc({ channel: job.channel, status: metricStatus });\n    // Attempt to mark as failed to prevent infinite loops\n    try {\n      await supabase\n        .from('notification_queue')\n        .update({ status: 'failed', error_msg: `Worker error: ${error?.message}` })\n        .eq('id', job.id);\n      await updateAlertStatus(supabase, job.alert_id, { [job.channel]: metricStatus }); // Also mark alert\n    } catch (updateError: any) {\n      log.fatal(\n        { ...baseLogData, error: updateError?.message },\n        'FATAL: Failed to even mark job as failed after critical error',\n      );\n    }\n  }\n}\n\n// Main worker loop\nasync function notificationWorker() {\n  log.info({ worker: WORKER_NAME }, 'Worker started');\n  const supabase = getServiceSupabaseClient(); // Get client once\n\n  while (true) {\n    try {\n      log.debug({ worker: WORKER_NAME }, 'Fetching notification batch...');\n      const { data: jobs, error: fetchError } = await supabase.rpc('fetch_notification_batch', {\n        p_limit: BATCH_SIZE,\n      });\n\n      if (fetchError) {\n        log.error(\n          { worker: WORKER_NAME, error: fetchError.message },\n          'Error fetching notification batch',\n        );\n        // Wait before retrying fetch\n        await new Promise((resolve) => setTimeout(resolve, POLLING_INTERVAL_MS * 2));\n        continue;\n      }\n\n      if (!jobs || jobs.length === 0) {\n        log.debug({ worker: WORKER_NAME }, 'No pending notifications found, sleeping...');\n        await new Promise((resolve) => setTimeout(resolve, POLLING_INTERVAL_MS));\n        continue;\n      }\n\n      log.info({ worker: WORKER_NAME, count: jobs.length }, 'Processing batch...');\n      // Process jobs concurrently (adjust concurrency as needed)\n      await Promise.all(jobs.map((job) => processNotificationJob(supabase, job)));\n    } catch (error: any) {\n      log.error({ worker: WORKER_NAME, error: error?.message }, 'Error in worker main loop');\n      // Wait longer after a loop error\n      await new Promise((resolve) => setTimeout(resolve, POLLING_INTERVAL_MS * 3));\n    }\n  }\n}\n\n// --- Helper: Update Alert Delivery Status (Copied from send-email-alert) --- //\nasync function updateAlertStatus(\n  supabase: SupabaseClient<Database>,\n  alertId: number | string,\n  status: { [key: string]: string },\n) {\n  // Fetch existing status, merge, and update\n  const { data: currentAlert, error: fetchError } = await supabase\n    .from('alerts')\n    .select('delivery_status')\n    .eq('id', alertId)\n    .single();\n\n  if (fetchError) {\n    log.error({ alertId, error: fetchError?.message }, 'Error fetching alert to update status');\n    return; // Or throw?\n  }\n\n  const currentStatus = (currentAlert?.delivery_status || {}) as { [key: string]: string };\n  const newStatus = { ...currentStatus, ...status };\n\n  const { error: updateError } = await supabase\n    .from('alerts')\n    .update({ delivery_status: newStatus })\n    .eq('id', alertId);\n\n  if (updateError) {\n    log.error({ alertId, error: updateError?.message }, 'Error updating delivery_status');\n  }\n}\n\nexport default notificationWorker;\n","usedDeprecatedRules":[]}]