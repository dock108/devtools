/// <reference types=\"cypress\" />\n\ndescribe(\'Guardian Full Stack E2E Test\', () => {\n  // Use environment variables set in the GitHub Actions workflow\n  const testUserId = Cypress.env(\'TEST_USER_ID\');\n  const testStripeAccountId = Cypress.env(\'TEST_STRIPE_ACCOUNT_ID\');\n\n  beforeEach(() => {\n    // Use cy.login() if configured, otherwise manually handle auth if needed\n    // For this test, assuming direct Supabase access might be simpler via tasks\n    // or potentially setting a test cookie if your auth allows.\n    // cy.login(testUserId);\n\n    // Since auth might be complex in CI, let\'s just visit the page\n    // and rely on Cypress tasks for DB verification later.\n    cy.visit(\'/\'); // Visit a page that loads the Header\n    cy.log(`Running test as simulated user: ${testUserId} for account: ${testStripeAccountId}`);\n\n  });\n\n  it(\'should show alert badge after event replay, allow marking as read\', () => {\n    // Pre-condition: The GH Action should have already replayed events\n    // and waited for processing before running this test.\n\n    // 1. Assert nav badge shows > 0 (wait for realtime/initial load)\n    cy.log(\'Waiting for alert badge to appear...\');\n    // Use a less specific selector to find the badge element itself\n    cy.get(\'[aria-label*=\"View alerts\"] span\', { timeout: 20000 }) // Increased timeout\n      .should(\'be.visible\')\n      .invoke(\'text\')\n      .then(parseInt)\n      .should(\'be.greaterThan\', 0);\n\n    // Capture the initial count for later verification\n    let initialBadgeCount = 0;\n    cy.get(\'[aria-label*=\"View alerts\"] span\').then(($span) => {\n        const text = $span.text();\n        initialBadgeCount = text.includes(\'+\') ? 99 : parseInt(text);\ // Handle 9+\n        cy.log(`Initial badge count observed: ${initialBadgeCount}`);\n    });\n\n    // 2. Click badge → navigate to /guardian/alerts\n    cy.log(\'Clicking alert bell icon link...\');\n    cy.get(\'[aria-label*=\"View alerts\"]\').first().click();\n    cy.url().should(\'include\', \'/guardian/alerts\');\n    cy.log(\'Navigated to alerts page.\');\n\n    // 3. Assert table lists expected alert types (basic check)\n    // This depends heavily on your fixture file and alert table structure\n    cy.log(\'Checking for alerts in the table...\');\n    cy.contains(\'h1\', \'Guardian Alerts\', { timeout: 10000 }).should(\'be.visible\');\n    // Check for presence of specific alert types from your fixture\n    cy.contains(\'td\', \'velocity-breach\', { timeout: 5000 }).should(\'exist\');\n    cy.contains(\'td\', \'bank-swap\', { timeout: 5000 }).should(\'exist\');\n    // Add more checks based on fixture file\n\n    // 4. Mark all read → badge disappears.\n    // The navigation to /guardian/alerts via the bell icon should trigger markAllRead\n    cy.log(\'Verifying alert badge disappears after navigation...\');\n    cy.get(\'[aria-label*=\"View alerts\"] span\').should(\'not.exist\');\n\n    // 5. Verify reads in DB (optional but recommended)\n    // Use a task to check that *at least* initialBadgeCount alerts are marked as read for the user\n    cy.log(\'Verifying alerts marked as read in database...\');\n    cy.then(() => { // Ensure initialBadgeCount has been set\n        cy.task(\'checkAlertReadCount\', { userId: testUserId, minCount: initialBadgeCount }, { timeout: 10000 })\n          .should(\'be.true\'); // Task returns true if count >= minCount\n    });\n  });\n}); 